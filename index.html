<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Set up character encoding and responsive viewport -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MalScape</title>
  <style>
    /* Import a cool font from Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    /* Basic resets and base styling */
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      color: #333;
      background-color: #f8f9fa;
    }
    body { display: flex; }
    
    /* Containers for main layout */
    #main-container {
      flex: 1;
      padding: 24px;
      height: 100vh;
      overflow-y: auto;
    }
    #legend-container {
      width: 220px; /* reduced width */
      background-color: #fff;
      border-left: 1px solid #e9ecef;
      padding: 16px 12px; /* reduced padding */
      height: 100vh;
      overflow-y: auto;
      box-shadow: -4px 0 8px rgba(0, 0, 0, 0.05);
    }
    
    /* Header styles */
    h2 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 28px;
      font-weight: 600;
      border-bottom: 2px solid #4299e1;
      padding-bottom: 8px;
      display: inline-block;
    }
    
    h3 {
      color: #2c3e50;
      font-size: 16px; /* smaller legend header */
      margin-top: 0;
      margin-bottom: 12px;
      font-weight: 600;
    }
    
    /* Styling for controls and inputs */
    .control-group {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    label {
      display: inline-block;
      margin-right: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    input[type="text"], input[type="file"], input[type="range"], select {
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      margin-right: 12px;
      margin-bottom: 8px;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, input[type="range"]:focus, select:focus {
      border-color: #4299e1;
      outline: none;
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.15);
    }
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-right: 8px;
    }
    button:hover { background-color: #3182ce; }
    #unselectButton { background-color: #e53e3e; }
    #unselectButton:hover { background-color: #c53030; }
    #loadMoreBtn {
      display: none;
      margin-top: 16px;
      background-color: #38a169;
    }
    #loadMoreBtn:hover { background-color: #2f855a; }
    
    /* Style for the network visualization area */
    #cy {
      width: 100%;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      background-color: #fff;
    }
    
    /* Tooltip styling */
    #tooltip {
      position: absolute;
      display: none;
      background: #fff;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 13px;
      color: #2d3748;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-width: 300px;
      line-height: 1.5;
    }
    
    /* Table styling */
    #table-container {
      margin-top: 24px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    th, td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
      white-space: normal;
      word-wrap: break-word;
    }
    
    /* Toggle for full payload view */
    .payload-toggle {
      cursor: pointer;
      color: #4299e1;
      text-decoration: underline;
      display: block;
      margin-top: 5px;
      font-size: 12px;
    }
    .payload-toggle:hover { color: #3182ce; }
    .payload-truncated { max-height: 100px; overflow: hidden; }
    .payload-full { max-height: none; }
    
    /* Overlay shown while loading data */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 18px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #loadingOverlay span {
      background: #2d3748;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
    }
    #loadingOverlay span::before {
      content: '';
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid transparent;
      border-top-color: #fff;
      border-radius: 50%;
      margin-right: 12px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Legend color box styling */
    .color-box {
      display: inline-block;
      width: 12px;  /* smaller size */
      height: 12px; /* smaller size */
      vertical-align: middle;
      margin-right: 4px;
      border: 1px solid #ccc;
    }
    #legend {
      font-size: 12px; /* reduce font size for the legend */
      line-height: 1.4;
    }
    #legend th, #legend td {
      padding: 4px 6px; /* smaller padding */
    }
    
    /* Adjust layout for smaller screens */
    @media (max-width: 1200px) {
      body { flex-direction: column; }
      #legend-container {
        width: 100%;
        height: auto;
        max-height: 300px;
        border-left: none;
        border-top: 1px solid #e9ecef;
        box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.05);
      }
      #main-container { height: auto; padding: 16px; }
    }
  </style>

  <!-- Load Cytoscape for network graphs -->
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <!-- Load Pyodide to run Python code in the browser -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
</head>
<body>
  <!-- Overlay to show loading state -->
  <div id="loadingOverlay">
    <span>Processing data, please wait...</span>
  </div>

  <!-- Main content area -->
  <div id="main-container">
    <h2>MalScape</h2>

    <!-- Input section for IPs and CSV upload -->
    <div class="control-group">
      <div>
        <label for="startSource">Start Source IP:</label>
        <input type="text" id="startSource" placeholder="e.g. 192.168.1.10" />
        <label for="startDestination">Start Destination IP:</label>
        <input type="text" id="startDestination" placeholder="e.g. 10.0.0.50" />
        <button id="selectEdgeButton">Select Edge</button>
      </div>
      <div style="margin-top: 16px;">
        <label for="fileInput">Upload CSV Data:</label>
        <input type="file" id="fileInput" accept=".csv" />
      </div>
    </div>

    <!-- Timeline control with speed options -->
    <div class="control-group">
      <label for="timeSlider">Timeline:</label>
      <input type="range" id="timeSlider" min="1" max="100" value="100">
      <span id="timeDisplay"></span>
      <button id="playButton">▶</button>
      <select id="speedSelector">
        <option value="1">1x</option>
        <option value="2">2x</option>
        <option value="4">4x</option>
        <option value="16">16x</option>
        <option value="32">32x</option>
        <option value="32">64x</option>
        <option value="32">124x</option>
      </select>
    </div>

    <!-- Visualization filter controls -->
    <div class="control-group" id="visFilterGroup">
      <label for="visFilterColumn">Filter Column:</label>
      <select id="visFilterColumn">
        <option value="No.">No.</option>
        <option value="Time">Time</option>
        <option value="Source">Source</option>
        <option value="Destination">Destination</option>
        <option value="Protocol">Protocol</option>
        <option value="Length">Length</option>
        <option value="Payload">Payload</option>
      </select>
      <!-- Searchable input for filtering keywords -->
      <label for="keywordInput">Keyword:</label>
      <input type="text" id="keywordInput" list="keywordOptions" placeholder="Select or search keyword" />
      <datalist id="keywordOptions">
        <!-- Options will be added dynamically -->
      </datalist>
      <button id="applyVisFilterBtn">Apply Visualization Filter</button>
      <button id="clearVisFilterBtn">Clear Filter</button>
      <button id="unselectButton">Unselect All Edges</button>
    </div>

    <!-- Area for Cytoscape network graph -->
    <div id="cy"></div>
    
    <!-- Tooltip for nodes and edges -->
    <div id="tooltip"></div>
    
    <div class="control-group">
      <div style="margin-top: 16px;">
        <label for="infoFilterInput">Search Payload:</label>
        <input type="text" id="infoFilterInput" placeholder="Enter search keyword" />
      </div>
    </div>

    <!-- Table to display CSV data -->
    <div id="table-container"></div>
    <button id="loadMoreBtn">Load More Rows</button>
  </div>

  <!-- Sidebar for protocol legend -->
  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <tr><th>Protocol</th><th>Color</th><th>Description</th></tr>
      <tr>
        <td>DNS</td>
        <td><span class="color-box" style="background-color:#6BAED6"></span></td>
        <td>DNS Traffic</td>
      </tr>
      <tr>
        <td>FTP</td>
        <td><span class="color-box" style="background-color:#3182BD"></span></td>
        <td>FTP Traffic</td>
      </tr>
      <tr>
        <td>FTP-DATA</td>
        <td><span class="color-box" style="background-color:#08519C"></span></td>
        <td>FTP Data Channel</td>
      </tr>
      <tr>
        <td>HTTP</td>
        <td><span class="color-box" style="background-color:#FF7F0E"></span></td>
        <td>HTTP Traffic</td>
      </tr>
      <tr>
        <td>SMB</td>
        <td><span class="color-box" style="background-color:#2CA02C"></span></td>
        <td>SMB File Sharing</td>
      </tr>
      <tr>
        <td>SMTP</td>
        <td><span class="color-box" style="background-color:#000000"></span></td>
        <td>Email Traffic (SMTP)</td>
      </tr>
      <tr>
        <td>SMTP/IMF</td>
        <td><span class="color-box" style="background-color:#FF9896"></span></td>
        <td>Email Traffic (IMF)</td>
      </tr>
      <tr>
        <td>SSH</td>
        <td><span class="color-box" style="background-color:#9467BD"></span></td>
        <td>SSH Traffic</td>
      </tr>
      <tr>
        <td>STP</td>
        <td><span class="color-box" style="background-color:#8C564B"></span></td>
        <td>Spanning Tree Protocol</td>
      </tr>
      <tr>
        <td>TCP</td>
        <td><span class="color-box" style="background-color:#17BECF"></span></td>
        <td>TCP Traffic (default)</td>
      </tr>
      <tr>
        <td>TLSv1</td>
        <td><span class="color-box" style="background-color:#BCBD22"></span></td>
        <td>TLS v1 Encrypted Traffic</td>
      </tr>
    </table>
  </div>

  <script>
    // Warn the user before they leave the page
    window.addEventListener('beforeunload', (e) => {
      e.preventDefault();
      e.returnValue = '';
    });

    // Global variables used throughout the app
    let pyodide;
    let globalCsvText = "";
    let csvRows = [];
    let csvHeaders = [];
    let selectedEdges = new Set();
    let globalCy;
    let payloadColumnIndex = -1;
    
    // For filtering the visualization based on CSV data
    let currentVisFilter = null;
    
    let allRowElems = [];
    let displayOffset = 0;
    const PAGE_SIZE = 50;
    let currentAllowed = [];
    
    // Grab references to important DOM elements
    const fileInput = document.getElementById('fileInput');
    const tooltip = document.getElementById('tooltip');
    const unselectButton = document.getElementById('unselectButton');
    const startSourceInput = document.getElementById('startSource');
    const startDestinationInput = document.getElementById('startDestination');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const selectEdgeButton = document.getElementById('selectEdgeButton');
    const payloadFilterInput = document.getElementById('infoFilterInput');
    const timeSlider = document.getElementById('timeSlider');
    const timeDisplay = document.getElementById('timeDisplay');
    const playButton = document.getElementById('playButton');
    const speedSelector = document.getElementById('speedSelector');
    
    // Controls for visualization filtering
    const visFilterColumn = document.getElementById('visFilterColumn');
    const keywordInput = document.getElementById('keywordInput');
    const keywordOptions = document.getElementById('keywordOptions');
    const applyVisFilterBtn = document.getElementById('applyVisFilterBtn');
    const clearVisFilterBtn = document.getElementById('clearVisFilterBtn');
    
    let playInterval;
    let isPlaying = false;
    
    // Update keyword suggestions when the selected filter column changes
    visFilterColumn.addEventListener('change', () => {
      updateKeywordSuggestions();
    });
    
    // Toggle play/pause for the timeline with adjustable speed
    playButton.addEventListener('click', () => {
      if (!isPlaying) {
        playButton.textContent = '⏸';
        isPlaying = true;
        playInterval = setInterval(() => {
          let currentValue = parseInt(timeSlider.value);
          let maxValue = parseInt(timeSlider.max);
          let speed = parseFloat(speedSelector.value) || 1;
          let increment = 50 * speed;
          if (currentValue < maxValue) {
            timeSlider.value = Math.min(currentValue + increment, maxValue);
            updateTimeFilter();
          } else {
            clearInterval(playInterval);
            playButton.textContent = '▶';
            isPlaying = false;
          }
        }, 200);
      } else {
        clearInterval(playInterval);
        playButton.textContent = '▶';
        isPlaying = false;
      }
    });
    
    // Update table rows based on payload filter input
    payloadFilterInput.addEventListener('input', () => {
      updateRowVisibility();
    });
    
    // Apply the visualization filter using the keyword from the input
    applyVisFilterBtn.addEventListener('click', () => {
      const col = visFilterColumn.value;
      const keyword = keywordInput.value.trim().toLowerCase();
      if (!keyword) {
        alert("Please select or type a keyword.");
        return;
      }
      currentVisFilter = { column: col, keyword: keyword };
      applyVisualizationFilter();
    });
    
    // Remove the visualization filter and reset view
    clearVisFilterBtn.addEventListener('click', () => {
      currentVisFilter = null;
      // Show all selected edges
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          edge.show();
        }
      });
      globalCy.nodes().forEach(node => node.show());
      // Clear the keyword input field
      keywordInput.value = "";
    });
    
    // Button to select a specific edge by matching source and destination IPs
    selectEdgeButton.addEventListener('click', () => {
      const src = startSourceInput.value.trim();
      const dst = startDestinationInput.value.trim();
      if (!src || !dst) {
        alert("Please enter both Source and Destination IP.");
        return;
      }
      let foundEdge = null;
      globalCy.edges().some(edge => {
        if (edge.data('source') === src && edge.data('target') === dst) {
          foundEdge = edge;
          return true;
        }
      });
      if (foundEdge) {
        foundEdge.addClass('selected');
        (foundEdge.data('csvIndices') || []).forEach(idx => selectedEdges.add(idx));
        globalCy.animate({
          fit: { eles: foundEdge, padding: 50 },
          duration: 500
        });
        updateKeywordSuggestions();
        updateRowVisibility();
      } else {
        alert("No matching edge found for the given Source and Destination IP.");
      }
    });
    
    // Unselect all currently selected edges
    unselectButton.addEventListener('click', () => {
      selectedEdges.clear();
      if (globalCy) {
        globalCy.edges().removeClass('selected');
      }
      updateKeywordSuggestions();
      updateRowVisibility();
    });
    
    // Load additional rows in the table (pagination)
    loadMoreBtn.addEventListener('click', () => {
      displayOffset += PAGE_SIZE;
      showNextChunk();
    });
    
    // Set up the timeline slider based on network node times
    function setupTimeSlider() {
      let maxTime = 0;
      globalCy.nodes().forEach(node => {
        if (node.data('timeIndex') > maxTime) {
          maxTime = node.data('timeIndex');
        }
      });
      timeSlider.min = 1;
      timeSlider.max = maxTime;
      timeSlider.value = maxTime;
      timeDisplay.textContent = "Time cutoff: " + maxTime;
      timeSlider.addEventListener('input', updateTimeFilter);
      updateTimeFilter();
    }
    
    // Update the network graph based on the timeline slider value
    function updateTimeFilter() {
      let timeValue = parseInt(timeSlider.value);
      timeDisplay.textContent = "Time cutoff: " + timeValue;
      if (!globalCy) return;
      globalCy.nodes().forEach(node => {
        if (node.data('timeIndex') <= timeValue) {
          node.show();
        } else {
          node.hide();
        }
      });
      globalCy.edges().forEach(edge => {
        if (edge.source().visible() && edge.target().visible()) {
          edge.show();
        } else {
          edge.hide();
        }
      });
    }
    
    // Update the datalist options for keyword suggestions based on the selected CSV column
    function updateKeywordSuggestions() {
      // Clear out previous suggestions
      keywordOptions.innerHTML = "";
      let uniqueKeywords = new Set();
      const col = visFilterColumn.value;
      const colIndex = csvHeaders.indexOf(col);
      if (colIndex === -1) return;
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          let indices = edge.data('csvIndices') || [];
          indices.forEach(idx => {
            if (idx < 1 || idx >= csvRows.length) return;
            let row = csvRows[idx].split(',').map(s => s.replace(/(^"|"$)/g, ''));
            uniqueKeywords.add(row[colIndex].trim());
          });
        }
      });
      // Add unique keywords to the datalist
      uniqueKeywords.forEach(keyword => {
        if (keyword) {
          let option = document.createElement('option');
          option.value = keyword;
          keywordOptions.appendChild(option);
        }
      });
    }
    
    // Filter the visualization to only show selected edges matching the keyword
    function applyVisualizationFilter() {
      if (!currentVisFilter) return;
      let colIndex = csvHeaders.indexOf(currentVisFilter.column);
      if (colIndex === -1) {
        alert("Selected column not found in CSV headers.");
        return;
      }
      // Loop over selected edges and hide/show based on filter match
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          let showEdge = false;
          let indices = edge.data('csvIndices') || [];
          for (let idx of indices) {
            if (idx < 1 || idx >= csvRows.length) continue;
            let row = csvRows[idx].split(',').map(s => s.replace(/(^"|"$)/g, ''));
            let cellValue = row[colIndex].toLowerCase();
            if (cellValue.indexOf(currentVisFilter.keyword) !== -1) {
              showEdge = true;
              break;
            }
          }
          if (showEdge) {
            edge.show();
          } else {
            edge.hide();
          }
        }
      });
    }
    
    // Load Pyodide and necessary Python packages for CSV processing
    async function loadPyodideAndPackages() {
      pyodide = await loadPyodide();
      await pyodide.loadPackage(['pandas', 'micropip']);
      await pyodide.runPythonAsync(`
import micropip
await micropip.install(['ipaddress'])
      `);
    }
    loadPyodideAndPackages();
    
    // Process the CSV file when the user uploads it
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadingOverlay.style.display = "flex";
      try {
        const text = await file.text();
        const userSource = startSourceInput.value.trim();
        const userDestination = startDestinationInput.value.trim();
        const processedCSV = await runPythonScript(text, userSource, userDestination);
        globalCsvText = processedCSV;
        csvRows = processedCSV.trim().split('\n');
        csvHeaders = csvRows[0].split(',').map(s => s.replace(/(^"|"$)/g, ''));
        createFullTable();
        visualizeNetwork(parseCSV(processedCSV));
        setupTimeSlider();
        if (userSource && userDestination) {
          globalCy.edges().forEach(edge => {
            if (edge.data('source') === userSource && edge.data('target') === userDestination) {
              edge.addClass('selected');
              (edge.data('csvIndices') || []).forEach(idx => selectedEdges.add(idx));
            }
          });
          updateKeywordSuggestions();
          updateRowVisibility();
        }
      } catch (err) {
        console.error("Error processing file:", err);
        alert("An error occurred while processing the CSV. See console for details.");
      } finally {
        loadingOverlay.style.display = "none";
      }
    });
    
    // Run a Python script via Pyodide to process CSV text
    async function runPythonScript(csvText, startSource, startDestination) {
      const pythonScript = `
import csv
import pandas as pd
from ipaddress import ip_address, ip_network
from io import StringIO
import re

internal_subnets = [
    ip_network('172.28.0.0/16'),
    ip_network('192.168.61.0/24')
]

def classify_ip(ip):
    try:
        ip_obj = ip_address(ip)
        return 'Internal' if any(ip_obj in subnet for subnet in internal_subnets) else 'External'
    except ValueError:
        return 'Invalid IP'

def process_csv(csv_text, start_source=None, start_destination=None):
    df = pd.read_csv(StringIO(csv_text), dtype=str)
    if not all(x in df.columns for x in ["Source", "Destination"]):
        raise ValueError("Missing required column: Source or Destination")
    if start_source and start_destination:
        matches = df.index[(df['Source'] == start_source) & (df['Destination'] == start_destination)]
        if len(matches) > 0:
            df = df.loc[matches[0]:].reset_index(drop=True)
    if "Info" in df.columns:
        df.rename(columns={"Info": "Payload"}, inplace=True)
    connection_counts = df.groupby(["Source","Destination"])["Source"].transform("count")
    node_weights = connection_counts.copy()
    edge_weights = connection_counts.copy()
    if node_weights.max() != node_weights.min():
        node_weights = (node_weights - node_weights.min()) / (node_weights.max() - node_weights.min())
    else:
        node_weights = pd.Series(1.0, index=node_weights.index)
    if edge_weights.max() != edge_weights.min():
        edge_weights = (edge_weights - edge_weights.min()) / (edge_weights.max() - edge_weights.min())
    else:
        edge_weights = pd.Series(1.0, index=edge_weights.index)
    df["SourceClassification"] = df["Source"].apply(classify_ip)
    df["DestinationClassification"] = df["Destination"].apply(classify_ip)
    if "Payload" in df.columns:
        df["Payload"] = df["Payload"].apply(lambda x: x.replace(',', '/') if pd.notna(x) else x)
    out = StringIO()
    df.to_csv(out, index=False, quoting=csv.QUOTE_MINIMAL)
    return out.getvalue()

processed = process_csv(csv_text, start_source="${startSource}", start_destination="${startDestination}")
`;
      pyodide.globals.set("csv_text", csvText);
      await pyodide.runPythonAsync(pythonScript);
      return pyodide.globals.get("processed");
    }
    
    // Create an HTML table from the CSV rows
    function createFullTable() {
      const container = document.getElementById('table-container');
      container.innerHTML = '';
      allRowElems = [];
      if (csvRows.length < 2) return;
      const table = document.createElement('table');
      const hdrLine = csvRows[0];
      const hdrCols = hdrLine.split(',').map(c => c.replace(/(^"|"$)/g, ''));
      payloadColumnIndex = hdrCols.findIndex(col => col.toLowerCase() === "payload");
      const hdrTr = document.createElement('tr');
      hdrCols.forEach(col => {
        let th = document.createElement('th');
        th.textContent = col;
        hdrTr.appendChild(th);
      });
      table.appendChild(hdrTr);
      for (let i = 1; i < csvRows.length; i++) {
        let tr = document.createElement('tr');
        tr.setAttribute('data-index', i);
        let cols = csvRows[i].split(',');
        cols.forEach(c => {
          let td = document.createElement('td');
          td.textContent = c.replace(/(^"|"$)/g, '');
          tr.appendChild(td);
        });
        tr.addEventListener('click', function() {
          const rowIndex = parseInt(this.getAttribute('data-index'));
          if (globalCy) {
            let targetEdge = null;
            globalCy.edges().some(edge => {
              if ((edge.data('csvIndices') || []).includes(rowIndex)) {
                targetEdge = edge;
                return true;
              }
              return false;
            });
            if (targetEdge) {
              globalCy.edges().removeClass('selected');
              selectedEdges.clear();
              targetEdge.addClass('selected');
              (targetEdge.data('csvIndices') || []).forEach(idx => selectedEdges.add(idx));
              updateKeywordSuggestions();
              globalCy.animate({
                fit: { eles: targetEdge, padding: 50 },
                duration: 500
              });
              updateRowVisibility();
            }
          }
        });
        table.appendChild(tr);
        allRowElems.push(tr);
      }
      container.appendChild(table);
      displayOffset = 0;
      updateRowVisibility();
    }
    
    // Update table rows visibility based on filter and selection
    function updateRowVisibility() {
      if (!csvRows || csvRows.length < 2 || allRowElems.length === 0) return;
      let allowed = [];
      if (selectedEdges.size === 0) {
        for (let i = 1; i < csvRows.length; i++){
          allowed.push(i);
        }
      } else {
        allowed = Array.from(selectedEdges);
      }
      allowed.sort((a, b) => a - b);
      const filterText = payloadFilterInput.value.trim().toLowerCase();
      if (filterText && payloadColumnIndex !== -1) {
        allowed = allowed.filter(rowIndex => {
          let rowElem = allRowElems[rowIndex - 1];
          if (rowElem && rowElem.cells && rowElem.cells.length > payloadColumnIndex) {
            let cellText = rowElem.cells[payloadColumnIndex].textContent.toLowerCase();
            return cellText.includes(filterText);
          }
          return false;
        });
      }
      allRowElems.forEach(row => row.style.display = 'none');
      currentAllowed = allowed;
      displayOffset = 0;
      showNextChunk();
    }
    
    // Show the next set of table rows (pagination)
    function showNextChunk() {
      if (!currentAllowed || currentAllowed.length === 0) {
        loadMoreBtn.style.display = 'none';
        return;
      }
      let start = displayOffset;
      let end = start + PAGE_SIZE;
      if (end > currentAllowed.length) {
        end = currentAllowed.length;
      }
      for (let i = start; i < end; i++) {
        let rowIndex = currentAllowed[i];
        if (rowIndex - 1 >= 0 && rowIndex - 1 < allRowElems.length) {
          allRowElems[rowIndex - 1].style.display = 'table-row';
        }
      }
      displayOffset = end;
      loadMoreBtn.style.display = (displayOffset >= currentAllowed.length) ? 'none' : 'inline-block';
    }
    
    // Convert CSV text into elements for Cytoscape
    function parseCSV(text) {
      if (!text) return [];
      let lines = text.trim().split('\n');
      if (lines.length < 2) return [];
      const header = lines[0].split(',').map(s => s.replace(/(^"|"$)/g, '').trim());
      const sourceClassIdx = header.indexOf("SourceClassification");
      const destinationClassIdx = header.indexOf("DestinationClassification");
      let seenNodes = new Set();
      let edgesMap = new Map();
      let nodeElements = [];
      for (let i = 1; i < lines.length; i++){
        let rowNumber = i;
        let cols = lines[i].split(',').map(c => c.replace(/(^"|"$)/g, ''));
        const sourceIdx = header.indexOf('Source');
        const destIdx = header.indexOf('Destination');
        const protocolIdx = header.indexOf('Protocol');
        const source = cols[sourceIdx]?.trim();
        const destination = cols[destIdx]?.trim();
        const protocol = cols[protocolIdx]?.trim();
        const nodeWeight = parseFloat(cols[8]) || 0;
        const edgeWeight = parseFloat(cols[9]) || 0;
        const sourceClassification = sourceClassIdx !== -1 ? cols[sourceClassIdx]?.trim() : 'External';
        const destinationClassification = destinationClassIdx !== -1 ? cols[destinationClassIdx]?.trim() : 'External';
        if (source && !seenNodes.has(source)) {
          nodeElements.push({
            data: {
              id: source,
              label: source,
              Classification: sourceClassification,
              NodeWeight: nodeWeight,
              timeIndex: rowNumber
            }
          });
          seenNodes.add(source);
        }
        if (destination && !seenNodes.has(destination)) {
          nodeElements.push({
            data: {
              id: destination,
              label: destination,
              Classification: destinationClassification,
              NodeWeight: nodeWeight,
              timeIndex: rowNumber
            }
          });
          seenNodes.add(destination);
        }
        if (!source || !destination || !protocol) continue;
        const edgeKey = source + '|' + destination + '|' + protocol;
        if (!edgesMap.has(edgeKey)) {
          edgesMap.set(edgeKey, {
            source, destination, protocol,
            csvIndices: [],
            totalEdgeWeight: 0
          });
        }
        let entry = edgesMap.get(edgeKey);
        entry.csvIndices.push(rowNumber);
        entry.totalEdgeWeight += edgeWeight;
      }
      let edgeElements = [];
      edgesMap.forEach(val => {
        edgeElements.push({
          data: {
            id: `edge-${val.source}-${val.destination}-${val.protocol}`,
            source: val.source,
            target: val.destination,
            Protocol: val.protocol,
            EdgeWeight: val.totalEdgeWeight,
            processCount: val.csvIndices.length,
            csvIndices: val.csvIndices,
            label: `(${val.csvIndices.length}) ${val.protocol}`
          }
        });
      });
      return [...nodeElements, ...edgeElements];
    }
    
    // Group nodes using a BFS approach for directed components
    function groupDirectedComponents(cy) {
      let visited = new Set();
      let groupCount = 0;
      function randomColor(){
        return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
      }
      cy.nodes().forEach(node => {
        if (!visited.has(node.id())) {
          groupCount++;
          const color = randomColor();
          let bfs = cy.elements().bfs({ roots: node, directed: true });
          bfs.path.forEach(ele => {
            if (ele.isNode()) {
              visited.add(ele.id());
              ele.data('groupID', groupCount);
              ele.data('color', color);
            }
          });
        }
      });
    }
    
    // Position node groups in a tree layout based on time
    function positionGroupedComponentsTree(cy) {
      let groupMap = {};
      cy.nodes().forEach(n => {
        let g = n.data('groupID') || 0;
        if (!groupMap[g]) groupMap[g] = [];
        groupMap[g].push(n);
      });
      let sortedGroups = Object.entries(groupMap).sort((a, b) => b[1].length - a[1].length);
      let groupYOffset = 0;
      const verticalSpacingBetweenGroups = 300;
      const levelHeight = 80;
      const siblingSpacing = 100;
      sortedGroups.forEach(([groupID, nodes]) => {
        let root = nodes.reduce((prev, curr) => {
          return (!prev || (curr.data('timeIndex') < prev.data('timeIndex'))) ? curr : prev;
        }, null);
        if (!root) return;
        let levels = {};
        let visited = new Set();
        let queue = [];
        levels[root.id()] = 0;
        visited.add(root.id());
        queue.push(root);
        while (queue.length > 0) {
          let current = queue.shift();
          let currentLevel = levels[current.id()];
          current.outgoers('edge').forEach(edge => {
            let target = edge.target();
            if (target.data('groupID') == groupID && !visited.has(target.id())) {
              levels[target.id()] = currentLevel + 1;
              visited.add(target.id());
              queue.push(target);
            }
          });
        }
        let levelNodes = {};
        nodes.forEach(n => {
          let lvl = levels[n.id()] !== undefined ? levels[n.id()] : 0;
          if (!levelNodes[lvl]) levelNodes[lvl] = [];
          levelNodes[lvl].push(n);
        });
        Object.keys(levelNodes).forEach(lvlKey => {
          let lvl = parseInt(lvlKey);
          let nodesAtLevel = levelNodes[lvl];
          nodesAtLevel.sort((a, b) => (a.data('timeIndex') || 0) - (b.data('timeIndex') || 0));
          let totalWidth = (nodesAtLevel.length - 1) * siblingSpacing;
          let startX = -totalWidth / 2;
          nodesAtLevel.forEach((n, idx) => {
            let x = startX + idx * siblingSpacing;
            let y = groupYOffset + lvl * levelHeight;
            n.position({x: x, y: y});
          });
        });
        let maxLevel = Math.max(...Object.keys(levelNodes).map(Number));
        groupYOffset += (maxLevel + 1) * levelHeight + verticalSpacingBetweenGroups;
      });
    }
    
    // Initialize the Cytoscape network visualization
    function visualizeNetwork(elements) {
      const cy = cytoscape({
        container: document.getElementById('cy'),
        elements,
        layout: { name: 'preset' },
        style: [
          {
            selector: 'node',
            style: {
              'color': '#000',
              'font-size': 12,
              'text-valign': 'center',
              'text-halign': 'center',
              'shape': 'ellipse',
              'font-family': 'Arial, sans-serif',
              'font-weight': 'bold',
              'text-opacity': 0,
              'width': 'mapData(NodeWeight, 0, 1, 20, 60)',
              'height': 'mapData(NodeWeight, 0, 1, 20, 60)',
              'background-color': 'mapData(NodeWeight, 0, 1, #d4f0d4, #006400)',
              'border-width': 2.0,
              'content': 'data(label)'
            }
          },
          {
            selector: 'node[Classification="Internal"]',
            style: { 'shape': 'rectangle' }
          },
          {
            selector: 'node[color]',
            style: { 'background-color': 'data(color)' }
          },
          {
            selector: 'edge',
            style: {
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'control-point-step-size': 30,
              'width': 'mapData(processCount, 1, 10, 2, 10)',
              'opacity': 0.8
            }
          },
          {
            selector: 'edge[Protocol="DNS"]',
            style: { 'line-color': '#6BAED6', 'target-arrow-color': '#6BAED6' }
          },
          {
            selector: 'edge[Protocol="FTP"]',
            style: { 'line-color': '#3182BD', 'target-arrow-color': '#3182BD' }
          },
          {
            selector: 'edge[Protocol="FTP-DATA"]',
            style: { 'line-color': '#08519C', 'target-arrow-color': '#08519C' }
          },
          {
            selector: 'edge[Protocol="HTTP"]',
            style: { 'line-color': '#FF7F0E', 'target-arrow-color': '#FF7F0E' }
          },
          {
            selector: 'edge[Protocol="SMB"]',
            style: { 'line-color': '#2CA02C', 'target-arrow-color': '#2CA02C' }
          },
          {
            selector: 'edge[Protocol="SMTP"]',
            style: { 'line-color': '#000000', 'target-arrow-color': '#000000' }
          },
          {
            selector: 'edge[Protocol="SMTP/IMF"]',
            style: { 'line-color': '#FF9896', 'target-arrow-color': '#FF9896' }
          },
          {
            selector: 'edge[Protocol="SSH"]',
            style: { 'line-color': '#9467BD', 'target-arrow-color': '#9467BD' }
          },
          {
            selector: 'edge[Protocol="STP"]',
            style: { 'line-color': '#8C564B', 'target-arrow-color': '#8C564B' }
          },
          {
            selector: 'edge[Protocol="TCP"]',
            style: { 'line-color': '#17BECF', 'target-arrow-color': '#17BECF' }
          },
          {
            selector: 'edge[Protocol="TLSv1"]',
            style: { 'line-color': '#BCBD22', 'target-arrow-color': '#BCBD22' }
          },
          {
            selector: 'edge.selected',
            style: {
              'line-color': 'red',
              'target-arrow-color': 'red',
              'width': 4
            }
          }
        ]
      });
      
      cy.zoom(0.5);
      globalCy = cy;
      groupDirectedComponents(cy);
      positionGroupedComponentsTree(cy);
      
      // Show tooltip with node or edge info on hover
      cy.on('mouseover', 'node,edge', (evt) => {
        let t = evt.target;
        let px = evt.originalEvent.pageX;
        let py = evt.originalEvent.pageY;
        tooltip.style.display = 'block';
        tooltip.style.left = (px + 10) + 'px';
        tooltip.style.top = (py + 10) + 'px';
        if (t.isNode()) {
          tooltip.innerHTML = `<strong>Node ID:</strong> ${t.id()}<br>
                               <strong>Classification:</strong> ${t.data('Classification')}<br>
                               <strong>Group:</strong> ${t.data('groupID') || 'N/A'}`;
        } else {
          let arr = t.data('csvIndices') || [];
          tooltip.innerHTML = `<strong>Edge:</strong><br>
                               From: ${t.data('source')}<br>
                               To: ${t.data('target')}<br>
                               Protocol: ${t.data('Protocol')}<br>
                               Rows: ${arr.length}`;
        }
      });
      
      // Hide tooltip when not hovering
      cy.on('mouseout', 'node,edge', () => {
        tooltip.style.display = 'none';
      });
      
      // Handle edge clicks for selection, with shift-click for group selection
      cy.on('click', 'edge', (evt) => {
        let edge = evt.target;
        if (evt.originalEvent.shiftKey) {
          let groupID = edge.source().data('groupID');
          if (groupID !== undefined) {
            cy.edges().forEach(e => {
              if (
                e.source().data('groupID') === groupID &&
                e.target().data('groupID') === groupID
              ) {
                let indices = e.data('csvIndices') || [];
                indices.forEach(idx => selectedEdges.add(idx));
                e.addClass('selected');
              }
            });
          }
        } else {
          let indices = edge.data('csvIndices') || [];
          if (!indices.length) return;
          let allSelected = indices.every(idx => selectedEdges.has(idx));
          if (allSelected) {
            indices.forEach(idx => selectedEdges.delete(idx));
            edge.removeClass('selected');
          } else {
            indices.forEach(idx => selectedEdges.add(idx));
            edge.addClass('selected');
          }
        }
        updateKeywordSuggestions();
        displayOffset = 0;
        updateRowVisibility();
      });
    }
  </script>
</body>
</html>
