<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MalScape</title>
  <!-- Including D3.js for data-driven visualizations and Cytoscape for network graphs -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
  <style>
    /* General Styles: importing font and setting basic box-model properties */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      color: #333;
      background-color: #f8f9fa;
    }
    /* Use a flex layout for the overall page */
    body { display: flex; }
    
    /* Main container styles where our visualization and controls live */
    #main-container {
      flex: 1;
      padding: 24px;
      height: 100vh;
      overflow-y: auto;
    }
    /* Set consistent width for node and edge size input fields */
    #nodeSizeMin, #nodeSizeMax, #edgeWidthMin, #edgeWidthMax {
      width: 200px;
    }

    /* Legend container styles on the side */
    #legend-container {
      width: 220px;
      background-color: #fff;
      border-left: 1px solid #e9ecef;
      padding: 16px 12px;
      height: 100vh;
      overflow-y: auto;
      box-shadow: -4px 0 8px rgba(0,0,0,0.05);
    }
    
    /* Header styles (h2 and h3) for section titles */
    h2 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 28px;
      font-weight: 600;
      border-bottom: 2px solid #4299e1;
      padding-bottom: 8px;
      display: inline-block;
    }
    h3 {
      color: #2c3e50;
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      font-weight: 600;
    }
    
    /* Control group styling for various filters and controls */
    .control-group {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Input and label styling */
    label {
      display: inline-block;
      margin-right: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      margin-right: 12px;
      margin-bottom: 8px;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus {
      border-color: #4299e1;
      outline: none;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    
    /* Button styling */
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-right: 8px;
    }
    button:hover { background-color: #3182ce; }
    
    /* Specific buttons hidden by default or with special colors */
    #loadMoreBtn {
      display: none;
      margin-top: 16px;
      background-color: #38a169;
    }
    #loadMoreBtn:hover { background-color: #2f855a; }
    
    /* Cytoscape network container style */
    #cy {
      width: 100%;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 24px;
      background-color: #fff;
      display: none;
    }

    /* Table container for CSV data, initially hidden */
    #table-container {
      margin-bottom: 24px;
      border-radius: 8px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }
    #table-container table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
    }
    #table-container th, #table-container td {
      padding: 12px 15px;
      border-bottom: 1px solid #e9ecef;
      text-align: left;
      white-space: nowrap;
    }
    
    /* Pagination controls styling */
    #table-pagination {
      display: none;
      margin-top: 8px;
      text-align: center;
    }
    #table-pagination input {
      width: 60px;
      text-align: center;
    }
    
    /* Tooltip styling for hover details */
    #tooltip {
      position: absolute;
      display: none;
      background: #fff;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 13px;
      color: #2d3748;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      max-width: 300px;
      line-height: 1.5;
    }
    
    /* Styles for colored boxes used in the legend */
    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      vertical-align: middle;
      margin-right: 4px;
      border: 1px solid #ccc;
    }
    #legend {
      font-size: 12px;
      line-height: 1.4;
    }
    #legend th, #legend td {
      padding: 4px 6px;
    }
    #backToHeatmap {
      margin: 20px;
      padding: 8px 16px;
      font-size: 14px;
      display: none;
    }
    
    /* Edge Filter Panel styling */
    #edgeFilterPanel {
      position: absolute;
      top: 80px;
      right: 40px;
      width: 320px;
      padding: 12px;
      background-color: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      display: none;
      z-index: 9999;
    }
    #edgeFilterPanel h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
    }
    #edgeFilterPanel label {
      display: block;
      margin-top: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    #edgeFilterPanel input {
      margin-bottom: 8px;
      width: 100%;
    }
    
    /* Loading overlay styles */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.8);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #4299e1;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    .loading-text {
      font-size: 18px;
      color: #333;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
  </div>
  
  <!-- Main container -->
  <div id="main-container" style="margin-top: 60px;">
    <h2>MalScape</h2>
    <!-- Top controls -->
    <div id="topControls">
      <div style="top: 16px; left: 16px; z-index: 1000; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <label for="fileInput"><strong>Upload CSV File:</strong></label>
        <input type="file" id="fileInput" accept=".csv">
        <button id="downloadButton">Download Processed CSV File</button>
      </div>
      <div class="control-group">
        <label for="rowOrderSelect">Order Cells in Each Row By:</label>
        <select id="rowOrderSelect">
          <option value="descending">Descending (by value)</option>
          <option value="ascending">Ascending (by value)</option>
        </select>
        <label for="minSourceAmtFilter">Min Unique Sources:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="e.g., 1" step="1">
        <label for="maxSourceAmtFilter">Max Unique Sources:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="e.g., 100" step="1">
        <label for="minDestinationAmtFilter">Min Unique Destinations:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="e.g., 1" step="1">
        <label for="maxDestinationAmtFilter">Max Unique Destinations:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="e.g., 100" step="1">
        <label for="payloadSearch">Search Payload Content:</label>
        <input type="text" id="payloadSearch" placeholder="Enter keyword">
        <label for="sourceFilter">Source IP:</label>
        <input type="text" id="sourceFilter" placeholder="e.g., 192.168.1.1">
        <label for="destinationFilter">Destination IP:</label>
        <input type="text" id="destinationFilter" placeholder="e.g., 172.16.0.1">
        <label for="protocolFilter">Network Protocol:</label>
        <input type="text" id="protocolFilter" placeholder="e.g., TCP">
        <label for="entropyMinFilter">Min Cluster Variation:</label>
        <input type="number" id="entropyMinFilter"  placeholder="e.g., 1.0" step="0.1">
        <label for="entropyMaxFilter">Max Cluster Variation:</label>
        <input type="number" id="entropyMaxFilter" placeholder="e.g., 3.0" step="0.1">
        <label for="isLargePacketFilter">Show only large packets:</label>
        <input type="checkbox" id="isLargePacketFilter">
        <label for="isSuspiciousAckFilter">Show only suspicious ACKs:</label>
        <input type="checkbox" id="isSuspiciousAckFilter">
      </div>
    </div>

    <div id="sizeControls" style="display: none; margin-top: 16px;">
      <label for="edgeWidthMin">Min Edge Width:</label>
      <input type="number" id="edgeWidthMin" placeholder="e.g., 2" step="1" min="1">
      <label for="edgeWidthMax">Max Edge Width:</label>
      <input type="number" id="edgeWidthMax" placeholder="e.g., 12" step="1" min="1">
      <label for="nodeSizeMin">Min Node Size:</label>
      <input type="number" id="nodeSizeMin" placeholder="e.g., 15" step="1" min="1">
      <label for="nodeSizeMax">Max Node Size:</label>
      <input type="number" id="nodeSizeMax" placeholder="e.g., 50" step="1" min="1">
    </div>

    <!-- Heatmap container -->
    <div id="heatmap"></div>
    <button id="loadMoreBtn">Load More</button>
    <button id="backToHeatmap">Back to Heatmap</button>
    <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;">Refresh Network</button>
    <div id="cy"></div>

    <!-- Table search and container -->
    <div id="table-search-container" style="display:none; margin-bottom: 12px;">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>
    <div id="table-container"></div>
    <div id="table-pagination">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
  </div>
  
  <!-- Legend container -->
  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <tr>
        <th>Protocol</th>
        <th>Color</th>
        <th>Process %</th>
      </tr>
    </table>
  </div>
  
  <!-- Edge Filter Panel -->
  <div id="edgeFilterPanel">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label>
    <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label>
    <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label>
    <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label>
    <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label>
    <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn">Filter Edges</button>
    <button id="clearEdgeFilterBtn">Clear Filter</button>
  </div>
  
  <script>
    // Global Variables
    let protocolColorMap = {};
    let globalCy;
    let selectedEdges = new Set();
    let currentClusterID = null;
    const TABLE_PAGE_SIZE = 50;
    
    window.selectedClusters = new Set();
    window.usedHighlightHues = [];
    
    // Generates a non‑blue and non‑red unique color
    function generateNonRedBlueUniqueColor() {
      let attempts = 0;
      while (attempts < 100) {
        let hue = Math.floor(Math.random() * 360);
        if ((hue >= 0 && hue <= 20) || (hue >= 200 && hue <= 260) || (hue >= 340 && hue <= 360)) {
          attempts++;
          continue;
        }
        const threshold = 50;
        let isDistinct = window.usedHighlightHues.every(usedHue => {
          let diff = Math.abs(hue - usedHue);
          return diff >= threshold && (360 - diff) >= threshold;
        });
        if (isDistinct) {
          window.usedHighlightHues.push(hue);
          let color = `hsl(${hue}, 70%, 50%)`;
          return { color, hue };
        }
        attempts++;
      }
      let fallbackHue = Math.floor(Math.random() * 360);
      let fallbackColor = `hsl(${fallbackHue}, 70%, 50%)`;
      window.usedHighlightHues.push(fallbackHue);
      return { color: fallbackColor, hue: fallbackHue };
    }
    
    function updateExploreButton() {
      let exploreBtn = document.getElementById('exploreClustersBtn');
      if (window.selectedClusters.size > 0) {
        if (!exploreBtn) {
          exploreBtn = document.createElement('button');
          exploreBtn.id = 'exploreClustersBtn';
          exploreBtn.textContent = 'Explore Selected Clusters Further';
          exploreBtn.style.marginTop = "16px";
          document.getElementById('main-container').appendChild(exploreBtn);
          exploreBtn.addEventListener('click', exploreSelectedClusters);
        }
      } else {
        if (exploreBtn) {
          exploreBtn.remove();
        }
      }
    }
    
    function showLoading() {
      document.getElementById('loading-overlay').style.display = 'flex';
    }
    function hideLoading() {
      document.getElementById('loading-overlay').style.display = 'none';
    }
    
    // Update the legend from the backend
    function updateLegend() {
      const legendTable = document.getElementById('legend');
      legendTable.innerHTML = '<tr><th>Protocol</th><th>Color</th><th>Process %</th></tr>';
      fetch("http://127.0.0.1:5000/protocol_percentages")
        .then(response => response.json())
        .then(percentages => {
          if (window.globalData) {
            let protocolsSet = new Set();
            window.globalData.forEach(d => {
              if(d.Protocol) protocolsSet.add(d.Protocol.trim());
            });
            let protocols = Array.from(protocolsSet).sort((a, b) => (percentages[b] || 0) - (percentages[a] || 0));
            protocols.forEach(protocol => {
              if (!protocolColorMap[protocol]) {
                protocolColorMap[protocol] = '#' + Math.floor(Math.random() * 16777215)
                  .toString(16).padStart(6, '0');
              }
              let percentage = (percentages[protocol] !== undefined)
                                ? percentages[protocol].toFixed(5) + '%'
                                : '0%';
              const row = document.createElement('tr');
              row.innerHTML = `<td>${protocol}</td>
                               <td><span class="color-box" style="background-color:${protocolColorMap[protocol]}"></span></td>
                               <td>${percentage}</td>`;
              legendTable.appendChild(row);
            });
          }
        })
        .catch(error => {
          console.error("Error fetching protocol percentages:", error);
        });
    }
    
    function exploreSelectedClusters() {
      const clustersToExplore = Array.from(window.selectedClusters);
      if (clustersToExplore.length === 0) return;
      Promise.all(
        clustersToExplore.map(clusterID =>
          fetch("http://127.0.0.1:5000/cluster_network?cluster_id=" + clusterID)
            .then(response => response.json())
        )
      )
      .then(results => {
        let combinedNodes = {};
        let combinedEdges = {};
        results.forEach(data => {
          data.nodes.forEach(n => {
            combinedNodes[n.data.id] = n;
          });
          data.edges.forEach(e => {
            combinedEdges[e.data.id] = e;
          });
        });
        const combinedData = {
          nodes: Object.values(combinedNodes),
          edges: Object.values(combinedEdges)
        };
        updateLegend(combinedData);
        visualizeNetwork(combinedData);
        d3.select("#heatmap").style("display", "none");
        document.getElementById("backToHeatmap").style.display = "inline-block";
        document.getElementById("refreshNetworkBtn").style.display = "inline-block";
        document.getElementById("topControls").style.display = "none";
        document.getElementById('table-search-container').style.display = "block";
        document.getElementById('table-container').style.display = "block";
        document.getElementById('sizeControls').style.display = "block";
        currentClusterID = clustersToExplore[0];
        createClusterTable(currentClusterID);
      })
      .catch(error => {
        console.error("Error exploring selected clusters:", error);
      });
    }
    
    // Fetch aggregated heatmap data
    function updateHeatmap() {
      showLoading();
      const metrics = [
        { label: "Count", value: "count" },
        { label: "Unique IPs", value: "Unique IPs" },
        { label: "Unique Sources", value: "Unique Sources" },
        { label: "Unique Destinations", value: "Unique Destinations" },
        { label: "Packet Length", value: "Length" },
        { label: "Payload Length", value: "Len" },
        { label: "Payload Size Variance", value: "Payload Size Variance" },
        { label: "Packets per Second", value: "Packets per Second" },
        { label: "Total Data Sent", value: "Total Data Sent" },
        { label: "% SYN packets", value: "% SYN packets" },
        { label: "% RST packets", value: "% RST packets" },
        { label: "% ACK packets", value: "% ACK packets" },
        { label: "% PSH packets", value: "% PSH packets" }
      ];  

      const filterParamsBase = {
        payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
        sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
        destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
        protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
        entropyMin: document.getElementById('entropyMinFilter').value,
        entropyMax: document.getElementById('entropyMaxFilter').value,
        isLargePacketOnly: document.getElementById('isLargePacketFilter').checked,
        isSuspiciousAckOnly: document.getElementById('isSuspiciousAckFilter').checked,
        minSourceAmt: document.getElementById('minSourceAmtFilter').value,
        maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
        minDestinationAmt: document.getElementById('minDestinationAmtFilter').value,
        maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
      };

      Promise.all(metrics.map(m => {
          const filterParams = Object.assign({}, filterParamsBase, { metric: m.value });
          return fetch("http://127.0.0.1:5000/filter_and_aggregate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(filterParams)
          })
          .then(response => response.json())
          .then(data => ({ metric: m.label, pivotData: data }));
        }))
        .then(results => {
          renderCombinedHeatmap(results);
          hideLoading();
        })
        .catch(error => {
          console.error("Error fetching aggregated data:", error);
          hideLoading();
        });
    }
    
    // Render heatmap based on aggregated data.
    // Now, each pivot object is assumed to include a "clusterAnomaly" flag (set by the backend)
    function renderCombinedHeatmap(dataByMetric) {
      const orderOption = document.getElementById("rowOrderSelect").value || "descending";
      const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;
      const heatmapData = dataByMetric.map(({ metric, pivotData }) => ({
        metric,
        values: [...pivotData].sort(comparator).slice(0, 700)
      }));
      const maxCols = d3.max(heatmapData, r => r.values.length);
      const cellWidth = 2;
      const cellHeight = 15;
      const labelMargin = 150;
      const verticalSpacing = 10;
      const numRows = heatmapData.length;
      const totalHeight = 20 + numRows * cellHeight + (numRows - 1) * verticalSpacing + 20;
      const width = labelMargin + maxCols * cellWidth + 40;
      d3.select("#heatmap").select("svg").remove();
      const svg = d3.select("#heatmap").append("svg")
                    .attr("width", width)
                    .attr("height", totalHeight);
      
      // The anomaly flag is now assumed to be provided by the backend
      heatmapData.forEach((rowData, rowIndex) => {
        const rowY = 20 + rowIndex * (cellHeight + verticalSpacing);
        svg.append("text")
           .attr("x", labelMargin - 10)
           .attr("y", rowY + cellHeight / 2)
           .attr("text-anchor", "end")
           .attr("alignment-baseline", "middle")
           .attr("font-size", "12px")
           .attr("fill", "black")
           .text(rowData.metric);
  
        let rowMax = d3.max(rowData.values, d => d.value) || 1;
        const localColorScale = d3.scaleSequential(d3.interpolateBlues).domain([0, rowMax]);
  
        rowData.values.forEach((cellData, colIndex) => {
          let cellX = labelMargin + colIndex * cellWidth;
          let cellFillColor = localColorScale(cellData.value);
          // Instead of computing anomaly state here from globalData,
          // we directly use the provided cluster anomaly flag.
          if (window.globalData) {
          let records = window.globalData.filter(row => row.ClusterID == cellData.cluster);
          if (records.some(r => r.Anomaly === 'anomaly')) {
            cellData.clusterAnomaly = 'anomaly';
          } else {
            cellData.clusterAnomaly = 'normal';
          }
        }
          if (cellData.clusterAnomaly === "anomaly") {
            cellFillColor = "red";
          }
          svg.append("rect")
             .attr("class", "cell")
             .attr("data-cluster", cellData.cluster)
             .attr("data-original-fill", cellFillColor)
             .attr("x", cellX)
             .attr("y", rowY)
             .attr("width", cellWidth)
             .attr("height", cellHeight)
             .attr("fill", cellFillColor)
             .on("mouseover", function(event) {
               tooltip.style.display = "block";
               tooltip.innerHTML = `<strong>${rowData.metric}</strong><br>Cluster: ${cellData.cluster}<br>Value: ${cellData.value}`;
               tooltip.style.left = (event.pageX + 10) + "px";
               tooltip.style.top = (event.pageY + 10) + "px";
             })
             .on("mouseout", function() {
               tooltip.style.display = "none";
             })
             .on("click", function(event) {
               event.stopPropagation();
               const cell = d3.select(this);
               const clusterID = cell.attr("data-cluster");
               const clusterCells = d3.selectAll("rect.cell")
                                       .filter(function() {
                                         return d3.select(this).attr("data-cluster") === clusterID;
                                       });
               const isSelected = clusterCells.classed("selected");
               if (!isSelected) {
                 const { color: randColor, hue: selectedHue } = generateNonRedBlueUniqueColor();
                 clusterCells.classed("selected", true)
                             .attr("data-selected-color", randColor)
                             .attr("data-selected-hue", selectedHue)
                             .transition()
                             .duration(200)
                             .style("fill", randColor);
                 window.selectedClusters.add(clusterID);
               } else {
                 clusterCells.classed("selected", false)
                             .transition()
                             .duration(200)
                             .style("fill", function() {
                               const cid = d3.select(this).attr("data-cluster");
                               const originalFill = cellData.clusterAnomaly === "anomaly" ? "red" : d3.select(this).attr("data-original-fill");
                               return originalFill;
                             });
                 window.selectedClusters.delete(clusterID);
                 const firstCell = clusterCells.nodes()[0];
                 if (firstCell) {
                   const usedHue = d3.select(firstCell).attr("data-selected-hue");
                   window.usedHighlightHues = window.usedHighlightHues.filter(h => h != usedHue);
                 }
               }
               updateExploreButton();
             });
        });
        d3.select("#loadMoreBtn").style("display", "none");
      });
    }
    
    function showHeatmap() {
      document.getElementById('cy').style.display = 'none';
      document.getElementById('backToHeatmap').style.display = 'none';
      document.getElementById('edgeFilterPanel').style.display = 'none';
      document.getElementById('table-container').style.display = 'none';
      document.getElementById('table-pagination').style.display = 'none';
      document.getElementById('refreshNetworkBtn').style.display = 'none';
      document.getElementById('sizeControls').style.display = 'none';
      document.getElementById('table-search-container').style.display = "none";
      document.getElementById('topControls').style.display = 'block';
      d3.select("#heatmap").style("display", "block");
      updateLegend();
      clearEdgeFilter();
    }
    document.getElementById('backToHeatmap').addEventListener('click', showHeatmap);
    
    function showClusterNetwork(clusterID) {
      currentClusterID = clusterID;
      fetch("http://127.0.0.1:5000/cluster_network?cluster_id=" + clusterID)
        .then(response => response.json())
        .then(data => {
          if (data.nodes.length === 0 && data.edges.length === 0) {
            alert("No network data for this cluster.");
            return;
          }
          updateLegend(data);
          const elementsCombined = data.nodes.concat(data.edges);
          visualizeNetwork(elementsCombined);
          d3.select("#heatmap").style("display", "none");
          document.getElementById("backToHeatmap").style.display = "inline-block";
          document.getElementById("refreshNetworkBtn").style.display = "inline-block";
          document.getElementById('table-search-container').hidden = false;
          document.getElementById('sizeControls').hidden = false;
          document.getElementById("topControls").style.display = "none";
          createClusterTable(clusterID);
          document.getElementById('cy').scrollIntoView({ behavior: 'smooth', block: 'center' });
        })
        .catch(error => console.error("Error fetching network data:", error));
    }
    
    function loadClusterTablePage(clusterID, page) {
      fetch(`http://127.0.0.1:5000/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
      .then(response => response.text())
      .then(html => {
         const container = document.getElementById('table-container');
         container.innerHTML = html;
         document.getElementById('table-pagination').style.display = 'block';
         const summaryElem = document.getElementById('table-summary');
         if(summaryElem) {
             const total = parseInt(summaryElem.dataset.total);
             const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
             document.getElementById('totalPages').textContent = totalPages;
             document.getElementById('currentPageInput').value = page;
         }
      })
      .catch(error => console.error("Error fetching cluster table:", error));
    }
    
    function createClusterTable(clusterID) {
      loadClusterTablePage(clusterID, 1);
      document.getElementById('table-container').style.display = "block";
      document.getElementById('table-search-container').style.display = "block";
    }
    
    document.getElementById('goPageBtn').addEventListener('click', function () {
      let page = parseInt(document.getElementById('currentPageInput').value);
      if (page >= 1) {
        if (window.edgeFilterState) {
          const { source, destination, protocol } = window.edgeFilterState;
          fetch(`http://127.0.0.1:5000/get_edge_table?source=${source}&destination=${destination}&protocol=${protocol}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
            .then(res => res.text())
            .then(html => {
              const container = document.getElementById('table-container');
              container.innerHTML = html;
              const summaryElem = document.getElementById('table-summary');
              if (summaryElem) {
                const total = parseInt(summaryElem.dataset.total);
                const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                document.getElementById('totalPages').textContent = totalPages;
                document.getElementById('currentPageInput').value = page;
              }
            });
        } else if (currentClusterID) {
          loadClusterTablePage(currentClusterID, page);
        }
      }
    });
    
    function groupDirectedComponents(cy) {
      let visited = new Set();
      let groupCount = 0;
      function randomColor(){
        return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      }
      cy.nodes().forEach(node => {
        if (!visited.has(node.id())) {
          groupCount++;
          const color = randomColor();
          let bfs = cy.elements().bfs({ roots: node, directed: true });
          bfs.path.forEach(ele => {
            if (ele.isNode()) {
              visited.add(ele.id());
              ele.data('groupID', groupCount);
              ele.data('color', color);
            }
          });
        }
      });
    }
    
    function positionGroupedComponentsTree(cy) {
      let groupMap = {};
      cy.nodes().forEach(n => {
        let g = n.data('groupID') || 0;
        if (!groupMap[g]) groupMap[g] = [];
        groupMap[g].push(n);
      });
      let sortedGroups = Object.entries(groupMap).sort((a, b) => b[1].length - a[1].length);
      let groupYOffset = 0;
      const verticalSpacingBetweenGroups = 200;
      const levelHeight = 130;
      const siblingSpacing = 200;
      sortedGroups.forEach(([groupID, nodes]) => {
        let root = nodes.reduce((prev, curr) => {
          return (!prev || (curr.data('timeIndex') < prev.data('timeIndex'))) ? curr : prev;
        }, null);
        if (!root) return;
        let levels = {};
        let visited = new Set();
        let queue = [];
        levels[root.id()] = 0;
        visited.add(root.id());
        queue.push(root);
        while (queue.length > 0) {
          let current = queue.shift();
          let currentLevel = levels[current.id()];
          current.outgoers('edge').forEach(edge => {
            let target = edge.target();
            if (target.data('groupID') == groupID && !visited.has(target.id())) {
              levels[target.id()] = currentLevel + 1;
              visited.add(target.id());
              queue.push(target);
            }
          });
        }
        let levelNodes = {};
        nodes.forEach(n => {
          let lvl = levels[n.id()] !== undefined ? levels[n.id()] : 0;
          if (!levelNodes[lvl]) levelNodes[lvl] = [];
          levelNodes[lvl].push(n);
        });
        Object.keys(levelNodes).forEach(lvlKey => {
          let lvl = parseInt(lvlKey);
          let nodesAtLevel = levelNodes[lvl];
          nodesAtLevel.sort((a, b) => (a.data('timeIndex') || 0) - (b.data('timeIndex') || 0));
          let totalWidth = (nodesAtLevel.length - 1) * siblingSpacing;
          let startX = -totalWidth / 2;
          nodesAtLevel.forEach((n, idx) => {
            let x = startX + idx * siblingSpacing;
            let y = groupYOffset + lvl * levelHeight;
            n.position({x: x, y: y});
          });
        });
        let maxLevel = Math.max(...Object.keys(levelNodes).map(Number));
        groupYOffset += (maxLevel + 1) * levelHeight + verticalSpacingBetweenGroups;
      });
    }
    
    function getNodeSize(ele) {
      let minSize = parseFloat(document.getElementById('nodeSizeMin').value);
      let maxSize = parseFloat(document.getElementById('nodeSizeMax').value);
      if (isNaN(minSize) && isNaN(maxSize)) {
        minSize = 30;
        maxSize = 65;
      } else {
        if (isNaN(minSize)) minSize = maxSize;
        if (isNaN(maxSize)) maxSize = minSize;
      }
      if (maxSize < minSize) {
        const temp = maxSize;
        maxSize = minSize;
        minSize = temp;
      }
      let maxWeight = 0;
      let minWeight = Infinity;
      ele.cy().nodes().forEach(n => {
        const w = parseFloat(n.data('NodeWeight')) || 0;
        if (w > maxWeight) maxWeight = w;
        if (w < minWeight) minWeight = w;
      });
      if (!isFinite(minWeight)) minWeight = 0;
      const currentWeight = parseFloat(ele.data('NodeWeight')) || 0;
      if (maxWeight === minWeight) return minSize;
      const scaled = minSize + ((currentWeight - minWeight) / (maxWeight - minWeight)) * (maxSize - minSize);
      return Math.min(Math.max(scaled, minSize), maxSize);
    }
    
    function visualizeNetwork(elements) {
      document.getElementById('cy').style.display = 'block';
      const cy = cytoscape({
        container: document.getElementById('cy'),
        elements: elements,
        pixelRatio: 1,
        layout: { name: 'preset' },
        style: [
          {
            selector: 'node',
            style: {
              'width': function(ele) { return getNodeSize(ele); },
              'height': function(ele) { return getNodeSize(ele); },
              'background-color': 'mapData(NodeWeight, 0, 1, #d4f0d4, #006400)',
              'border-width': 2,
              'border-color': '#333',
              'content': 'data(label)',
              'font-size': 14,
              'color': '#000',
              'text-valign': 'center',
              'text-halign': 'center',
              'text-opacity': 1,
              'text-outline-width': 2,
              'text-outline-color': '#fff',
              'shape': 'ellipse'
            }
          },
          {
            selector: 'node[Classification="Internal"]',
            style: { 'shape': 'rectangle' }
          },
          {
            selector: 'node[color]',
            style: { 'background-color': 'data(color)' }
          },
          {
            selector: 'edge',
            style: {
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'control-point-step-size': 30,
              'width': 'data(normalizedWidth)',
              'line-color': function(ele) { return ele.data('edgeColor') || '#888'; },
              'target-arrow-color': function(ele) { return ele.data('edgeColor') || '#888'; },
              'opacity': 0.8
            }
          },
          {
            selector: 'edge.selected',
            style: {
              'line-color': 'red',
              'target-arrow-color': 'red',
              'opacity': 1,
              'z-index': 9999
            }
          }
        ]
      });
      
      globalCy = cy;
      
      cy.edges().forEach(edge => {
        let protocol = edge.data('Protocol');
        let color = protocolColorMap[protocol] || '#888';
        if (/^#?f{2}0000$/i.test(color) || color.toLowerCase() === 'red') {
          color = '#880000';
        }
        edge.data('edgeColor', color);
      });
      
      cy.edges().forEach(edge => {
        let count = parseFloat(edge.data('processCount')) || 0;
        const maxNormalizedWeight = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 12, 2);
        const minNormalizedWeight = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 2, 1);
        const computedWeight = 2 + (count * 1);
        const clamped = Math.min(Math.max(computedWeight, minNormalizedWeight), maxNormalizedWeight);
        edge.data('normalizedWeight', clamped);
        edge.data('normalizedWidth', clamped);
      });
      
      groupDirectedComponents(cy);
      positionGroupedComponentsTree(cy);
      cy.fit(cy.elements(), 30);
      
      cy.on('mouseover', 'node,edge', (evt) => {
        let t = evt.target;
        let px = evt.originalEvent.pageX;
        let py = evt.originalEvent.pageY;
        tooltip.style.display = 'block';
        tooltip.style.left = (px + 10) + 'px';
        tooltip.style.top = (py + 10) + 'px';
        if (t.isNode()) {
          tooltip.innerHTML = `<strong>Node IP:</strong> ${t.id()}<br>
                               <strong>Classification:</strong> ${t.data('Classification')}<br>
                               <strong>Group:</strong> ${t.data('groupID') || 'N/A'}<br>`;
        } else {
          let processes = (t.data('processCount') !== undefined) ? t.data('processCount') : 0;
          tooltip.innerHTML = `<strong>Edge:</strong><br>
                               From: ${t.data('source')}<br>
                               To: ${t.data('target')}<br>
                               Protocol: ${t.data('Protocol')}<br>
                               Processes: ${processes}<br>
                               Weight: ${t.data('EdgeWeight')}`;
        }
      });
      
      cy.on('mouseout', 'node,edge', () => {
        tooltip.style.display = 'none';
      });
      
      cy.on('click', 'edge', (evt) => {
        const edge = evt.target;
        const edgeId = edge.id();
        if (selectedEdges.has(edgeId)) {
          selectedEdges.delete(edgeId);
          edge.removeClass('selected');
          edge.data('normalizedWidth', edge.data('originalWidth'));
        } else {
          selectedEdges.add(edgeId);
          edge.data('originalWidth', edge.data('normalizedWidth'));
          edge.data('normalizedWidth', edge.data('normalizedWidth'));
          edge.addClass('selected');
        }
        const selectedEdgeData = Array.from(selectedEdges).map(id => {
          const e = cy.getElementById(id);
          return {
            source: e.data('source'),
            destination: e.data('target'),
            protocol: e.data('Protocol')
          };
        });
        if (selectedEdgeData.length === 0) {
          if (currentClusterID) {
            loadClusterTablePage(currentClusterID, 1);
            document.getElementById('table-container').style.display = 'block';
            document.getElementById('table-pagination').style.display = 'block';
            window.edgeFilterState = null;
          }
          return;
        }
        fetch("http://127.0.0.1:5000/get_multi_edge_table", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            edges: selectedEdgeData,
            page: 1,
            page_size: 50
          })
        })
        .then(res => res.text())
        .then(html => {
          const container = document.getElementById('table-container');
          container.innerHTML = html;
          container.style.display = 'block';
          document.getElementById('table-pagination').style.display = 'block';
          const summaryElem = document.getElementById('table-summary');
          if (summaryElem) {
            const total = parseInt(summaryElem.dataset.total);
            const totalPages = Math.ceil(total / 50);
            document.getElementById('totalPages').textContent = totalPages;
            document.getElementById('currentPageInput').value = 1;
          }
          window.edgeFilterState = selectedEdgeData;
        });
      });
    }
    
    function showEdgeFilterPanel(edgeData) {
      document.getElementById('edgeFilterSource').value = edgeData.source || "";
      document.getElementById('edgeFilterDestination').value = edgeData.target || "";
      document.getElementById('edgeFilterProtocol').value = edgeData.Protocol || "";
      document.getElementById('edgeFilterWeight').value = "";
      document.getElementById('edgeFilterProcessCount').value = "";
      const panel = document.getElementById('edgeFilterPanel');
      panel.style.display = 'block';
    }
    
    function clearEdgeFilter() {
      if (!globalCy) return;
      globalCy.edges().forEach(e => e.show());
      document.getElementById('edgeFilterSource').value = "";
      document.getElementById('edgeFilterDestination').value = "";
      document.getElementById('edgeFilterProtocol').value = "";
      document.getElementById('edgeFilterWeight').value = "";
      document.getElementById('edgeFilterProcessCount').value = "";
      document.getElementById('edgeFilterPanel').style.display = 'none';
    }
    
    function applyEdgeFilter() {
      if (!globalCy) return;
      let fSource = document.getElementById('edgeFilterSource').value.trim().toLowerCase();
      let fDest = document.getElementById('edgeFilterDestination').value.trim().toLowerCase();
      let fProto = document.getElementById('edgeFilterProtocol').value.trim().toLowerCase();
      let fWeight = document.getElementById('edgeFilterWeight').value.trim();
      let fProcessCount = document.getElementById('edgeFilterProcessCount').value.trim();
      
      globalCy.edges().forEach(e => {
        let d = e.data();
        let keep = true;
        if (fSource && !d.source.toLowerCase().includes(fSource)) keep = false;
        if (fDest && !d.target.toLowerCase().includes(fDest)) keep = false;
        if (fProto && !d.Protocol.toLowerCase().includes(fProto)) keep = false;
        if (fWeight) {
          let parsed = parseNumericExpression(fWeight);
          if (parsed) {
            const edgeVal = d.EdgeWeight || 0;
            switch (parsed.operator) {
              case '>':  if (!(edgeVal > parsed.number))  keep = false; break;
              case '>=': if (!(edgeVal >= parsed.number)) keep = false; break;
              case '<':  if (!(edgeVal < parsed.number))  keep = false; break;
              case '<=': if (!(edgeVal <= parsed.number)) keep = false; break;
              case '==': if (edgeVal !== parsed.number)   keep = false; break;
              default: break;
            }
          }
        }
        if (fProcessCount) {
          let parsedCount = parseNumericExpression(fProcessCount);
          if (parsedCount) {
            const countVal = d.processCount || 0;
            switch (parsedCount.operator) {
              case '>':  if (!(countVal > parsedCount.number))  keep = false; break;
              case '>=': if (!(countVal >= parsedCount.number)) keep = false; break;
              case '<':  if (!(countVal < parsedCount.number))  keep = false; break;
              case '<=': if (!(countVal <= parsedCount.number)) keep = false; break;
              case '==': if (countVal !== parsedCount.number)     keep = false; break;
              default: break;
            }
          }
        }
        if (keep) e.show(); else e.hide();
      });
    }
    
    document.getElementById('applyEdgeFilterBtn').addEventListener('click', applyEdgeFilter);
    document.getElementById('clearEdgeFilterBtn').addEventListener('click', clearEdgeFilter);
    
    function parseNumericExpression(value) {
      const match = value.match(/^(\>=|\<=|>|<)\s*(\d+(?:\.\d+)?)$/);
      if (match) {
        return { operator: match[1], number: parseFloat(match[2]) };
      }
      const justNum = parseFloat(value);
      if (!isNaN(justNum) && value.trim() !== "") {
        return { operator: '==', number: justNum };
      }
      return null;
    }
    
    document.getElementById("fileInput").addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        showLoading();
        const csvText = e.target.result;
        fetch("http://127.0.0.1:5000/process_csv", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ csv_text: csvText })
        })
        .then(response => response.text())
        .then(processedText => {
          try {
            window.globalData = d3.csvParse(processedText, d3.autoType);
            updateLegend();
            updateHeatmap();
          } catch (error) {
            console.error("Error parsing processed CSV:", error);
          } finally {
            hideLoading();
          }
        })
        .catch(error => {
          console.error("Error processing CSV on server:", error);
          hideLoading();
        });
      };
      reader.readAsText(file);
    });
    
    document.getElementById("downloadButton").addEventListener("click", function() {
      window.location.href = "http://127.0.0.1:5000/download_csv";
    });

    document.getElementById("refreshNetworkBtn").addEventListener("click", function() {
      if (currentClusterID && window.globalData) {
        showClusterNetwork(currentClusterID);
      }
    });
    
    const tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    document.body.appendChild(tooltip);
    
    const filterIds = [
      'payloadSearch', 'sourceFilter', 'destinationFilter',
      'protocolFilter', 'entropyMinFilter', 'entropyMaxFilter',
      'isLargePacketFilter', 'isSuspiciousAckFilter', 'rowOrderSelect',
      'minSourceAmtFilter', 'maxSourceAmtFilter', 'minDestinationAmtFilter', 'maxDestinationAmtFilter'
    ];
    
    filterIds.forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('keydown', function (event) {
        if (event.key === "Enter") {
          updateHeatmap();
        }
      });
    });
    
    document.addEventListener('click', function(event) {
      if (!event.target.classList.contains('cell')) {
        d3.selectAll("rect.cell.selected")
          .classed("selected", false)
          .transition()
          .duration(200)
          .style("fill", function() {
            return d3.select(this).attr("data-original-fill");
          });
        window.selectedClusters.clear();
        window.usedHighlightHues = [];
        d3.select("#exploreClustersBtn").remove();
      }
    });
    
    document.getElementById('tableSearchInput').addEventListener('input', function () {
      const query = this.value.trim().toLowerCase();
      const rows = document.querySelectorAll('#table-container table tbody tr');
      const headerCells = document.querySelectorAll('#table-container table thead th');
      let payloadIndex = -1;
      headerCells.forEach((th, idx) => {
        if (th.textContent.trim().toLowerCase() === 'payload') {
          payloadIndex = idx;
        }
      });
      if (payloadIndex === -1) return;
      rows.forEach(row => {
        const cell = row.cells[payloadIndex];
        const text = cell ? cell.textContent.toLowerCase() : '';
        row.style.display = text.includes(query) ? '' : 'none';
      });
    });
  </script> 
</body>
</html>
