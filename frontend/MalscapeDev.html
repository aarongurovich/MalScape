<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MalScape</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; color: #333; background-color: #f8f9fa; overflow-x: hidden; }
body { display: flex; }

#legend-container {
    width: 220px;
    background-color: #fff;
    border-right: 1px solid #dee2e6;
    padding: 16px 12px;
    height: 100vh;
    overflow-y: auto;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    position: fixed;
    left: -220px;
    top: 0;
    z-index: 1050;
    transition: left 0.3s ease;
}
#legend-container.visible {
    left: 0;
}

#sidebar {
    width: 0;
    height: 100vh;
    background-color: #f1f3f5;
    border-right: 1px solid #dee2e6;
    padding: 0;
    overflow-x: hidden;
    overflow-y: auto;
    transition: width 0.3s ease, padding 0.3s ease, left 0.3s ease, background-color 0.3s ease;
    position: fixed;
    top: 0;
    left: 0;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    z-index: 1100;
    display: flex;
    flex-direction: column;
}
#sidebar.open {
    width: 500px;
    padding: 20px;
    left: 220px;
}
#sidebar-content {
    opacity: 0;
    transition: opacity 0.3s ease 0.1s;
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
}
#sidebar.open #sidebar-content {
    opacity: 1;
    overflow: visible;
}
#sidebar-cy {
    width: 100%;
    height: 40%;
    min-height: 250px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    background-color: #fff;
    margin-top: 10px;
    flex-shrink: 0;
}

#sidebar-toggle {
    position: fixed;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    z-index: 1200;
    background-color: #4299e1;
    color: white;
    border: none;
    padding: 15px 8px;
    border-radius: 0 6px 6px 0;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
    transition: background-color 0.2s ease, left 0.3s ease;
    writing-mode: vertical-rl;
    text-orientation: mixed;
}
#sidebar-toggle:hover {
    background-color: #3182ce;
}

#main-container {
    flex: 1;
    padding: 24px;
    height: 100vh;
    overflow-y: auto;
    transition: margin-left 0.3s ease;
    margin-left: 0;
    padding-left: 40px;
}

#nodeSizeMin, #nodeSizeMax, #edgeWidthMin, #edgeWidthMax { width: 200px; }
h2 { color: #2c3e50; margin-top: 0; margin-bottom: 24px; font-size: 28px; font-weight: 600; border-bottom: 2px solid #4299e1; padding-bottom: 8px; display: inline-block; }
h3 { color: #2c3e50; font-size: 16px; margin-top: 0; margin-bottom: 12px; font-weight: 600; }
#sidebar h3 { font-size: 18px; margin-bottom: 10px; flex-shrink: 0; }

.control-group { margin-bottom: 20px; padding: 16px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
.sidebar-control {
    padding: 8px 0;
    margin-bottom: 5px;
    background: none;
    box-shadow: none;
    border-radius: 0;
    flex-shrink: 0;
}
.sidebar-control label {
    font-size: 13px;
    margin-right: 5px;
}

mark {
background-color: yellow;
color: black;
padding: 0.1em;
border-radius: 3px;
}

label { display: inline-block; margin-right: 8px; font-weight: 500; color: #4a5568; }
input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] { padding: 8px 12px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; margin-right: 12px; margin-bottom: 8px; transition: border-color 0.2s; }
input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus { border-color: #4299e1; outline: none; box-shadow: 0 0 0 3px rgba(66,153,225,0.15); }
button { background-color: #4299e1; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s; margin-right: 8px; }
button:hover { background-color: #3182ce; }
#loadMoreBtn { display: none; margin-top: 16px; background-color: #38a169; }
#loadMoreBtn:hover { background-color: #2f855a; }
#cy { width: 100%; height: 600px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-top: 24px; margin-bottom: 24px; background-color: #fff; display: none; }

#table-container { margin-top: 24px; margin-bottom: 24px; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: none; max-height: 300px; overflow-y: auto; }
#table-container table { width: 100%; border-collapse: collapse; table-layout: auto; }
#table-container th, #table-container td { padding: 12px 15px; border-bottom: 1px solid #e9ecef; text-align: left; white-space: nowrap; }
#table-pagination { display: none; margin-top: 8px; text-align: center; }
#table-pagination input { width: 60px; text-align: center; }
#tooltip { position: absolute; display: none; background: rgba(255, 255, 255, 0.95); border-radius: 4px; padding: 8px 12px; font-size: 13px; color: #2d3748; pointer-events: none; z-index: 2000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px; line-height: 1.5; border: 1px solid #dee2e6; }
.color-box { display: inline-block; width: 12px; height: 12px; vertical-align: middle; margin-right: 4px; border: 1px solid #ccc; }
#legend { font-size: 12px; line-height: 1.4; table-layout: fixed; width: 100%;}
#legend th, #legend td { padding: 4px 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
#legend td:first-child, #legend th:first-child { width: 45%; }
#legend td:nth-child(2), #legend th:nth-child(2) { width: 25%; }
#legend td:last-child, #legend th:last-child { width: 30%; text-align: right;}
#backToHeatmap { margin: 20px 0; padding: 8px 16px; font-size: 14px; display: none; }
#edgeFilterPanel { position: absolute; top: 80px; right: 20px; width: 320px; padding: 12px; background-color: #fff; border: 1px solid #e2e8f0; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); display: none; z-index: 999; }
#edgeFilterPanel h4 { margin-top: 0; margin-bottom: 8px; font-size: 16px; font-weight: 600; color: #2c3e50; }
#edgeFilterPanel label { display: block; margin-top: 8px; font-weight: 500; color: #4a5568; }
#edgeFilterPanel input { margin-bottom: 8px; width: 100%; }
#loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; }
.spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4299e1; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 16px; }
.loading-text { font-size: 18px; color: #333; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
#resetSidebarBtn { background-color: #6c757d; margin-top: 5px; margin-bottom: 10px; width: 100%; flex-shrink: 0; }
#resetSidebarBtn:hover { background-color: #5a6268; }

#sidebar-table-search-container {
    padding: 10px 0 5px 0;
    flex-shrink: 0;
    display: none;
}
#sidebar-table-search-container label {
    font-weight: 600;
    font-size: 13px;
    margin-right: 5px;
}
#sidebarTableSearchInput {
    width: calc(100% - 100px);
    padding: 5px 8px;
    font-size: 12px;
}

#sidebar-table-container {
    margin-top: 15px;
    flex-grow: 1;
    overflow: auto;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background-color: #fff;
    display: none;
    position: relative;
}
#sidebar-table-container table {
    font-size: 11px;
    width: 100%;
    border-collapse: collapse;
    table-layout: auto;
}
#sidebar-table-container th {
    background-color: #f1f3f5;
    padding: 8px 10px;
    text-align: left;
    position: sticky;
    top: 0;
    z-index: 1;
    border-bottom: 2px solid #dee2e6;
    font-weight: 600;
    white-space: nowrap;
}
#sidebar-table-container td {
    padding: 8px 10px;
    white-space: normal;
    word-break: break-word;
    border: none;
    border-bottom: 1px solid #e9ecef;
    vertical-align: top;
    line-height: 1.4;
}
#sidebar-table-container tr:last-child td { border-bottom: none; }
#sidebar-table-container tbody tr:nth-child(even) { background-color: #f8f9fa; }
#sidebar-table-container tbody tr:hover { background-color: #e9ecef; cursor: pointer; }

#sidebar-table-container th,
#sidebar-table-container td {
min-width: 150px;
word-break: break-word;
}
#sidebar-table-pagination {
    text-align: center;
    margin-top: 8px;
    display: none;
    flex-shrink: 0;
}
#sidebar-table-pagination button { padding: 4px 8px; font-size: 12px; }
#sidebar-table-pagination input { width: 45px; font-size: 12px; padding: 4px 6px; }

#sidebar-table-no-results {
    text-align: center;
    padding: 10px;
    color: #6c757d;
    display: none;
}

#sidebarFullscreenBtn {
    position: absolute;
    top: 0px;
    right: 15px;
    width: auto;
    padding: 4px 8px;
    font-size: 18px;
    line-height: 1;
    z-index: 1150;
    background-color: #6c757d;
    color: white;
    border: 1px solid #5a6268;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    margin: 0;
}
#sidebarFullscreenBtn:hover {
    background-color: #5a6268;
    border-color: #4e555b;
}


#legend-container.fullscreen-active {
    display: block !important;
    position: fixed !important;
    left: 0 !important;
    top: 0 !important;
    height: 100vh !important;
    width: 220px !important;
    z-index: 1999 !important;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    border-right: 1px solid #dee2e6;
    background-color: #fff;
    overflow-y: auto;
}

#sidebar.fullscreen #sidebar-cy {
flex: 1 1 60%;
min-height: 150px !important;
height: auto !important;
margin-top: 0 !important;
border-radius: 6px 0 0 6px;
border: 1px solid #dee2e6;
}

#sidebar.fullscreen h3,
#sidebar.fullscreen #resetSidebarBtn,
#sidebar.fullscreen #sidebar-info,
#sidebar.fullscreen #sidebar-table-pagination {
display: none !important;
visibility: hidden !important;
}

#sidebar.fullscreen #sidebar-table-search-container {
display: block !important;
visibility: visible !important;
}


#sidebar.fullscreen #sidebar-cy {
flex: 1 1 65%;
min-height: 150px !important;
height: auto !important;
margin-top: 0 !important;
border-radius: 6px 0 0 6px;
border: 1px solid #dee2e6;
}

#sidebar.fullscreen #sidebar-table-container {
flex: 1 1 30%;
min-height: 100px;
height: auto !important;
margin-top: 10px !important;
display: block;
border-radius: 6px;
border: 1px solid #dee2e6;
}

body.sidebar-fullscreen #main-container,
body.sidebar-fullscreen #sidebar-toggle {
display: none !important;
visibility: hidden !important;
}
/* --- BEGIN ADDED Dendrogram CSS --- */
#dendrogramCard {
    display: none; /* Initially hidden */
    background: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 20px;
    border-radius: 12px;
    margin: 20px 0;
    border: 1px solid #e2e8f0;
}
#inline-dendrogram-container {
    margin-bottom: 10px;
    width: 100%;
    height: 400px; /* Default height */
    overflow: hidden;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    position: relative;
}
#inlineDendrogramSvg {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
}
#inlineDendrogramSvg:active {
    cursor: grabbing;
}
#treeControls {
    margin-top: 15px;
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
}
#treeControls label {
    margin-bottom: 0;
}
#treeControls input[type="number"] {
    margin-bottom: 0;
    vertical-align: middle;
    width: 70px;
    padding: 6px 8px;
}
#treeControls button {
    padding: 6px 12px;
}
#treeControls select {
    padding: 6px 8px;
    margin-bottom: 0;
}
#reclusterMessage {
    color: #e53e3e;
    font-size: 13px;
    margin-top: 8px;
    font-weight: 500;
    width: 100%; /* Ensure it takes full width */
}
.tree-height-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: auto;
}
.tree-height-controls button {
    background: none;
    border: 1px solid #cbd5e0;
    color: #4a5568;
    padding: 4px 10px;
    cursor: pointer;
}
.tree-height-controls button:hover {
    background-color: #edf2f7;
    border-color: #a0aec0;
}
.custom-height-link {
    background: none;
    border: none;
    color: #4299e1;
    cursor: pointer;
    font-size: 13px;
    text-decoration: underline;
    padding: 0;
    margin-left: 5px;
}
.custom-height-link:hover {
    color: #3182ce;
}
.show-tree-button {
    padding: 6px 12px;
    font-size: 14px;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.show-tree-button:hover {
    background-color: #218838;
}
.small-utility-button {
    padding: 3px 8px;
    font-size: 12px;
    background-color: #6c757d;
    border-radius: 4px;
    color: white;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s;
}
.small-utility-button:hover {
    background-color: #5a6268;
}
/* Dendrogram node/link styles */
.node--leaf circle {
    fill: #999;
    stroke: none;
}
.node--internal circle {
    fill: #555;
    stroke: none;
}
.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}
.node--leaf circle.highlighted {
    /* Color is set dynamically by JS */
    r: 6 !important;
    stroke: #555;
    stroke-width: 0.5px;
}
.node.grayed-out > circle {
    fill: #d3d3d3 !important;
    stroke: #bbb !important;
    opacity: 0.6;
}
.node.grayed-out > text { /* If using text labels later */
    fill: #aaa !important;
    opacity: 0.7;
}
#threshold-bar {
    stroke: rgba(220, 53, 69, 0.7);
    stroke-width: 2;
    stroke-dasharray: 5 3;
    pointer-events: none;
}
.heatmap-cell { /* Tree-attached heatmap cells */
    cursor: pointer;
}
.heatmap-feature-label {
     font-size: 9px;
     fill: #333;
     text-anchor: end;
     dominant-baseline: middle;
}
/* --- END ADDED Dendrogram CSS --- */
    </style>
</head>
<body>
  <div id="loading-overlay" title="Data is loading...">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
  </div>

  <div id="legend-container" title="Shows protocol colors and statistics.">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <thead><tr><th>Protocol</th><th>Color</th><th>Process %</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="control-group sidebar-control" style="margin-top: 20px; padding: 10px 0px 5px 0px; box-shadow: none;" title="Adjust node and edge sizes in the sidebar graph.">
        <h3 style="margin-bottom: 10px; font-size: 14px;">Sidebar Graph Sizing</h3>

        <label for="sidebarNodeSizeMin" style="font-size: 12px; display: block; margin-bottom: 2px;">Min Node Size:</label>
        <input type="number" id="sidebarNodeSizeMin" placeholder="5" step="1" min="1" value="10" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarNodeSizeMax" style="font-size: 12px; display: block; margin-bottom: 2px;">Max Node Size:</label>
        <input type="number" id="sidebarNodeSizeMax" placeholder="40" step="1" min="1" value="40" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarEdgeWidthMin" style="font-size: 12px; display: block; margin-bottom: 2px;">Min Edge Width:</label>
        <input type="number" id="sidebarEdgeWidthMin" placeholder="0.5" step="0.1" min="0.1" value="1" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarEdgeWidthMax" style="font-size: 12px; display: block; margin-bottom: 2px;">Max Edge Width:</label>
        <input type="number" id="sidebarEdgeWidthMax" placeholder="8" step="0.1" min="0.1" value="6" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">
    </div>
    
  </div>

  <button id="sidebar-toggle" title="Open/close cluster detail sidebar">&#9776;</button>

  <div id="sidebar" title="Shows detailed graph and data for selected heatmap clusters.">
      <div id="sidebar-content">
          <button id="sidebarFullscreenBtn" title="Toggle Sidebar Fullscreen">&#x2922;</button>

          <h3>Cluster Visualization</h3>
          <button id="resetSidebarBtn" title="Clear sidebar graph, table, and heatmap selections.">Reset Node Selection</button>

          <div class="control-group sidebar-control" title="Change sidebar graph layout.">
              <label for="sidebarLayoutSelect">Layout:</label>
              <select id="sidebarLayoutSelect" style="padding: 4px 8px; font-size: 12px; max-width: 150px;">
                  <option value="cose" selected>Cose (Default)</option>
                  <option value="breadthfirst">Hierarchical</option>
                  <option value="circle">Circle</option>
                  <option value="grid">Grid</option>
                  <option value="concentric">Concentric</option>
                  </select>
          </div>

          <div id="sidebar-cy-loading" style="display: none; text-align: center; margin-top: 5px; color: #6c757d;">Loading graph...</div>
          <div id="sidebar-cy" title="Interactive graph of selected cluster(s). Click nodes/edges to filter table."></div>
          <div id="sidebar-info" style="margin-top: 10px; font-size: 14px; text-align: center; flex-shrink: 0;">Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.</div>

          <div id="sidebar-table-search-container" title="Filter sidebar table rows.">
              <label for="sidebarTableSearchInput">Search Table:</label>
              <input type="text" id="sidebarTableSearchInput" placeholder="Enter keywords...">
          </div>

          <div id="sidebar-table-loading" style="display: none; text-align: center; margin-top: 20px; color: #6c757d;">Loading table...</div>
          <div id="sidebar-table-container" title="Detailed connection data for selected cluster/node/edge(s). Click row to highlight edge.">
             <p id="sidebar-table-no-results">No rows match your search criteria.</p>
             </div>
          <div id="sidebar-table-pagination" title="Navigate sidebar table pages.">
              <span>Page <input type="number" id="sidebarCurrentPageInput" value="1" min="1"> of <span id="sidebarTotalPages">?</span></span>
              <button id="sidebarGoPageBtn">Go</button>
          </div>
      </div>
  </div>

  <div id="main-container">
    <h2>MalScape</h2>
    <div id="topControls">
      <div style="margin-bottom: 16px; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <label for="fileInput"><strong>Upload CSV File:</strong></label>
        <input type="file" id="fileInput" accept=".csv" title="Select CSV file to visualize.">
        <button id="downloadButton" title="Download currently loaded data as CSV.">Download Processed CSV File</button>
      </div>
      <div class="control-group" title="Filter data displayed in heatmap.">
        <label for="rowOrderSelect">Order Cells By:</label>
        <select id="rowOrderSelect" title="Order heatmap rows by metric value."> <option value="descending">Descending</option> <option value="ascending">Ascending</option> </select>
        <label for="minSourceAmtFilter">Min Src:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="1" step="1" style="width:60px;" title="Minimum source appearances.">
        <label for="maxSourceAmtFilter">Max Src:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="Inf" step="1" style="width:60px;" title="Maximum source appearances.">
        <label for="minDestinationAmtFilter">Min Dst:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="1" step="1" style="width:60px;" title="Minimum destination appearances.">
        <label for="maxDestinationAmtFilter">Max Dst:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="Inf" step="1" style="width:60px;" title="Maximum destination appearances.">
        <label for="payloadSearch">Payload:</label>
        <input type="text" id="payloadSearch" placeholder="Keyword" style="width:100px;" title="Filter by payload keyword.">
        <label for="sourceFilter">Src IP:</label>
        <input type="text" id="sourceFilter" placeholder="IP" style="width:100px;" title="Filter by source IP/subnet.">
        <label for="destinationFilter">Dst IP:</label>
        <input type="text" id="destinationFilter" placeholder="IP" style="width:100px;" title="Filter by destination IP/subnet.">
        <label for="protocolFilter">Proto:</label>
        <input type="text" id="protocolFilter" placeholder="TCP" style="width:60px;" title="Filter by protocol name.">
        <label for="entropyMinFilter">Min Ent:</label>
        <input type="number" id="entropyMinFilter" placeholder="0.0" step="0.1" style="width:60px;" title="Minimum payload entropy.">
        <label for="entropyMaxFilter">Max Ent:</label>
        <input type="number" id="entropyMaxFilter" placeholder="Inf" step="0.1" style="width:60px;" title="Maximum payload entropy.">
        <label for="isLargePacketFilter">Large Pkts:</label>
        <input type="checkbox" id="isLargePacketFilter" title="Filter for large packets.">
        <label for="isSuspiciousAckFilter">Susp ACK:</label>
        <input type="checkbox" id="isSuspiciousAckFilter" title="Filter for suspicious ACKs.">
        <button id="applyFiltersBtn" style="margin-left: 10px;" title="Apply selected filters to heatmap.">Apply Filters</button>
      </div>
    </div>
    <div id="dendrogramCard" style="display: none; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #e2e8f0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div>
                <h3>Hierarchical Cluster Tree</h3>
                <span id="treeInfoSpan" style="font-size: 12px; color: #555; margin-left: 10px;"></span>
                <span id="timeInfoSpan" style="font-size: 12px; color: #555; margin-left: 15px;"></span>
            </div>
        </div>
        <div id="inline-dendrogram-container" style="margin-bottom: 10px; width: 100%; height: 400px; overflow: hidden; border: 1px solid #dee2e6; border-radius: 6px; position: relative;">
        <svg id="inlineDendrogramSvg" style="width: 100%; height: 100%; display: block; cursor: grab;"></svg>
        </div>
        <div id="treeControls" style="margin-top: 15px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
        <label for="dendrogramSortMetricSelect">Order Heatmap By:</label>
        <select id="dendrogramSortMetricSelect" style="padding: 6px 8px; margin-bottom: 0;">
            <option value="Default" selected>Default (Structure)</option>
            
            <optgroup label="Basic Counts">
                <option value="Count">Count</option>
                <option value="Unique IPs">Unique IPs</option>
                <option value="Unique Sources">Unique Sources</option>
                <option value="Unique Destinations">Unique Destinations</option>
            </optgroup>

            <optgroup label="Packet/Payload Size">
                <option value="Length">Packet Length</option>
                <option value="Len">Payload Length</option>
                <option value="Payload Size Variance">Payload Size Variance</option>
            </optgroup>

            <optgroup label="Timing/Rate">
                <option value="Start Time">Start Time</option>
                <option value="Duration">Duration</option>
                <option value="Average Inter-Arrival Time">Avg Inter-Arrival Time</option>
                <option value="Packets per Second">Packets per Second</option>
            </optgroup>

            <optgroup label="Data Volume">
                 <option value="Total Data Sent">Total Data Sent</option>
             </optgroup>

            <optgroup label="TCP Flags">
                <option value="% SYN packets">% SYN packets</option>
                <option value="% RST packets">% RST packets</option>
                <option value="% ACK packets">% ACK packets</option>
                <option value="% PSH packets">% PSH packets</option>
            </optgroup>
        </select>
        <div style="display: inline-block; margin-left: 5px; vertical-align: middle;">
            <input type="checkbox" id="reorderTreeCheckbox" style="vertical-align: middle; margin-right: 4px;">
            <label for="reorderTreeCheckbox" style="font-weight: normal; font-size: 13px;">Reorder Tree Structure</label>
        </div>
        <label for="resolutionInput">Louvain Resolution:</label>
        <input type="number" id="resolutionInput" value="2.5" step="0.1" min="0.1" placeholder="default 2.5" style="margin-bottom: 0; vertical-align: middle; width: 70px; padding: 6px 8px;">
        <button onclick="reclusterAndRedraw()" style="padding: 6px 12px;">Apply Resolution</button>
        <button onclick="resetInlineZoom()" style="padding: 6px 12px;">Reset Zoom</button>
        <label for="thresholdSlider">Visual Threshold:</label>
        <input type="range" id="thresholdSlider" min="0" max="100" value="100" style="width: 150px; vertical-align: middle;">
        <span id="thresholdValue">100%</span>
        <div id="reclusterMessage" style="width: 100%; margin-top: 5px; color: #e53e3e; font-size: 13px; font-weight: 500;"></div>
        </div>
    </div>
    <div id="table-search-container" style="display:none; margin-bottom: 12px; margin-top: 24px;" title="Search main table payload.">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>
    <div id="table-container" title="Main connection data table (used in network graph view)."></div>
    <div id="table-pagination" title="Navigate main table pages.">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
    <div style="margin-top: 20px;">
        <button id="loadMoreBtn" title="Load more data (not implemented).">Load More</button>
        <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;" title="Refresh network graph (not implemented).">Refresh Network</button>
    </div>
    <div id="sizeControls" style="display: none; margin-top: 16px;" title="Adjust node and edge sizes in the main graph.">
      <label for="edgeWidthMin">Min Edge Width:</label>
      <input type="number" id="edgeWidthMin" placeholder="1" step="0.1" min="0.1" value="1">
      <label for="edgeWidthMax">Max Edge Width:</label>
      <input type="number" id="edgeWidthMax" placeholder="10" step="0.1" min="0.1" value="10">
      <label for="nodeSizeMin">Min Node Size:</label>
      <input type="number" id="nodeSizeMin" placeholder="15" step="1" min="1" value="15">
      <label for="nodeSizeMax">Max Node Size:</label>
      <input type="number" id="nodeSizeMax" placeholder="60" step="1" min="1" value="60">
    </div>
    <div id="cy" title="Main network graph view (not fully implemented)."></div>
  </div>

  <div id="edgeFilterPanel" title="Filter edges in main network graph.">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label> <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label> <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label> <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label> <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label> <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn" title="Apply edge filters.">Filter Edges</button> <button id="clearEdgeFilterBtn" title="Remove edge filters.">Clear Filter</button>
  </div>

  <div id="tooltip" title="Hover details appear here."></div>

  <script>
    const API_BASE_URL = 'http://127.0.0.1:5000';
    const DEFAULT_UNKNOWN_COLOR = '#cccccc';
    const SELECTED_EDGE_COLOR = '#ff0000';
    const SELECTED_NODE_COLOR = '#ff0000';
    const SELECTED_EDGE_WIDTH = 3.5;
    const SELECTED_EDGE_ZINDEX = 999;

    let previousClusterCount = null;
    let previousClusterHash = null;
    let currentDendrogramHeight = 400;
    window.lastTreeData = null;
    window.inlineZoom = null;
    let initialTreeTransform = d3.zoomIdentity;
    const margin = { top: 30, right: 30, bottom: 120, left: 30 };
    window.fullHeatmapData = {};
    window.heatmapSortOrders = {};
    const metrics = [
     { label: "Count", value: "count" }, { label: "Unique IPs", value: "Unique IPs" },
     { label: "Unique Sources", value: "Unique Sources" }, { label: "Unique Destinations", value: "Unique Destinations" },
     { label: "Packet Length", value: "Length" }, { label: "Payload Length", value: "Len" },
     { label: "Payload Size Variance", value: "Payload Size Variance" },
     { label: "Start Time", value: "Start Time" },
     { label: "Duration", value: "Duration" },
     { label: "Average Inter-Arrival Time", value: "Average Inter-Arrival Time" },
     { label: "Packets per Second", value: "Packets per Second" },
     { label: "Total Data Sent", value: "Total Data Sent" },
     { label: "% SYN packets", value: "% SYN packets" }, { label: "% RST packets", value: "% RST packets" },
     { label: "% ACK packets", value: "% ACK packets" }, { label: "% PSH packets", value: "% PSH packets" }
 ];

    let protocolColorMap = {};
    let globalCy;
    let sidebarCy;
    let currentClusterID = null;
    let currentSidebarTableClusterId = null;
    const TABLE_PAGE_SIZE = 30;
    const heatmapCellWidth = 2;
    const heatmapCellHeight = 15;
    let tooltip;
    let clusterHighlightColors = new Map();
    let addedSidebarClusters = new Set();
    let selectedSidebarEdges = new Set();
    let selectedNodeId = null;
    let sidebarTableMode = 'cluster';
    let isSidebarOpen = false;
    const sidebarWidth = 500;
    const legendWidth = 220;

    const sidebar = document.getElementById('sidebar');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle');
    const mainContainer = document.getElementById('main-container');
    const legendContainer = document.getElementById('legend-container');
    const resetSidebarBtn = document.getElementById('resetSidebarBtn');
    const sidebarTableContainer = document.getElementById('sidebar-table-container');
    const sidebarTablePagination = document.getElementById('sidebar-table-pagination');
    const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');
    const sidebarSearchContainer = document.getElementById('sidebar-table-search-container');
    const sidebarSearchInput = document.getElementById('sidebarTableSearchInput');
    const sidebarInfoDiv = document.getElementById('sidebar-info');
    const sidebarFullscreenBtn = document.getElementById('sidebarFullscreenBtn');
    let isSidebarFullscreen = false;


    const sidebarLayoutOptions = {
        cose: {
            name: 'cose', animate: true, animationDuration: 500, padding: 30,
            idealEdgeLength: 100, nodeRepulsion: node => node.degree() * 15000,
            edgeElasticity: edge => 100, gravity: 60, numIter: 1000,
            initialTemp: 200, coolingFactor: 0.95, minTemp: 1.0, fit: true
        },
        breadthfirst: {
            name: 'breadthfirst', directed: true, padding: 20, circle: false,
            grid: false, spacingFactor: 1.4, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, roots: undefined,
            animate: true, animationDuration: 500, fit: true
        },
        circle: {
            name: 'circle', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1.2, radius: undefined,
            startAngle: 3/2 * Math.PI,
            animate: true, animationDuration: 500, fit: true
        },
        grid: {
            name: 'grid', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1,
            rows: undefined, cols: undefined,
            position: function( node ){},
            animate: true, animationDuration: 500, fit: true
        },
        concentric: {
            name: 'concentric', fit: true, padding: 30, startAngle: 3 / 2 * Math.PI,
            sweep: undefined, clockwise: true, equidistant: false,
            minNodeSpacing: 20, avoidOverlap: true, nodeDimensionsIncludeLabels: false,
            concentric: function( node ){ return node.degree(); },
            levelWidth: function( nodes ){ return nodes.maxDegree() / 4; },
            animate: true, animationDuration: 500
        }
    };

    function applySidebarLayout() {
        if (!sidebarCy) {
            console.log("Sidebar graph not initialized yet.");
            return;
        }
        const selectedLayoutName = document.getElementById('sidebarLayoutSelect').value;
        const layoutConfig = sidebarLayoutOptions[selectedLayoutName];

        if (!layoutConfig) {
            console.error(`Layout configuration for '${selectedLayoutName}' not found.`);
            return;
        }

        console.log(`Applying sidebar layout: ${selectedLayoutName}`);
        let layout = sidebarCy.layout(layoutConfig);
        layout.run();
    }

    function toggleSidebar(forceOpen = null) {
     const shouldBeOpen = forceOpen !== null ? forceOpen : !isSidebarOpen;

     if (shouldBeOpen) {
         if (!isSidebarOpen) {
             legendContainer.classList.add('visible');
             sidebar.classList.add('open');
             isSidebarOpen = true;
             sidebarToggleBtn.innerHTML = '&times;';
             sidebarToggleBtn.style.left = `${legendWidth + sidebarWidth}px`;
             mainContainer.style.marginLeft = `${legendWidth + sidebarWidth}px`;
             setTimeout(() => {
                 if (sidebarCy) {
                     sidebarCy.resize();
                     applySidebarLayout();
                     sidebarCy.fit(null, 30);
                 }
             }, 350);
         }
     } else {
          if (isSidebarOpen) {
             legendContainer.classList.remove('visible');
             sidebar.classList.remove('open');
             isSidebarOpen = false;
             sidebarToggleBtn.innerHTML = '&#9776;';
             sidebarToggleBtn.style.left = `0px`;
             mainContainer.style.marginLeft = `0px`;
          }
     }
 }

    resetSidebarBtn.addEventListener('click', () => {
        console.log("Resetting sidebar view and heatmap highlights.");
        clearSidebarVisualization();
        updateLegend();
        updateHeatmap();
        selectedNodeId = null;
        document.getElementById('sidebarLayoutSelect').value = 'cose';
    });

    function showSidebarLoading(isLoadingGraph, isLoadingTable) {
        document.getElementById('sidebar-cy-loading').style.display = isLoadingGraph ? 'block' : 'none';
        document.getElementById('sidebar-table-loading').style.display = isLoadingTable ? 'block' : 'none';
        const showInfo = !isLoadingGraph && !isLoadingTable && (!sidebarCy || sidebarCy.elements().length === 0) && selectedSidebarEdges.size === 0 && selectedNodeId === null;
         sidebarInfoDiv.style.display = showInfo ? 'block' : 'none';
    }

    function filterSidebarTable() {
        if (!sidebarTableContainer || !sidebarSearchInput) return;

        const keywords = sidebarSearchInput.value.toLowerCase().split(' ').filter(k => k.trim() !== '');
        const tableBody = sidebarTableContainer.querySelector('tbody');
        const noResultsMsg = document.getElementById('sidebar-table-no-results');

        if (!tableBody) {
            if (noResultsMsg) noResultsMsg.style.display = 'none';
            return;
        }

        const rows = tableBody.querySelectorAll('tr');
        let visibleRowCount = 0;

        const removeHighlight = (node) => {
            const marks = node.querySelectorAll('mark');
            marks.forEach(mark => {
                const parent = mark.parentNode;
                while (mark.firstChild) {
                    parent.insertBefore(mark.firstChild, mark);
                }
                parent.removeChild(mark);
                parent.normalize();
            });
        };

        const addHighlight = (node, textToHighlight) => {
            if (!textToHighlight) return;

            const text = node.textContent.toLowerCase();
            const startIndex = text.indexOf(textToHighlight);

            if (startIndex === -1) return;

            const pattern = new RegExp(textToHighlight.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
            const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);
            let currentNode;
            const nodesToProcess = [];

            while(currentNode = walker.nextNode()) {
                 nodesToProcess.push(currentNode);
            }

            nodesToProcess.forEach(textNode => {
                const textContent = textNode.nodeValue;
                let match;
                let lastIndex = 0;
                const fragment = document.createDocumentFragment();

                while ((match = pattern.exec(textContent)) !== null) {
                    if (match.index > lastIndex) {
                        fragment.appendChild(document.createTextNode(textContent.substring(lastIndex, match.index)));
                    }
                    const mark = document.createElement('mark');
                    mark.textContent = match[0];
                    fragment.appendChild(mark);

                    lastIndex = pattern.lastIndex;
                }
                if (lastIndex < textContent.length) {
                    fragment.appendChild(document.createTextNode(textContent.substring(lastIndex)));
                }

                if (fragment.hasChildNodes() && lastIndex > 0) {
                     textNode.parentNode.replaceChild(fragment, textNode);
                }
            });
        };

        rows.forEach(row => {
            row.querySelectorAll('td').forEach(cell => {
                removeHighlight(cell);
            });

            const rowText = row.textContent.toLowerCase();
            let showRow = true;
            if (keywords.length > 0) {
                for (const keyword of keywords) {
                    if (!rowText.includes(keyword)) {
                        showRow = false;
                        break;
                    }
                }
            } else {
                showRow = true;
            }

            row.style.display = showRow ? '' : 'none';

            if (showRow && keywords.length > 0) {
                visibleRowCount++;
                row.querySelectorAll('td').forEach(cell => {
                    keywords.forEach(keyword => {
                        addHighlight(cell, keyword);
                    });
                });
            } else if (showRow) {
                 visibleRowCount++;
            }
        });

        if (noResultsMsg) {
             noResultsMsg.style.display = (visibleRowCount === 0 && keywords.length > 0) ? 'block' : 'none';
        }
    }

    function handleSidebarTableRowClick(event) {
        if (!sidebarCy || event.target.tagName !== 'TD') {
            return;
        }

        const row = event.target.closest('tr');
        if (!row || !row.parentElement || row.parentElement.tagName !== 'TBODY') {
             console.log("Clicked outside table body row.");
             return;
        }

        const table = row.closest('table');
        if (!table) return;

        const headerCells = Array.from(table.querySelectorAll('thead th'));
        const dataCells = Array.from(row.querySelectorAll('td'));

        let sourceIndex = -1;
        let destIndex = -1;
        let protocolIndex = -1;

        headerCells.forEach((th, index) => {
            const headerText = th.textContent.trim();
            if (headerText === 'Source') sourceIndex = index;
            else if (headerText === 'Destination') destIndex = index;
            else if (headerText === 'Protocol') protocolIndex = index;
        });

        if (sourceIndex === -1 || destIndex === -1 || protocolIndex === -1) {
            console.error("Could not find Source, Destination, or Protocol columns in the sidebar table header.");
            return;
        }

        const source = dataCells[sourceIndex]?.textContent.trim();
        const destination = dataCells[destIndex]?.textContent.trim();
        const protocol = dataCells[protocolIndex]?.textContent.trim();

        if (!source || !destination || !protocol) {
            console.error("Could not extract valid source, destination, or protocol from table row.", { source, destination, protocol });
            return;
        }

        console.log(`Table row clicked. Finding edge: ${source} -> ${destination} [${protocol}]`);

        const edgeSelector = `edge[source = "${source}"][target = "${destination}"][Protocol = "${protocol}"]`;
        const edgeToSelect = sidebarCy.elements(edgeSelector);

        if (edgeToSelect.length > 0) {
            console.log("Edge found:", edgeToSelect.id());
            deselectCurrentNode();

            sidebarCy.edges().filter(edge => edge !== edgeToSelect.first()).forEach(edge => {
                 selectedSidebarEdges.delete(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`);
                 const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                 const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                 edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                 edge.unselect();
            });

            const targetEdge = edgeToSelect.first();
            const edgeKey = `${source}|${destination}|${protocol}`;
            selectedSidebarEdges.add(edgeKey);
            targetEdge.style({
                 'line-color': SELECTED_EDGE_COLOR,
                 'target-arrow-color': SELECTED_EDGE_COLOR,
                 'width': SELECTED_EDGE_WIDTH,
                 'z-index': SELECTED_EDGE_ZINDEX
            });
            sidebarCy.elements().unselect();
            targetEdge.select();

            sidebarCy.animate({
                fit: {
                    eles: targetEdge.union(targetEdge.connectedNodes()),
                    padding: 70
                },
                duration: 400
            });
             updateSidebarTableForSelectedEdges();

        } else {
            console.warn(`Edge not found in sidebar graph for: ${source} -> ${destination} [${protocol}]`);
        }
    }

    function clearSidebarVisualization() {
        // --- Existing code to clear Sidebar Graph, State Variables, Table, etc. ---
        if (sidebarCy) {
            sidebarCy.destroy();
            sidebarCy = null;
        }
        document.getElementById('sidebar-cy').innerHTML = '';
        addedSidebarClusters.clear();
        selectedSidebarEdges.clear();
        selectedNodeId = null;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = null;
        sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>';
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        sidebarSearchContainer.style.display = 'none';
        if (sidebarSearchInput) sidebarSearchInput.value = '';
        document.getElementById('sidebar-cy-loading').style.display = 'none';
        document.getElementById('sidebar-table-loading').style.display = 'none';
        sidebarInfoDiv.innerHTML = 'Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.';
        sidebarInfoDiv.style.display = 'block';
        // --- End of existing code ---

        // Clear Heatmap Highlights (for the *main* heatmap, if you uncommented that)
        clusterHighlightColors.clear(); // Clear the central selection state map
        // resetHeatmapHighlights();    // Call function for main heatmap if needed

        // --- Clear Dendrogram Highlights (Leaves AND Attached Heatmap Outlines) ---
        try {
            const svgContent = d3.select("#inlineDendrogramSvg g"); // Select the content group
            if (!svgContent.empty()) {

                // 1. Reset Leaf Node Fills (using existing function)
                highlightTreeClusters(); // Calling with no arguments resets fills

                // --- 2. ADDED: Reset Tree-Attached Heatmap Cell Outlines ---
                const defaultStrokeColor = '#fff'; // Define or ensure access to default color
                const defaultStrokeWidth = 0.2;   // Define or ensure access to default width

                svgContent.selectAll('.heatmap-cell') // Select all heatmap cells within the dendro SVG
                    .transition().duration(150) // Use a short transition for smoothness
                    .style("stroke", defaultStrokeColor) // Set stroke color to default
                    .style("stroke-width", defaultStrokeWidth); // Set stroke width to default
                // --- End ADDED section ---

                console.log("Reset tree node highlights AND tree-attached heatmap cell outlines.");
            }
        } catch (error) {
            console.error("Error resetting tree elements:", error);
        }
        // --- End Dendrogram Reset ---

        // Reset Sidebar Layout Dropdown
        document.getElementById('sidebarLayoutSelect').value = 'cose';
        console.log("Sidebar visualization, color map, selections, table, and related highlights cleared.");
    }

    // Helper function to reset main heatmap highlights
    function resetHeatmapHighlights() {
        console.log("Resetting main heatmap cell highlights.");
        d3.selectAll('#heatmap rect.cell').each(function() { // Target only main heatmap cells
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) { cell.attr("fill", originalColor); }
            else { cell.style("fill", null); }
        });
    }

    // Helper function to reset main heatmap highlights (called by clearSidebarVisualization)
    function resetHeatmapHighlights() {
        console.log("Resetting main heatmap cell highlights.");
        d3.selectAll('#heatmap rect.cell').each(function() { // Target only main heatmap cells
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) {
                // Use transition only if desired, direct attr is faster
                // cell.transition().duration(100)
                cell.attr("fill", originalColor);
            } else {
                // Fallback if original color wasn't stored somehow
                cell.style("fill", null); // Let CSS/default handle it
                console.warn(`Missing original fill for heatmap cell: cluster ${cell.attr('data-cluster')}, metric ${cell.attr('data-metric')}`);
            }
        });
    }

    function calculateEdgeWidth(processCount) {
        const count = processCount || 1;
        const minCount = 1;
        const maxCount = 100;
        const minWidth = 1;
        const maxWidth = 5;
        const range = (maxCount - minCount) || 1;
        const width = minWidth + (maxWidth - minWidth) * ((count - minCount) / range);
        return Math.max(minWidth, Math.min(width, maxWidth));
    }

    const CYTOSCAPE_STYLE = [
        { selector: 'node', style: {
            'background-color': '#888',
            'label': 'data(label)',
            'width': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'height': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'font-size': 10, 'color': '#000',
            'text-valign': 'bottom', 'text-halign': 'center', 'text-margin-y': 4,
            'border-width': 0,
            'shape': 'ellipse',
            'transition-property': 'background-color, shape',
            'transition-duration': '0.15s'
        }},
        { selector: 'edge', style: {
            'line-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-shape': 'triangle', 'curve-style': 'bezier',
            'transition-property': 'line-color, target-arrow-color, width, z-index',
            'transition-duration': '0.15s',
            'z-index': 1
        }},
        { selector: 'node[Classification = "Internal"]', style: {
            'shape': 'square'
        }},
        { selector: 'node[Classification = "External"]', style: {
            'shape': 'ellipse'
        }}
    ];

    function generateUniqueHighlightColor() {
        const MIN_HUE_DIFF = 30;
        let attempts = 0;
        const existingHues = Array.from(clusterHighlightColors.values()).map(hslString => {
            const match = hslString.match(/hsl\((\d+),/);
            return match ? parseInt(match[1], 10) : -1;
        }).filter(h => h !== -1);

        while (attempts < 100) {
            let hue = Math.floor(Math.random() * 360);
            if ((hue >= 0 && hue <= 25) || (hue >= 335 && hue <= 360) || (hue >= 195 && hue <= 265)) {
                attempts++;
                continue;
            }
            let isDistinct = existingHues.every(existingHue => {
                let diff = Math.abs(hue - existingHue);
                return diff >= MIN_HUE_DIFF && (360 - diff) >= MIN_HUE_DIFF;
            });
            if (isDistinct) {
                const newColor = `hsl(${hue}, 85%, 60%)`;
                console.log(`Generated distinct color: ${newColor} (Hue: ${hue})`);
                return newColor;
            }
            attempts++;
        }
        console.warn("Could not find highly distinct color, using fallback random hue.");
        let fallbackHue;
        do {
            fallbackHue = Math.floor(Math.random() * 360);
        } while ((fallbackHue >= 0 && fallbackHue <= 25) || (fallbackHue >= 335 && fallbackHue <= 360) || (fallbackHue >= 195 && fallbackHue <= 265));
        return `hsl(${fallbackHue}, 85%, 60%)`;
    }

    function deselectCurrentNode() {
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const originalColor = node.scratch('_originalColor');
                if (originalColor) {
                    node.style('background-color', originalColor);
                } else {
                    const clusterID = node.data('clusterID');
                    const clusterColor = clusterHighlightColors.get(clusterID) || '#888';
                    node.style('background-color', clusterColor);
                    console.warn(`Missing scratch color for node ${selectedNodeId}, reverted using cluster/default color.`);
                }
                node.connectedEdges().forEach(edge => {
                    const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                    if (!selectedSidebarEdges.has(edgeKey)) {
                         const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                         const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                         edge.style({
                            'line-color': originalEdgeColor,
                            'target-arrow-color': originalEdgeColor,
                            'width': originalEdgeWidth,
                            'z-index': 1
                         });
                    }
                });
                 node.unselect();
                console.log(`Node ${selectedNodeId} and its non-selected edges deselected.`);
            } else {
                console.warn(`Attempted to deselect node ${selectedNodeId}, but it was not found.`);
            }
            selectedNodeId = null;
        }
    }

    function visualizeClusterInSidebar(clusterID, nodeColor) {
        if (addedSidebarClusters.has(clusterID)) {
             console.log(`Cluster ${clusterID} is already visualized.`);
             if (sidebarCy) {
                 sidebarCy.nodes(`[clusterID = "${clusterID}"]`).animate({ style: { 'opacity': 0.5 } }, { duration: 200 }).animate({ style: { 'opacity': 1 } }, { duration: 200 });
             }
             if (currentSidebarTableClusterId !== clusterID || sidebarTableMode !== 'cluster') {
                 loadSidebarClusterTable(clusterID, 1);
             }
             deselectCurrentNode();
             if (selectedSidebarEdges.size > 0 && sidebarCy) {
                  sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                  .forEach(edge => {
                      const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                      const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                      edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                      edge.unselect();
                  });
                  selectedSidebarEdges.clear();
             }
             applySidebarSizeControls();
             return;
        }

        toggleSidebar(true);
        showSidebarLoading(true, false);
        sidebarInfoDiv.innerHTML = `Loading network for Cluster ${clusterID}...`;
        sidebarInfoDiv.style.display = 'block';

        fetch(`${API_BASE_URL}/cluster_network?cluster_id=${clusterID}`)
            .then(response => { if (!response.ok) throw new Error(`Network error (${response.status})`); return response.json(); })
            .then(data => {
                showSidebarLoading(false, false);

                if (!data || (!data.nodes || data.nodes.length === 0)) {
                    console.log(`No network data for Cluster ${clusterID}.`);
                    if (!sidebarCy) {
                        sidebarCy = cytoscape({ container: document.getElementById('sidebar-cy'), style: CYTOSCAPE_STYLE });
                        bindSidebarGraphEvents();
                    }
                    addedSidebarClusters.add(clusterID);
                    loadSidebarClusterTable(clusterID, 1);
                    updateLegend(sidebarCy?.edges());
                    deselectCurrentNode();
                    return;
                }

                const nodesToAdd = data.nodes.map(node => ({
                    group: 'nodes',
                    data: { ...node.data, clusterID: clusterID, Classification: node.data.Classification || 'Unknown' },
                    style: { 'background-color': nodeColor },
                    scratch: { _originalColor: nodeColor }
                }));

                const edgesToAdd = data.edges.map(edge => {
                    const protocol = edge.data.Protocol || 'Unknown';
                    if (!protocolColorMap[protocol]) {
                        protocolColorMap[protocol] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                    }
                    const edgeColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                    return {
                        group: 'edges',
                        data: { ...edge.data, clusterID: clusterID },
                        style: { 'line-color': edgeColor, 'target-arrow-color': edgeColor },
                        scratch: { _protocolColor: edgeColor }
                    };
                });

                if (!sidebarCy) {
                    sidebarCy = cytoscape({
                        container: document.getElementById('sidebar-cy'),
                        elements: { nodes: nodesToAdd, edges: edgesToAdd },
                        style: CYTOSCAPE_STYLE
                    });
                    bindSidebarGraphEvents();
                    applySidebarSizeControls();
                    applySidebarLayout();
                    sidebarCy.fit(null, 30);
                } else {
                    sidebarCy.add(nodesToAdd.concat(edgesToAdd));
                    applySidebarSizeControls();
                    applySidebarLayout();
                    sidebarCy.fit(null, 30);
                }

                addedSidebarClusters.add(clusterID);
                sidebarInfoDiv.style.display = 'none';
                updateLegend(sidebarCy.edges());
                loadSidebarClusterTable(clusterID, 1);
                deselectCurrentNode();
            })
            .catch(error => {
                console.error(`Error visualizing cluster ${clusterID} in sidebar:`, error);
                showSidebarLoading(false, false);
                sidebarInfoDiv.innerHTML = `Error loading graph data for Cluster ${clusterID}.`;
                sidebarInfoDiv.style.display = 'block';
                loadSidebarClusterTable(clusterID, 1);
                deselectCurrentNode();
            });
    }

    function bindSidebarGraphEvents() {
        if (!sidebarCy) return;

        sidebarCy.removeListener('mouseover');
        sidebarCy.removeListener('mouseout');
        sidebarCy.removeListener('click');
        sidebarCy.removeListener('tap');

        sidebarCy.on('mouseover', 'node', (event) => {
            const node = event.target;
            tooltip.style("display", "block")
                   .html(`Node: ${node.data('label')}<br>Class: ${node.data('Classification') || 'N/A'}<br>Cluster: ${node.data('clusterID')}`)
                   .style("left", (event.originalEvent.pageX + 10) + "px")
                   .style("top", (event.originalEvent.pageY + 10) + "px");
        });
        sidebarCy.on('mouseover', 'edge', (event) => {
            const edge = event.target;
            tooltip.style("display", "block")
                   .html(`Src: ${edge.data('source')}<br>Dst: ${edge.data('target')}<br>Proto: ${edge.data('Protocol')}<br>Count: ${edge.data('processCount') || 0}<br>Cluster: ${edge.data('clusterID')}`)
                   .style("left", (event.originalEvent.pageX + 10) + "px")
                   .style("top", (event.originalEvent.pageY + 10) + "px");
        });
        sidebarCy.on('mouseout', 'node, edge', () => {
            tooltip.style("display", "none");
        });

        sidebarCy.on('click', 'edge', (event) => {
             if (selectedNodeId) {
                console.log("Node selection active, ignoring individual edge click.");
                return;
             }
            const edge = event.target;
            const source = edge.data('source');
            const target = edge.data('target');
            const protocol = edge.data('Protocol');
            const edgeKey = `${source}|${target}|${protocol}`;

            if (selectedSidebarEdges.has(edgeKey)) {
                selectedSidebarEdges.delete(edgeKey);
                const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                edge.unselect();
            } else {
                selectedSidebarEdges.add(edgeKey);
                edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
                edge.select();
            }
            updateSidebarTableForSelectedEdges();
        });

        sidebarCy.on('click', 'node', (event) => {
            const clickedNode = event.target;
            const clickedNodeId = clickedNode.id();

            if (selectedSidebarEdges.size > 0) {
                sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                .forEach(edge => {
                    const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                    const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                    edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                    edge.unselect();
                });
                selectedSidebarEdges.clear();
            }

            if (selectedNodeId === clickedNodeId) {
                deselectCurrentNode();
                 if (currentSidebarTableClusterId) { loadSidebarClusterTable(currentSidebarTableClusterId, 1); }
                 else { updateSidebarTableForSelectedEdges(); }

            } else {
                deselectCurrentNode();

                if (!clickedNode.scratch('_originalColor')) {
                    clickedNode.scratch('_originalColor', clickedNode.style('background-color'));
                }
                clickedNode.style('background-color', SELECTED_NODE_COLOR);
                clickedNode.connectedEdges().forEach(edge => {
                    if(!edge.scratch('_originalWidth')){
                        edge.scratch('_originalWidth', edge.style('width'));
                    }
                    if(!edge.scratch('_protocolColor')){
                        edge.scratch('_protocolColor', edge.style('line-color'));
                    }
                    edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
                });
                 clickedNode.select();
                selectedNodeId = clickedNodeId;
                console.log(`Node ${selectedNodeId} and its edges selected.`);
                updateSidebarTableForSelectedEdges();
            }
             sidebarInfoDiv.style.display = 'none';
        });

         sidebarCy.on('tap', function(event){
             if (event.target === sidebarCy) {
                 let deselectedSomething = false;
                 if(selectedNodeId){
                      deselectCurrentNode();
                      deselectedSomething = true;
                 }
                 if (selectedSidebarEdges.size > 0) {
                      sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                      .forEach(edge => {
                          const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                          const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                          edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                          edge.unselect();
                      });
                      selectedSidebarEdges.clear();
                      deselectedSomething = true;
                 }
                 if (deselectedSomething) {
                    if (currentSidebarTableClusterId) { loadSidebarClusterTable(currentSidebarTableClusterId, 1); }
                    else { updateSidebarTableForSelectedEdges(); }
                 }
             }
         });
    }

    function applySidebarSizeControls() {
        if (!sidebarCy) return;

        const minNS = Math.max(parseFloat(document.getElementById('sidebarNodeSizeMin').value) || 10, 1);
        const maxNS = Math.max(parseFloat(document.getElementById('sidebarNodeSizeMax').value) || 40, minNS + 1);
        const minEW = Math.max(parseFloat(document.getElementById('sidebarEdgeWidthMin').value) || 1, 0.1);
        const maxEW = Math.max(parseFloat(document.getElementById('sidebarEdgeWidthMax').value) || 6, minEW + 0.1);

        console.log(`Applying sidebar sizes: Node(${minNS}-${maxNS}), Edge(${minEW}-${maxEW})`);

        sidebarCy.batch(() => {
            const nodeWeights = sidebarCy.nodes().map(n => n.data('NodeWeight') ?? n.degree());
            const minNodeWeight = nodeWeights.length > 0 ? Math.min(...nodeWeights) : 0;
            const maxNodeWeight = nodeWeights.length > 0 ? Math.max(...nodeWeights) : 1;
            const nodeWeightRange = (maxNodeWeight - minNodeWeight) || 1;

            sidebarCy.nodes().forEach(n => {
                const weight = n.data('NodeWeight') ?? n.degree();
                let size = minNS + (maxNS - minNS) * ((weight - minNodeWeight) / nodeWeightRange);
                size = Math.max(minNS, Math.min(size, maxNS));
                n.style({ 'width': size, 'height': size });
            });

            const edgeCounts = sidebarCy.edges().map(e => e.data('processCount') || 1);
            if (edgeCounts.length > 0) {
                const minCount = Math.min(...edgeCounts);
                const maxCount = Math.max(...edgeCounts);
                const countRange = (maxCount - minCount) || 1;

                sidebarCy.edges().forEach(e => {
                    const count = e.data('processCount') || 1;
                    let width = minEW + (maxEW - minEW) * ((count - minCount) / countRange);
                    width = Math.max(minEW, Math.min(width, maxEW));

                    e.scratch('_originalWidth', width);
                    const edgeKey = `${e.data('source')}|${e.data('target')}|${e.data('Protocol')}`;
                    const nodeIsSelected = selectedNodeId && (e.source().id() === selectedNodeId || e.target().id() === selectedNodeId);
                    const edgeIsSelected = selectedSidebarEdges.has(edgeKey);

                    if (!nodeIsSelected && !edgeIsSelected) {
                         e.style('width', width);
                    } else {
                        e.style('width', SELECTED_EDGE_WIDTH);
                    }
                });
            }
        });
    }

    function updateSidebarTableForSelectedEdges() {
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const connectedEdgeData = node.connectedEdges().map(edge => ({
                    source: edge.data('source'),
                    destination: edge.data('target'),
                    protocol: edge.data('Protocol')
                }));
                 if (connectedEdgeData.length > 0) {
                    loadSidebarMultiEdgeTable(connectedEdgeData, 1);
                 } else {
                    sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p><p style="padding:10px; text-align:center; color:#6c757d;">Selected node has no connections.</p>';
                    sidebarTableContainer.style.display = 'block';
                    sidebarTablePagination.style.display = 'none';
                    sidebarSearchContainer.style.display = 'none';
                 }
                 sidebarInfoDiv.style.display = 'none';
                 return;
            } else {
                selectedNodeId = null;
            }
        }

        if (selectedSidebarEdges.size > 0) {
            const edgeList = Array.from(selectedSidebarEdges).map(key => {
                const parts = key.split('|');
                return { source: parts[0], destination: parts[1], protocol: parts[2] };
            });
            loadSidebarMultiEdgeTable(edgeList, 1);
            sidebarInfoDiv.style.display = 'none';
        }
        else {
            if (currentSidebarTableClusterId) {
                loadSidebarClusterTable(currentSidebarTableClusterId, 1);
            } else {
                sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>';
                sidebarTableContainer.style.display = 'none';
                sidebarTablePagination.style.display = 'none';
                sidebarSearchContainer.style.display = 'none';
                sidebarInfoDiv.innerHTML = 'Click nodes or edges in the graph to filter the table below, or click a heatmap cell.';
                sidebarInfoDiv.style.display = 'block';
            }
        }
    }

    function loadSidebarMultiEdgeTable(edgeList, page) {
        if (!edgeList || edgeList.length === 0) {
            console.log("Attempted to load multi-edge table with empty list. Reverting view.");
            updateSidebarTableForSelectedEdges();
            return;
        }
        sidebarTableMode = 'edges';
        console.log(`Loading sidebar table for ${edgeList.length} edges, page ${page}`);
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        sidebarSearchContainer.style.display = 'none';

        const payload = { edges: edgeList, page: page, page_size: TABLE_PAGE_SIZE };

        fetch(`${API_BASE_URL}/get_multi_edge_table`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.ok ? response.text() : Promise.reject(`Failed multi-edge table page (${response.status})`))
        .then(html => {
            showSidebarLoading(false, false);
             const tempDiv = document.createElement('div');
             tempDiv.innerHTML = html;
             const tableHtml = tempDiv.querySelector('table')?.outerHTML || '';
             const summaryHtml = tempDiv.querySelector('#table-summary')?.outerHTML || '';
             sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>' + tableHtml;
            sidebarTableContainer.style.display = 'block';
            sidebarSearchContainer.style.display = 'block';
            if (sidebarSearchInput) filterSidebarTable();

            const summaryElem = tempDiv.querySelector('#table-summary');
            if (summaryElem && summaryElem.dataset.total) {
                const total = parseInt(summaryElem.dataset.total, 10);
                 if (total > 0) {
                    sidebarTablePagination.style.display = 'block';
                    const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                    document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                    document.getElementById('sidebarCurrentPageInput').value = page;
                    document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                 } else {
                    sidebarTablePagination.style.display = 'none';
                 }
            } else {
                document.getElementById('sidebarTotalPages').textContent = '?';
                document.getElementById('sidebarCurrentPageInput').value = page;
                sidebarTablePagination.style.display = 'none';
                console.warn("No table summary total found in multi-edge sidebar table response.");
            }
            sidebarTableContainer.scrollTop = 0;
        })
        .catch(error => {
            console.error("Error fetching multi-edge sidebar table:", error);
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = `<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p><p style="color: red; padding: 10px;">Error loading table data for selected edges.</p>`;
            sidebarTableContainer.style.display = 'block';
            sidebarSearchContainer.style.display = 'none';
            sidebarTablePagination.style.display = 'none';
        });
    }

    function applyAllHeatmapHighlights() {
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill");
            if (originalColor) { cell.attr("fill", originalColor); }
        });
        clusterHighlightColors.forEach((color, clusterId) => {
            d3.selectAll('rect.cell[data-cluster="' + clusterId + '"]').attr('fill', color);
        });
    }

    function showLoading() { document.getElementById('loading-overlay').style.display = 'flex'; }
    function hideLoading() { document.getElementById('loading-overlay').style.display = 'none'; }

    function updateLegend(cyEdges = null) {
        const legendTableBody = d3.select('#legend tbody');
        // legendTableBody.html(''); // <<<< REMOVE this line from here

        let protocols = new Set();
        let calculationPromise;
        let totalCount = 0;

        if (cyEdges && cyEdges.length > 0) {
            // Sidebar Mode: Calculate percentages locally
            document.querySelector('#legend-container h3').textContent = "Sidebar Protocols";
            const counts = {};
            cyEdges.forEach(edge => {
                const protocol = (edge.data('Protocol') || 'Unknown').trim();
                if (!protocol) return;
                protocols.add(protocol);
                const count = edge.data('processCount') || 1;
                counts[protocol] = (counts[protocol] || 0) + count;
                totalCount += count;
            });
            totalCount = totalCount || 1; // Avoid division by zero
            const percentages = {};
            Object.entries(counts).forEach(([p, c]) => { percentages[p] = (c / totalCount) * 100; });
            calculationPromise = Promise.resolve(percentages); // Resolve immediately
        } else {
            // Global Mode: Fetch percentages from backend
            document.querySelector('#legend-container h3').textContent = "Protocol Edge Coloring";
            calculationPromise = fetch(`${API_BASE_URL}/protocol_percentages`)
                .then(res => res.ok ? res.json() : Promise.reject('Failed global percentages'))
                .catch(error => {
                    console.error("Error fetching global protocol percentages:", error);
                    return {}; // Return empty object on error
                });
        }

        // Common logic after getting percentages
        calculationPromise.then(percentages => {
            // **** Moved Clear Operation Here ****
            legendTableBody.html(''); // Clear the table *just before* adding new rows
            // **** End Moved Clear Operation ****

            // Populate the 'protocols' set if in global mode
            if (!cyEdges) {
                Object.keys(percentages).forEach(proto => { if(proto) protocols.add(proto); });
            }

            // Assign colors if they don't exist
            protocols.forEach(proto => {
                if (proto && !protocolColorMap[proto]) {
                    // Simple random color generation, consider a more robust palette if needed
                    protocolColorMap[proto] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                }
            });
            if (!protocolColorMap['Unknown']) {
                protocolColorMap['Unknown'] = DEFAULT_UNKNOWN_COLOR; // Ensure 'Unknown' has a color
            }

            // Sort protocols by percentage (descending)
            const sortedProtocols = Array.from(protocols).filter(p => p).sort((a, b) => (percentages[b] || 0) - (percentages[a] || 0));

            // Append rows to the legend table
            sortedProtocols.forEach(protocol => {
                const pct = percentages[protocol] || 0;
                // Format percentage text
                const pctText = (pct > 0.01 ? pct.toFixed(2) : (pct > 0 ? '<0.01' : '0.00')) + '%';
                const color = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                // Append the table row
                legendTableBody.append('tr').html(
                    `<td>${protocol}</td><td><span class="color-box" style="background-color:${color}"></span></td><td>${pctText}</td>`
                );
            });

            // Update sidebar edge colors if sidebar graph exists
            if (sidebarCy) {
                sidebarCy.edges().forEach(edge => {
                    const protocol = edge.data('Protocol') || 'Unknown';
                    const newColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                    // Only update style if edge is not currently selected (avoids overriding selection color)
                    const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                    const nodeIsSelected = selectedNodeId && (edge.source().id() === selectedNodeId || edge.target().id() === selectedNodeId);
                    const edgeIsSelected = selectedSidebarEdges.has(edgeKey);

                    if (!nodeIsSelected && !edgeIsSelected) {
                        edge.style({'line-color': newColor, 'target-arrow-color': newColor});
                    }
                    // Always update the scratchpad color for future reference
                    edge.scratch('_protocolColor', newColor);
                });
            }
        }); // End calculationPromise.then()
    } // End updateLegend function

    function updateHeatmap() { // Modified to return a Promise
        return new Promise((resolve, reject) => { // Wrap function body in a Promise
            console.log("updateHeatmap started..."); // Keep basic start log
            // showLoading(); // Consider if loading indicator is needed here or handled globally
            if (typeof metrics === 'undefined' || !Array.isArray(metrics)) {
                console.error("Global 'metrics' array is not defined correctly.");
                return reject(new Error("Global 'metrics' array is not defined correctly.")); // Reject promise
            }
            window.fullHeatmapData = {};
            window.heatmapSortOrders = {};
            window.heatmapCountSortOrder = [];

            const filterParamsBase = {
                payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
                sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
                destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
                protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
                entropyMin: document.getElementById('entropyMinFilter').value,
                entropyMax: document.getElementById('entropyMaxFilter').value,
                isLargePacketOnly: document.getElementById('isLargePacketFilter').checked,
                isSuspiciousAckOnly: document.getElementById('isSuspiciousAckFilter').checked,
                minSourceAmt: document.getElementById('minSourceAmtFilter').value,
                maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
                minDestinationAmt: document.getElementById('minDestinationAmtFilter').value,
                maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
            };
             // console.log("updateHeatmap - Base Filters:", filterParamsBase); // Optional: Keep for debugging filters

            Promise.all(metrics.map(m => {
                const filterParams = { ...filterParamsBase, metric: m.value };
                // console.log(`updateHeatmap - Fetching metric: ${m.label}`); // Optional: Keep for debugging fetch calls
                return fetch(`${API_BASE_URL}/filter_and_aggregate`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(filterParams)
                    })
                    .then(response => response.ok ? response.json() : Promise.reject(`Failed ${m.label} (${response.status})`))
                    .then(data => {
                         // console.log(`updateHeatmap - Received data for metric: ${m.label}`, data ? data.length : 'null/undefined'); // Optional: Log data length
                         return { metric: m.label, pivotData: data }
                    })
                    .catch(error => {
                        console.error(`Error fetching ${m.label}:`, error);
                        return { metric: m.label, pivotData: [], error: true }; // Continue processing other metrics
                    });
            }))
            .then(results => {
                const validResults = results.filter(r => !r.error);
                // console.log(`updateHeatmap - Got ${validResults.length} valid metric results.`); // Optional log
                const orderOption = document.getElementById("rowOrderSelect")?.value || "descending";
                const comparator = orderOption === "descending" ? (a, b) => (b.value ?? -Infinity) - (a.value ?? -Infinity) : (a, b) => (a.value ?? Infinity) - (b.value ?? Infinity); // Handle nulls in sort

                validResults.forEach(r => {
                    const metricName = r.metric;
                    if (r.pivotData && Array.isArray(r.pivotData)) {
                         if (r.pivotData.length > 0) {
                             const sortedData = [...r.pivotData].sort(comparator);
                             window.heatmapSortOrders[metricName] = sortedData.map(d => d.cluster);
                             window.fullHeatmapData[metricName] = r.pivotData; // Store original fetched data
                             if(metricName === 'Count') { window.heatmapCountSortOrder = sortedData.map(d => d.cluster); }
                         } else {
                             window.heatmapSortOrders[metricName] = [];
                             window.fullHeatmapData[metricName] = [];
                             if(metricName === 'Count') { window.heatmapCountSortOrder = []; }
                         }
                    } else {
                         console.warn(`Invalid or missing pivotData for metric: ${metricName}`);
                         window.heatmapSortOrders[metricName] = [];
                         window.fullHeatmapData[metricName] = [];
                         if(metricName === 'Count') { window.heatmapCountSortOrder = []; }
                    }
                });

                console.log("updateHeatmap completed successfully. Heatmap data fetched and stored globally.");
                resolve(validResults); // Resolve the promise when data is processed
            })
            .catch(error => {
                console.error("Major error fetching heatmap data:", error);
                window.fullHeatmapData = {}; window.heatmapSortOrders = {}; window.heatmapCountSortOrder = [];
                reject(error); // Reject the promise on error
            });
        }); // End Promise wrapper
    }

    function loadSidebarClusterTable(clusterID, page) {
        if (!clusterID) return;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = clusterID;
        console.log(`Loading sidebar table for Cluster ${clusterID}, page ${page}`);
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        sidebarSearchContainer.style.display = 'none';

        fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
            .then(response => response.ok ? response.text() : Promise.reject(`Failed cluster table page (${response.status})`))
            .then(html => {
                showSidebarLoading(false, false);
                 const tempDiv = document.createElement('div');
                 tempDiv.innerHTML = html;
                 const tableHtml = tempDiv.querySelector('table')?.outerHTML || '';
                 const summaryHtml = tempDiv.querySelector('#table-summary')?.outerHTML || '';
                 sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>' + tableHtml;
                sidebarTableContainer.style.display = 'block';
                sidebarSearchContainer.style.display = 'block';
                if (sidebarSearchInput) filterSidebarTable();


                const summaryElem = tempDiv.querySelector('#table-summary');
                if (summaryElem && summaryElem.dataset.total) {
                    const total = parseInt(summaryElem.dataset.total, 10);
                    if (total > 0) {
                        sidebarTablePagination.style.display = 'block';
                        const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                        document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                        document.getElementById('sidebarCurrentPageInput').value = page;
                        document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                    } else {
                        sidebarTablePagination.style.display = 'none';
                    }
                } else {
                    document.getElementById('sidebarTotalPages').textContent = '?';
                    document.getElementById('sidebarCurrentPageInput').value = page;
                    sidebarTablePagination.style.display = 'none';
                    console.warn("No table summary total found in sidebar cluster table response.");
                }
                sidebarTableContainer.scrollTop = 0;
            })
            .catch(error => {
                console.error("Error fetching sidebar cluster table:", error);
                showSidebarLoading(false, false);
                sidebarTableContainer.innerHTML = `<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p><p style="color: red; padding: 10px;">Error loading table data.</p>`;
                sidebarTableContainer.style.display = 'block';
                sidebarSearchContainer.style.display = 'none';
                sidebarTablePagination.style.display = 'none';
            });
       }

    sidebarGoPageBtn.addEventListener('click', function () {
        let pageInput = document.getElementById('sidebarCurrentPageInput');
        let page = parseInt(pageInput.value, 10);
        const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
        const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);

        if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
            if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                loadSidebarClusterTable(currentSidebarTableClusterId, page);
            } else if (sidebarTableMode === 'edges') {
                let edgeList = [];
                if (selectedNodeId && sidebarCy) {
                    const node = sidebarCy.getElementById(selectedNodeId);
                    if (node && node.length > 0) {
                        edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') }));
                    }
                 } else if (selectedSidebarEdges.size > 0) {
                    edgeList = Array.from(selectedSidebarEdges).map(key => {
                        const parts = key.split('|');
                        return { source: parts[0], destination: parts[1], protocol: parts[2] };
                    });
                 }
                 if (edgeList.length > 0) {
                     loadSidebarMultiEdgeTable(edgeList, page);
                 } else {
                     console.warn("Sidebar pagination clicked in edge mode, but no edges identified as selected.");
                 }
            } else {
                console.warn("Sidebar pagination clicked but current table context is unclear.");
            }
        } else {
            alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`);
        }
    });

    function loadClusterTablePage(clusterID, page) {
        currentClusterID = clusterID;
        fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
            .then(response => response.ok ? response.text() : Promise.reject(`Failed main table page (${response.status})`))
            .then(html => {
                const container = document.getElementById('table-container');
                container.innerHTML = html;
                container.style.display = 'block';
                document.getElementById('table-pagination').style.display = 'block';

                const summaryElem = container.querySelector('#table-summary');
                if (summaryElem && summaryElem.dataset.total) {
                    const total = parseInt(summaryElem.dataset.total, 10);
                    const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                    document.getElementById('totalPages').textContent = totalPages || 1;
                    document.getElementById('currentPageInput').value = page;
                    document.getElementById('currentPageInput').max = totalPages || 1;
                } else {
                    document.getElementById('totalPages').textContent = '?';
                    document.getElementById('currentPageInput').value = page;
                    console.warn("No table summary total in main table response.");
                }
                container.scrollTop = 0;
            }).catch(error => {
                console.error("Error fetching main cluster table:", error);
                document.getElementById('table-container').innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                document.getElementById('table-container').style.display = 'block';
                document.getElementById('table-pagination').style.display = 'none';
            });
       }

    function createClusterTable(clusterID) {
        loadClusterTablePage(clusterID, 1);
        document.getElementById('table-search-container').style.display = "block";
       }

    function visualizeNetwork(elements) {
        if (globalCy) { globalCy.destroy(); }
        globalCy = cytoscape({
            container: document.getElementById('cy'),
            elements: elements,
            style: CYTOSCAPE_STYLE,
            layout: { name: 'cose' }
        });
        applySizeControls();
       }

    function applySizeControls() {
        if (!globalCy) return;
        const minNS = Math.max(parseFloat(document.getElementById('nodeSizeMin').value) || 15, 1);
        const maxNS = Math.max(parseFloat(document.getElementById('nodeSizeMax').value) || 60, minNS + 1);
        const minEW = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 1, 0.1);
        const maxEW = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 10, minEW + 0.1);

        globalCy.batch(() => {
            globalCy.nodes().forEach(n => {
                const weight = n.data('NodeWeight') ?? 0.5;
                let size = minNS + (maxNS - minNS) * weight;
                size = Math.max(minNS, Math.min(size, maxNS));
                n.style({ 'width': size, 'height': size });
            });
            const counts = globalCy.edges().map(e => e.data('processCount') || 1);
            if (counts.length > 0) {
                const minCount = Math.min(...counts);
                const maxCount = Math.max(...counts);
                const countRange = (maxCount - minCount) || 1;

                globalCy.edges().forEach(e => {
                    const count = e.data('processCount') || 1;
                    let width = minEW + (maxEW - minEW) * ((count - minCount) / countRange);
                    width = Math.max(minEW, Math.min(width, maxEW));
                    e.style('width', width);
                });
            }
        });
       }

    function applyEdgeFilter() {
        if (!globalCy) return;
        const sourceFilter = document.getElementById('edgeFilterSource').value.toLowerCase();
        const destFilter = document.getElementById('edgeFilterDestination').value.toLowerCase();
        const protoFilter = document.getElementById('edgeFilterProtocol').value.toLowerCase();
        const weightFilterStr = document.getElementById('edgeFilterWeight').value;
        const countFilterStr = document.getElementById('edgeFilterProcessCount').value;

        const parseFilter = (filterStr) => {
            const match = filterStr.match(/^([<>=!]+)?\s*(\d+(\.\d+)?)$/);
            if (match) {
                const operator = match[1] || '==';
                const value = parseFloat(match[2]);
                return { operator, value };
            }
            return null;
        };
        const weightFilter = parseFilter(weightFilterStr);
        const countFilter = parseFilter(countFilterStr);

        globalCy.edges().forEach(edge => {
            let show = true;
            const data = edge.data();

            if (sourceFilter && !data.source?.toLowerCase().includes(sourceFilter)) show = false;
            if (destFilter && !data.target?.toLowerCase().includes(destFilter)) show = false;
            if (protoFilter && !data.Protocol?.toLowerCase().includes(protoFilter)) show = false;

            if (weightFilter && show) {
                const edgeWeight = data.EdgeWeight || 0;
                switch (weightFilter.operator) {
                    case '>=': if (!(edgeWeight >= weightFilter.value)) show = false; break;
                    case '>':  if (!(edgeWeight > weightFilter.value)) show = false; break;
                    case '<=': if (!(edgeWeight <= weightFilter.value)) show = false; break;
                    case '<':  if (!(edgeWeight < weightFilter.value)) show = false; break;
                    case '==': if (!(edgeWeight == weightFilter.value)) show = false; break;
                    case '!=': if (!(edgeWeight != weightFilter.value)) show = false; break;
                }
            }

            if (countFilter && show) {
                const processCount = data.processCount || 0;
                 switch (countFilter.operator) {
                    case '>=': if (!(processCount >= countFilter.value)) show = false; break;
                    case '>':  if (!(processCount > countFilter.value)) show = false; break;
                    case '<=': if (!(processCount <= countFilter.value)) show = false; break;
                    case '<':  if (!(processCount < countFilter.value)) show = false; break;
                    case '==': if (!(processCount == countFilter.value)) show = false; break;
                    case '!=': if (!(processCount != countFilter.value)) show = false; break;
                }
            }
            edge.style('display', show ? 'element' : 'none');
        });
       }

    function clearEdgeFilter() {
        document.getElementById('edgeFilterSource').value = '';
        document.getElementById('edgeFilterDestination').value = '';
        document.getElementById('edgeFilterProtocol').value = '';
        document.getElementById('edgeFilterWeight').value = '';
        document.getElementById('edgeFilterProcessCount').value = '';
        if(globalCy) { globalCy.edges().style('display', 'element'); }
       }

     function toggleSidebarFullscreen() {
        if (!document.fullscreenEnabled) {
            alert("Fullscreen mode is not supported by your browser.");
            return;
        }

        if (!document.fullscreenElement && !isSidebarFullscreen) {
            // Enter fullscreen
            sidebar.requestFullscreen().then(() => {
                sidebar.classList.add('fullscreen');
                legendContainer.classList.add('fullscreen-active'); // Show legend
                document.body.classList.add('sidebar-fullscreen');
                isSidebarFullscreen = true;
                sidebarFullscreenBtn.innerHTML = '&#x274C;'; // Exit icon
                sidebarFullscreenBtn.title = "Exit Sidebar Fullscreen";
                console.log("Entered sidebar fullscreen.");
                if (sidebarCy) {
                    setTimeout(() => {
                         sidebarCy.resize();
                         // Recenter graph on entering fullscreen
                         sidebarCy.fit(null, 50); // Fit with 50px padding
                         // applySidebarLayout(); // Optional: re-run layout
                    }, 100); // Increased delay slightly
                }
            }).catch(err => {
                alert(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
                console.error("Fullscreen request failed:", err);
            });
        } else if (document.fullscreenElement === sidebar || isSidebarFullscreen) {
            // Exit fullscreen
            document.exitFullscreen().catch(err => {
                alert(`Error attempting to disable fullscreen mode: ${err.message} (${err.name})`);
                console.error("Fullscreen exit failed:", err);
                 cleanupFullscreenStyles();
            });
            // Style cleanup and recentering is handled by 'fullscreenchange'
        } else {
            console.warn("Fullscreen state mismatch detected.");
             cleanupFullscreenStyles();
        }
     }

     function cleanupFullscreenStyles() {
        sidebar.classList.remove('fullscreen');
        legendContainer.classList.remove('fullscreen-active'); // Hide legend unless sidebar is open
        document.body.classList.remove('sidebar-fullscreen');
        isSidebarFullscreen = false;
        sidebarFullscreenBtn.innerHTML = '&#x2922;';
        sidebarFullscreenBtn.title = "Toggle Sidebar Fullscreen";
        console.log("Cleaned up fullscreen styles.");

        // Restore normal sidebar state (open or closed) - this triggers resize/layout
        toggleSidebar(isSidebarOpen);

        // Recenter is handled by the fullscreenchange listener after this
     }

    document.addEventListener('DOMContentLoaded', async () => { // Add async keyword
        tooltip = d3.select("#tooltip");

        // --- Element References (Ensure these match your HTML) ---
        const fileInput = document.getElementById('fileInput');
        const downloadButton = document.getElementById('downloadButton');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        // const goPageBtn = document.getElementById('goPageBtn'); // Main table pagination (if used)
        const sidebar = document.getElementById('sidebar');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');
        const mainContainer = document.getElementById('main-container');
        const legendContainer = document.getElementById('legend-container');
        const resetSidebarBtn = document.getElementById('resetSidebarBtn');
        const sidebarTableContainer = document.getElementById('sidebar-table-container');
        const sidebarTablePagination = document.getElementById('sidebar-table-pagination');
        const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');
        const sidebarSearchContainer = document.getElementById('sidebar-table-search-container');
        const sidebarSearchInput = document.getElementById('sidebarTableSearchInput');
        const sidebarInfoDiv = document.getElementById('sidebar-info');
        const sidebarFullscreenBtn = document.getElementById('sidebarFullscreenBtn');
        const nodeSizeMin = document.getElementById('nodeSizeMin'); // Main Graph sizing (if used)
        const nodeSizeMax = document.getElementById('nodeSizeMax'); // Main Graph sizing (if used)
        const edgeWidthMin = document.getElementById('edgeWidthMin'); // Main Graph sizing (if used)
        const edgeWidthMax = document.getElementById('edgeWidthMax'); // Main Graph sizing (if used)
        const sidebarNodeSizeMin = document.getElementById('sidebarNodeSizeMin');
        const sidebarNodeSizeMax = document.getElementById('sidebarNodeSizeMax');
        const sidebarEdgeWidthMin = document.getElementById('sidebarEdgeWidthMin');
        const sidebarEdgeWidthMax = document.getElementById('sidebarEdgeWidthMax');
        // const applyEdgeFilterBtn = document.getElementById('applyEdgeFilterBtn'); // Main Graph filter (if used)
        // const clearEdgeFilterBtn = document.getElementById('clearEdgeFilterBtn'); // Main Graph filter (if used)
        // REMOVED: hideTreeBtn, showTreeBtn variable declarations
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValueSpan = document.getElementById('thresholdValue');
        const sidebarLayoutSelect = document.getElementById('sidebarLayoutSelect');
        // Add other references as needed (e.g., filter inputs)

        // --- Initial Setup Calls (Reordered and Awaited) ---
        try {
            showLoading(); // Show overall loading indicator

            // Run non-dependent updates first
            updateLegend();

            // 1. Fetch heatmap data (required by dendrogram)
            console.log("Initial load: Fetching heatmap data...");
            await updateHeatmap(); // Wait for heatmap data
            console.log("Initial load: Heatmap data fetched.");

            // 2. Fetch and render dendrogram (now uses populated window.fullHeatmapData)
            console.log("Initial load: Loading inline dendrogram...");
            await loadInlineDendrogram(); // Wait for dendrogram
            console.log("Initial load: Dendrogram loaded.");

            // 3. Fetch time info
            console.log("Initial load: Updating time info...");
            await updateTimeInfoDisplay(); // Wait for time info
            console.log("Initial load: Time info updated.");

            // Show/Hide 'Show Tree' button based on loaded data (REMOVED, as button is removed)
            // if (showTreeBtn) { ... }

        } catch (error) {
            console.error("Error during initial page load sequence:", error);
            // Display a user-friendly error message
            const dendroCard = document.getElementById('dendrogramCard');
            if(dendroCard) { // Check if card exists
                dendroCard.innerHTML = `<p style="color:red; padding: 20px;">Error loading initial data: ${error.message || 'Unknown error'}. The backend might not have previous data loaded. Please try uploading a CSV file.</p>`;
                dendroCard.style.display = 'block'; // Ensure it's visible to show error
            } else {
                alert(`Error loading initial data: ${error.message || 'Unknown error'}. Please try uploading a CSV file.`); // Fallback
            }
            // const showTreeBtn = document.getElementById('showTreeBtn'); // Removed
            // if(showTreeBtn) showTreeBtn.style.display = 'none'; // Removed
        } finally {
            hideLoading(); // Always hide loading indicator
        }

        // --- Event Listeners ---

        // File Input & Processing (Handles its own async loading sequence now)
        if(fileInput) {
            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    showLoading();
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const csvText = e.target.result;
                        // Make backend call to process
                        fetch(`${API_BASE_URL}/process_csv`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ csv_text: csvText }),
                        })
                        .then(response => { // Handle backend response first
                            if (!response.ok) {
                                return response.json().catch(() => response.text()).then(err => {
                                    let errorMsg = err.error || err || `Processing failed (${response.status})`;
                                    throw new Error(errorMsg);
                                });
                            }
                            return response.json();
                        })
                        .then(async (confirmationData) => { // If backend OK, now make this async
                            console.log('CSV processed successfully:', confirmationData.message);
                            protocolColorMap = {}; // Reset colors
                            try {
                                // Call updates in sequence using await
                                updateLegend();
                                await updateHeatmap();
                                await loadInlineDendrogram();
                                await updateTimeInfoDisplay();

                                // Reset sidebar/UI state
                                clearSidebarVisualization();
                                toggleSidebar(false);

                                // Show/Hide 'Show Tree' button logic (REMOVED)
                                // const showTreeBtn = document.getElementById('showTreeBtn');
                                // if (showTreeBtn) { ... }
                            } catch (loadError) {
                                console.error("Error loading visualizations after file processing:", loadError);
                                alert(`Error updating display after file processing: ${loadError.message}`);
                                // Potentially clear UI elements here on error too
                                const dendroCard = document.getElementById('dendrogramCard');
                                if(dendroCard) dendroCard.innerHTML = '<p style="color:red; padding: 20px;">Error updating display.</p>';
                            } finally {
                                hideLoading(); // Hide loading indicator AFTER all updates finish or fail
                            }
                        })
                        .catch(error => { // Catch errors from backend processing OR frontend updates
                            hideLoading();
                            console.error('Error processing file or updating display:', error);
                            alert(`Error: ${error.message}`);
                            // Clear relevant parts of the UI on error
                            const dendroCard = document.getElementById('dendrogramCard');
                            if(dendroCard) dendroCard.innerHTML = '<p style="color: red; text-align: center;">Could not process CSV data or update display.</p>';
                            // const showTreeBtn = document.getElementById('showTreeBtn'); // Removed
                            // if(showTreeBtn) showTreeBtn.style.display = 'none'; // Removed
                            const timeInfoSpan = document.getElementById('timeInfoSpan');
                            if(timeInfoSpan) timeInfoSpan.textContent = '';
                            updateLegend(); // Update legend (may show empty)
                            clearSidebarVisualization();
                        });
                    }; // End reader.onload
                    reader.onerror = function(e) {
                        console.error("Error reading file:", e);
                        alert("Error reading file.");
                        hideLoading();
                    };
                    reader.readAsText(file);
                }
                event.target.value = null; // Allow re-upload of the same file
            });
        } else { console.error("File input not found."); }

        // Download Button
        if(downloadButton) {
            downloadButton.addEventListener('click', function() {
                // Check if data seems loaded by checking time info (or another indicator)
                fetch(`${API_BASE_URL}/time_info`).then(res => res.ok ? res.json() : Promise.reject('No data status'))
                .then(data => {
                    if(data && !data.error && data.start_time) { // Check if data seems valid
                        window.location.href = `${API_BASE_URL}/download_csv`;
                    } else {
                        alert("No processed data available to download. Please upload a CSV file first.");
                    }
                }).catch(() => alert("Could not check data status. Please upload a CSV file first."));
            });
        } else { console.error("Download button not found."); }

        // Heatmap Filters Button
        if(applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', async () => { // make async
                showLoading();
                try {
                    console.log("Apply Filters: Updating heatmap data...");
                    await updateHeatmap(); // Fetch new data based on filters
                    console.log("Apply Filters: Redrawing dendrogram with updated data...");
                    // Re-render the dendrogram to reflect potential changes in data values/colors in its heatmap
                    if (window.lastTreeData) { // Check if tree structure exists
                        showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                    } else {
                        console.warn("Cannot redraw dendrogram heatmap after filter: Tree data not loaded.");
                        // Decide if you want to attempt loading the tree structure again
                        // await loadInlineDendrogram();
                    }
                // Re-apply highlights to tree leaves and attached heatmap cells
                highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                } catch (error) {
                    console.error("Error applying filters and updating visualizations:", error);
                    alert(`Error applying filters: ${error.message || 'Unknown error'}`);
                } finally {
                    hideLoading();
                }
            });
        } else { console.error("Apply Filters button not found."); }

        // --- Other Listeners ---

        // Sidebar Toggle
        if(sidebarToggleBtn) {
            sidebarToggleBtn.addEventListener('click', () => toggleSidebar());
        } else { console.error("Sidebar toggle button not found."); }

        // Sidebar Reset Button
        if(resetSidebarBtn) {
            resetSidebarBtn.addEventListener('click', () => {
                console.log("Reset Sidebar Button clicked.");
                clearSidebarVisualization(); // Handles clearing graph, table, highlights
                updateLegend(); // Update the legend to show global stats/colors
                toggleSidebar(false);
                resetInlineZoom();
                console.log("Sidebar reset complete via button, including tree zoom.");
            });
        } else {
            console.error("Reset Sidebar Button not found!");
        }

        // Sidebar Fullscreen Button
        if (sidebarFullscreenBtn) {
            sidebarFullscreenBtn.addEventListener('click', toggleSidebarFullscreen);
        } else { console.error("Sidebar fullscreen button not found!"); }

        // Fullscreen Change Listener
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && isSidebarFullscreen) {
                console.log("Fullscreen exited via event listener.");
                cleanupFullscreenStyles();
                // Ensure graph fits after exiting fullscreen and sidebar potentially resizing
                if (sidebarCy) { setTimeout(() => { sidebarCy.resize(); sidebarCy.fit(null, 50); }, 400); }
            } else if (document.fullscreenElement === sidebar && !isSidebarFullscreen) {
                // This case handles situations where fullscreen might be entered unexpectedly
                console.warn("Fullscreen entered via event listener - attempting state sync.");
                isSidebarFullscreen = true;
                sidebar.classList.add('fullscreen');
                legendContainer.classList.add('fullscreen-active');
                document.body.classList.add('sidebar-fullscreen');
                sidebarFullscreenBtn.innerHTML = '&#x274C;'; // Exit icon
                sidebarFullscreenBtn.title = "Exit Sidebar Fullscreen";
                if (sidebarCy) { setTimeout(() => { sidebarCy.resize(); sidebarCy.fit(null, 50); }, 100); }
            }
        });

        // Sidebar Table Row Click
        if (sidebarTableContainer) {
            sidebarTableContainer.addEventListener('click', handleSidebarTableRowClick);
        } else { console.error("Sidebar table container not found!"); }

        // Sidebar Table Search Input
        if (sidebarSearchInput) {
            sidebarSearchInput.addEventListener('input', filterSidebarTable);
        } else { console.error("Sidebar table search input not found!"); }

        // Sidebar Pagination
        if(sidebarGoPageBtn) {
            sidebarGoPageBtn.addEventListener('click', function () {
                let pageInput = document.getElementById('sidebarCurrentPageInput');
                let page = parseInt(pageInput.value, 10);
                const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
                const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);

                if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
                    if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                        loadSidebarClusterTable(currentSidebarTableClusterId, page);
                    } else if (sidebarTableMode === 'edges') {
                        let edgeList = [];
                        if (selectedNodeId && sidebarCy) { const node = sidebarCy.getElementById(selectedNodeId); if (node && node.length > 0) { edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') })); } }
                        else if (selectedSidebarEdges.size > 0) { edgeList = Array.from(selectedSidebarEdges).map(key => { const parts = key.split('|'); return { source: parts[0], destination: parts[1], protocol: parts[2] }; }); }

                        if (edgeList.length > 0) { loadSidebarMultiEdgeTable(edgeList, page); }
                        else { console.warn("Sidebar pagination clicked in edge mode, but no edges identified."); }
                    } else { console.warn("Sidebar pagination clicked but current table context is unclear."); }
                } else {
                    alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`);
                }
            });
        } else { console.error("Sidebar Go Page button not found."); }

        // Sidebar Layout Selector
        if(sidebarLayoutSelect) {
            sidebarLayoutSelect.addEventListener('change', applySidebarLayout);
        } else { console.error("Sidebar layout select not found."); }

        // Sidebar Size Controls
        if(sidebarNodeSizeMin) sidebarNodeSizeMin.addEventListener('input', applySidebarSizeControls);
        if(sidebarNodeSizeMax) sidebarNodeSizeMax.addEventListener('input', applySidebarSizeControls);
        if(sidebarEdgeWidthMin) sidebarEdgeWidthMin.addEventListener('input', applySidebarSizeControls);
        if(sidebarEdgeWidthMax) sidebarEdgeWidthMax.addEventListener('input', applySidebarSizeControls);

        // --- Dendrogram Listeners ---
        // REMOVED Event listener attachments for hideTreeBtn and showTreeBtn

        if (metricSelect) {
            metricSelect.addEventListener('change', () => {
                if (window.lastTreeData) {
                    // Redraw the dendrogram, which will use the new metric to order the heatmap leaves
                    showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                } else { console.warn("Cannot redraw dendrogram: No tree data available."); }
            });
        } else { console.error("Dendrogram sort select not found."); }

        if (reorderTreeCheckbox) {
            reorderTreeCheckbox.addEventListener('change', () => {
                // Check if tree data exists before trying to redraw
                if (window.lastTreeData) {
                    console.log(`Reorder checkbox changed to: ${reorderTreeCheckbox.checked}, redrawing dendrogram.`);
                    // Simply call showInlineDendrogram again.
                    // It will automatically read the current checkbox state and the current metric selection.
                    showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                } else {
                    console.warn("Cannot redraw dendrogram on checkbox change: No tree data available.");
                }
            });
        } else { console.error("Reorder tree checkbox not found."); }

        if (thresholdSlider && thresholdValueSpan) {
            thresholdSlider.addEventListener('input', () => {
                const percentage = parseInt(thresholdSlider.value, 10);
                thresholdValueSpan.textContent = percentage + '%';

                const svg = d3.select("#inlineDendrogramSvg");
                const svgNode = svg.node();
                if (!svgNode) return;
                const svgContent = svg.select("g");
                const root = window.lastTreeRoot;
                const treeLayoutWidth = window.currentLayoutWidth; // Get layout width used for drawing

                // --- Use stored D3 layout height ---
                const layoutHeight = window.currentD3LayoutHeight; // <<< GET STORED HEIGHT

                if (!layoutHeight || layoutHeight <= 0 || !root || svgContent.empty() || treeLayoutWidth === undefined) {
                    console.warn("Cannot update threshold bar: Missing layout data or invalid height.", { layoutHeight, rootExists: !!root, svgContentEmpty: svgContent.empty(), treeLayoutWidth });
                    svg.select("#threshold-bar").style("display", "none"); // Hide bar if data is bad
                    return;
                }
                // --- End height retrieval ---

                const thresholdLayoutY = layoutHeight * (percentage / 100); // Calculate Y based on actual layout height

                const allVisualNodes = svgContent.selectAll('.node');
                if (allVisualNodes.empty()) {
                    svg.select("#threshold-bar").style("display", "none"); return;
                }

                // Gray out nodes based on stored layout Y and thresholdLayoutY
                allVisualNodes.each(function(d) {
                    if (d && typeof d.structuralY === 'number' && isFinite(d.structuralY)) {
                        // Compare node's structural Y (relative to layoutHeight) with thresholdLayoutY
                        d3.select(this).classed('grayed-out', d.structuralY > thresholdLayoutY + 1e-6);
                    } else {
                        d3.select(this).classed('grayed-out', false);
                    }
                });

                // Update visual threshold bar position based on current zoom/pan
                const transform = d3.zoomTransform(svgNode);
                // Y position needs the global margin.top offset added before zoom transform
                const thresholdVisualY = ((thresholdLayoutY + margin.top) * transform.k) + transform.y;
                // X position still uses layoutWidth and global margin.left offset
                const barX1 = ((0 + margin.left) * transform.k) + transform.x;
                const barX2 = ((treeLayoutWidth + margin.left) * transform.k) + transform.x;

                svg.select("#threshold-bar")
                    .style("display", null)
                    .attr("y1", thresholdVisualY).attr("y2", thresholdVisualY)
                    .attr("x1", barX1).attr("x2", barX2);
            }); // End input listener
        } else { console.error("Threshold slider or value span not found."); }

        // Listeners for resolution, reset zoom, custom height buttons are handled by onclick attributes in HTML
        // Ensure the global functions reclusterAndRedraw(), resetInlineZoom(), showCustomHeightInput() exist

    }); // End DOMContentLoaded

    // --- BEGIN Dendrogram JS Functions ---
    function showInlineDendrogram(data, svgH = 400) {
        console.log(`--- Debug showInlineDendrogram (Start) ---`);

        // --- Get DOM References ---
        const containerDiv = document.getElementById("inline-dendrogram-container");
        const dendrogramCard = document.getElementById('dendrogramCard');
        const treeControls = document.getElementById('treeControls');
        const reorderCheckbox = document.getElementById('reorderTreeCheckbox'); // Checkbox for reordering tree
        const svg = d3.select("#inlineDendrogramSvg"); // Main SVG for dendrogram
        const treeInfoSpan = document.getElementById('treeInfoSpan'); // Span to display cluster count

        // --- Early exit if essential elements are missing ---
        if (!containerDiv || !dendrogramCard || !treeControls || !reorderCheckbox || !svg.node()) {
            console.error("One or more required elements (card, container, controls, checkbox, svg) not found!");
             if(dendrogramCard) dendrogramCard.style.display = 'block'; // Still show card for error message
             if(containerDiv) containerDiv.style.height = `${svgH}px`; // Set height
             svg.selectAll("*").remove(); // Clear SVG
             svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central")
                .text("Error: Cannot calculate layout - missing elements."); // Display error in SVG
             if(treeControls) treeControls.style.display = "none";
             if (treeInfoSpan) treeInfoSpan.textContent = '';
             window.lastTreeRoot = null;
            return;
        }

        // --- Make the card visible BEFORE measuring ---
        dendrogramCard.style.display = 'block';
        console.log("Set #dendrogramCard display to 'block'");

        // --- Calculate Dynamic Height using Viewport ---
        let calculatedHeight = svgH; // Start with fallback/passed value
        try {
            const viewportHeight = window.innerHeight;
            const cardRect = dendrogramCard.getBoundingClientRect();
            const cardTopOffset = cardRect.top;
            const cardStyle = window.getComputedStyle(dendrogramCard);
            const cardMarginBottom = parseFloat(cardStyle.marginBottom);
            const cardPaddingTop = parseFloat(cardStyle.paddingTop);
            const cardPaddingBottom = parseFloat(cardStyle.paddingBottom);
            const controlsHeight = treeControls.offsetHeight;
            const estimatedTopSectionHeight = 70; // Estimate for title/spacing above container
            const containerStyle = window.getComputedStyle(containerDiv);
            const containerMarginBottom = parseFloat(containerStyle.marginBottom) || 10;
            const safetyMargin = 25; // Extra space at bottom
            const spaceBelowCardTop = viewportHeight - cardTopOffset - cardMarginBottom - safetyMargin;
            const availableHeight = spaceBelowCardTop - cardPaddingTop - estimatedTopSectionHeight - containerMarginBottom - controlsHeight - cardPaddingBottom;
            calculatedHeight = Math.max(200, availableHeight); // Min height 200px
            console.log(`Dynamic Height Calculation: Available=${availableHeight.toFixed(2)}, Applied=${calculatedHeight.toFixed(2)}`);
        } catch (e) {
            console.error("Error during viewport height calculation:", e);
            calculatedHeight = svgH; // Fallback to passed value or default
        }
        currentDendrogramHeight = calculatedHeight; // Store globally
        svgH = calculatedHeight;
        console.log(`Setting containerDiv height to calculated: ${svgH}px`);
        containerDiv.style.height = `${svgH}px`;

        // --- D3 Setup & Constants ---
        svg.selectAll("*").remove(); // Clear previous drawing
        svg.append("line").attr("id", "threshold-bar") // Add threshold bar element
           .attr("stroke", "rgba(220, 53, 69, 0.7)")
           .attr("stroke-width", 2)
           .attr("stroke-dasharray", "5 3")
           .style("pointer-events", "none")
           .style("display", "none"); // Hide initially
        if (treeInfoSpan) treeInfoSpan.textContent = ''; // Clear old info

        // Constants for Styling
        const highlightStrokeWidth = 1.5; // Width for selected outline on heatmap cells
        const defaultStrokeColor = '#fff'; // Default outline color for heatmap cells
        const defaultStrokeWidth = 0.2;   // Default outline width for heatmap cells
        const anomalyOverrideColor = "orange"; // Fill color for anomalous cells

        // --- Data Validation ---
        if (!data || data.id === undefined || data.dist === undefined) {
            console.error("Invalid or empty tree data received:", data);
            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central").text("No hierarchical data available or error loading.");
            if (treeControls) treeControls.style.display = "none"; // Hide controls if no data
            if (treeInfoSpan) treeInfoSpan.textContent = '';
            window.lastTreeRoot = null; // Clear stored root
            return;
        }

        // --- Basic Setup & Layout Calculations ---
        const containerWidth = containerDiv.clientWidth || 600; // Get current width or default

        // Define smaller internal margins for D3 layout calculations (space for tree branches)
        const internalTopMargin = 15;
        const internalBottomMargin = 20;
        const dendrogramHeight = Math.max(150, svgH - internalTopMargin - internalBottomMargin);
        const height = dendrogramHeight; // Use this for d3.cluster().size() height
        window.currentD3LayoutHeight = height; // Store for threshold calculation
        console.log(`D3 Layout Height (tree vertical space): ${height.toFixed(2)}`);

        // Prepare heatmap features and dimensions
        const features = (typeof metrics !== 'undefined' && Array.isArray(metrics)) ? metrics.map(m => m.label) : [];
        const numHeatmapFeatures = features.length;
        const heatmapRowHeight = 15; // Fixed height for each heatmap row
        const heatmapSpacing = 5;   // Space between dendrogram leaves and heatmap top
        const heatmapTotalHeight = (heatmapRowHeight * numHeatmapFeatures);
        const heatmapStartY = dendrogramHeight + heatmapSpacing + margin.top; // Y position where heatmap starts
        const heatmapEndY = heatmapStartY + heatmapTotalHeight; // Y position where heatmap ends

        // --- Hierarchy and Initial Layout (Structural Y) ---
        const root = d3.hierarchy(data); // Create D3 hierarchy from input data
        const leafCount = root.leaves().length;
        if (treeInfoSpan) { treeInfoSpan.textContent = `${leafCount} Clusters`; } // Display leaf count

        // D3 cluster layout (determines initial node Y positions based on distance and X based on structure)
        const treeLayout = d3.cluster().size([1, height]); // Height controls vertical spread (Y)
        treeLayout(root); // Apply layout to the root node and descendants

        // --- Store Structural Y position ---
        root.each(node => { // Iterate through all nodes (root, internal, leaves)
            node.structuralY = node.y; // Store initial Y calculated by d3.cluster
            // Handle potential NaN/undefined Y (fallback to parent or 0)
            if (typeof node.structuralY !== 'number' || !isFinite(node.structuralY)) {
                node.structuralY = (node.parent && typeof node.parent.structuralY === 'number' && isFinite(node.parent.structuralY)) ? node.parent.structuralY : 0;
            }
            node.finalY = node.structuralY; // Final Y position used for drawing is always the structural Y
        });

        // --- Calculate and Store Structural X positions (Based on initial D3 layout order) ---
        const structuralLeaves = [...root.leaves()].sort((a, b) => a.x - b.x); // Sort leaves by initial layout X (0-1 range)
        const structuralClusterIds = structuralLeaves
            .map(leaf => (leaf.data && leaf.data.cluster_id !== undefined && leaf.data.cluster_id !== null) ? String(leaf.data.cluster_id) : null)
            .filter(id => id !== null); // Get cluster IDs in the initial structural order

        const minLeafSpacingStructural = 20; // Minimum horizontal space per leaf for structural layout
        const requiredWidthStructural = structuralClusterIds.length * minLeafSpacingStructural;
        const widthAvailableInContainer = Math.max(300, containerWidth - margin.left - margin.right);
        // Determine the width needed for the structural layout (at least required or available width)
        const structuralLayoutWidth = Math.max(requiredWidthStructural, widthAvailableInContainer);

        // Create an X scale based on the structural order and calculated width
        const structuralXScale = d3.scaleBand()
            .domain(structuralClusterIds) // Domain is cluster IDs in structural order
            .range([margin.left, margin.left + structuralLayoutWidth]) // Range covers the calculated width + left margin
            .paddingInner(0); // No padding between leaf positions

        // Calculate structuralX for all nodes bottom-up (leaves first, then parents)
        root.eachAfter(node => {
            if (node.children && node.children.length > 0) { // Internal node
                // Get structuralX from children (which were calculated in previous steps of eachAfter)
                const validChildrenX = node.children
                    .map(c => c.structuralX)
                    .filter(x => typeof x === 'number' && isFinite(x) && x >= 0);
                if (validChildrenX.length > 0) {
                    node.structuralX = d3.mean(validChildrenX); // Position is average of children's structuralX
                } else { // Fallback if children somehow have no valid structuralX
                    node.structuralX = (node.parent && typeof node.parent.structuralX === 'number' && isFinite(node.parent.structuralX)) ? node.parent.structuralX : (structuralLayoutWidth / 2 + margin.left);
                }
            } else { // Leaf node
                const clusterId = (node.data && node.data.cluster_id !== undefined && node.data.cluster_id !== null) ? String(node.data.cluster_id) : null;
                if (clusterId && structuralClusterIds.includes(clusterId)) {
                     const bandStart = structuralXScale(clusterId); // Find position in the structural scale
                     if (bandStart !== undefined && typeof bandStart === 'number') {
                        node.structuralX = bandStart + structuralXScale.bandwidth() / 2; // Center in the band
                     } else { node.structuralX = -1000; } // Should not happen if IDs are consistent
                } else { node.structuralX = -1000; } // Leaf lacks a valid cluster ID
            }
            // Ensure structuralX is a valid number, fallback to center if calculation failed
            if (typeof node.structuralX !== 'number' || !isFinite(node.structuralX)) {
                 node.structuralX = (structuralLayoutWidth / 2 + margin.left); // Fallback
                 console.warn("Fell back calculating structuralX for node", node.data?.id || node.data?.cluster_id);
            }
        });
        console.log("Calculated and stored structural X positions.");

        // --- Determine Heatmap Order (Always sort leaves by selected metric for heatmap drawing) ---
        let metricSortedLeaves = [...root.leaves()]; // Start with all leaves for sorting
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        const selectedMetric = metricSelect ? metricSelect.value : 'Default'; // Get the VALUE (e.g., 'Count')
        console.log(`Sorting heatmap leaves by metric: ${selectedMetric}`);

        // Apply sorting based on the selected metric using global heatmapSortOrders data
        if (selectedMetric !== 'Default' && window.heatmapSortOrders && window.heatmapSortOrders[selectedMetric]) {
            const currentSortOrder = window.heatmapSortOrders[selectedMetric]; // Get the ordered array of cluster IDs
            if (currentSortOrder && Array.isArray(currentSortOrder) && currentSortOrder.length > 0) {
                const orderMap = new Map(currentSortOrder.map((id, index) => [String(id), index])); // Map clusterID -> sortIndex
                metricSortedLeaves.sort((a, b) => { // Custom sort function
                    const aClusterId = a.data && a.data.cluster_id !== undefined ? String(a.data.cluster_id).trim() : null;
                    const bClusterId = b.data && b.data.cluster_id !== undefined ? String(b.data.cluster_id).trim() : null;
                    // Consistent handling of nulls/missing IDs (place them last)
                    if (aClusterId === null && bClusterId === null) return 0; // Keep relative order if both null
                    if (aClusterId === null) return 1; // Nulls after non-nulls
                    if (bClusterId === null) return -1; // Non-nulls before nulls
                    // Lookup sort index from map
                    const aIndex = orderMap.get(aClusterId);
                    const bIndex = orderMap.get(bClusterId);
                    // Handle cases where cluster might not be in the sort order (e.g., filtered out, new cluster)
                    if (aIndex !== undefined && bIndex !== undefined) return aIndex - bIndex; // Both found, sort by index
                    if (aIndex !== undefined) return -1; // Place found cluster before not-found cluster
                    if (bIndex !== undefined) return 1;  // Place not-found cluster after found cluster
                    return 0; // Keep relative order if neither cluster is found in sort order
                });
                 console.log("Applied metric sort order to heatmap leaves.");
            } else {
                // Fallback to structural sort if metric data is missing for some reason
                metricSortedLeaves.sort((a, b) => a.x - b.x);
                console.log("Metric sort order not found or empty, using structural order for heatmap.");
            }
        } else {
            // Use default structural sort if "Default (Structure)" is selected
            metricSortedLeaves.sort((a, b) => a.x - b.x);
            console.log("Using default structural order for heatmap.");
        }
        // Get cluster IDs based on the final metric sort order - this defines the heatmap column order
        const heatmapClusterIds = metricSortedLeaves
             .map(leaf => (leaf.data && leaf.data.cluster_id !== undefined && leaf.data.cluster_id !== null) ? String(leaf.data.cluster_id) : null)
             .filter(id => id !== null);

        // --- Checkbox State & Determine Final X Positions for TREE drawing ---
        const reorderTree = reorderCheckbox.checked; // Check the current state of the checkbox
        console.log(`Reorder Tree Structure checkbox checked: ${reorderTree}`);

        let finalLayoutWidth; // This will be the width used for the final tree drawing and the heatmap

        if (reorderTree) {
            // --- Mode 1: Reorder Tree based on Metric ---
            console.log("Reordering tree structure based on metric.");
            const minLeafSpacingMetric = 20; // Minimum horizontal space per leaf when reordering
            const requiredWidthMetric = heatmapClusterIds.length * minLeafSpacingMetric;
            finalLayoutWidth = Math.max(requiredWidthMetric, widthAvailableInContainer); // Use metric-based width

            // Create an X scale based on the metric-sorted leaves for positioning the *tree nodes*
            const metricXScale = d3.scaleBand()
                .domain(heatmapClusterIds) // Domain uses metric-sorted IDs
                .range([margin.left, margin.left + finalLayoutWidth])
                .paddingInner(0);

            // Calculate finalX for all tree nodes bottom-up based on metric sort order
            root.eachAfter(node => {
                 if (node.children && node.children.length > 0) { // Internal node
                     const validChildrenX = node.children
                         .map(c => c.finalX) // Use finalX of children (already calculated in this eachAfter loop)
                         .filter(x => typeof x === 'number' && isFinite(x) && x >= 0);
                     if (validChildrenX.length > 0) {
                         node.finalX = d3.mean(validChildrenX); // Position is average of children's finalX
                     } else { node.finalX = (finalLayoutWidth / 2 + margin.left); } // Fallback to center
                 } else { // Leaf node
                     const clusterId = (node.data && node.data.cluster_id !== undefined && node.data.cluster_id !== null) ? String(node.data.cluster_id) : null;
                     if (clusterId && heatmapClusterIds.includes(clusterId)) {
                         const bandStart = metricXScale(clusterId); // Use metric scale
                         if (bandStart !== undefined && typeof bandStart === 'number') {
                            node.finalX = bandStart + metricXScale.bandwidth() / 2; // Center in band
                         } else { node.finalX = -1000; } // Error: ID not found in scale
                     } else { node.finalX = -1000; } // No valid ID
                 }
                 // Ensure finalX is a valid number after calculation
                 if (typeof node.finalX !== 'number' || !isFinite(node.finalX)) {
                      node.finalX = (finalLayoutWidth / 2 + margin.left); // Fallback to center
                 }
            });
        } else {
            // --- Mode 2: Keep Original Tree Structure ---
            console.log("Keeping original tree structure, using structural X positions.");
            finalLayoutWidth = structuralLayoutWidth; // Use the width calculated earlier based on structure
            // Assign the pre-calculated structuralX to finalX for drawing
            root.each(node => {
                node.finalX = node.structuralX;
                 // Ensure finalX is valid after assignment (in case structuralX was invalid)
                 if (typeof node.finalX !== 'number' || !isFinite(node.finalX)) {
                     node.finalX = (finalLayoutWidth / 2 + margin.left); // Fallback
                 }
            });
        }
        // Store the width actually used for drawing (either structural or metric-based)
        window.currentLayoutWidth = finalLayoutWidth;

        // --- Define Scales for Drawing ---
        const heatmapContentWidth = finalLayoutWidth; // Heatmap uses the same width as the final tree layout

        // Scale specifically for positioning HEATMAP CELLS horizontally based on the METRIC order
        // This scale is independent of whether the tree itself was reordered
        const heatmapXScale = d3.scaleBand()
            .domain(heatmapClusterIds) // Domain based on metric-sorted leaves
            .range([margin.left, margin.left + heatmapContentWidth]) // Range based on the final layout width
            .paddingInner(0); // No padding between heatmap cells

        // Store the processed root node globally for threshold calculations etc.
        window.lastTreeRoot = root;

        // --- Define SVG ViewBox ---
        // Calculate the total height needed for the SVG content (tree + heatmap + margins)
        const actualHeatmapHeight = (numHeatmapFeatures > 0 && heatmapClusterIds.length > 0 && features.length > 0) ? heatmapTotalHeight + heatmapSpacing : 0;
        const totalNeededHeight = height + actualHeatmapHeight + margin.top + margin.bottom; // height is dendrogramHeight
        const viewBoxHeight = totalNeededHeight;
        // Calculate the total width needed for the SVG content (layout width + margins)
        const viewBoxWidth = finalLayoutWidth + margin.left + margin.right;
        // Set the viewBox attribute to make the SVG scale responsively
        svg.attr("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`)
           .attr("preserveAspectRatio", "xMidYMid meet"); // Scale content to fit, center, preserving aspect ratio

        // --- Define Main Content Group ---
        const svgContent = svg.append("g"); // Group for all visual elements (links, nodes, heatmap)

        // --- Draw Links (Using finalX, finalY) ---
        svgContent.selectAll(".link")
            .data(root.links()) // Get link data (source -> target pairs)
            .join("path") // Create/update paths for links
            .attr("class", "link")
            .attr("d", d => { // Calculate path data (d attribute) for elbow connectors
                const sourceX = d.source.finalX;
                const sourceY = d.source.finalY + margin.top; // Apply global top margin offset for absolute Y
                const targetX = d.target.finalX;
                const targetY = d.target.finalY + margin.top; // Apply global top margin offset
                // Ensure coordinates are valid before drawing
                if ([sourceX, sourceY, targetX, targetY].every(coord => typeof coord === 'number' && isFinite(coord))) {
                    const midY = sourceY + (targetY - sourceY) / 2; // Vertical midpoint
                    // Path: Move to Source -> Vertical line to Midpoint -> Horizontal line to Target X -> Vertical line to Target Y
                    return `M${sourceX},${sourceY} L${sourceX},${midY} L${targetX},${midY} L${targetX},${targetY}`;
                } return ""; // Return empty path if coordinates invalid
            })
            .attr("fill", "none") // Links are not filled
            .attr("stroke", "#ccc") // Light grey color
            .attr("stroke-width", 1.5);

        // --- Draw Nodes (Using finalX, finalY) ---
        const node = svgContent.selectAll(".node")
            // Bind data to descendants, filtering out any with invalid calculated positions
            .data(root.descendants().filter(d => typeof d.finalX === 'number' && isFinite(d.finalX) && typeof d.finalY === 'number' && isFinite(d.finalY)))
            .join("g") // Create/update groups for nodes
            .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf")) // Add classes for styling
            .attr("transform", d => `translate(${d.finalX},${d.finalY + margin.top})`); // Position node group

        // Append circles to each node group
        node.append("circle")
            .attr("r", 4) // Circle radius
            .attr("fill", d => d.children ? "#555" : "#999"); // Darker for internal, lighter for leaves

        // --- Tree-Attached Heatmap Drawing ---
        if (features.length > 0 && heatmapClusterIds.length > 0 && window.fullHeatmapData && Object.keys(window.fullHeatmapData).length > 0) {
            // --- Prepare data lookup map (clusterId -> {metric: value, metric_anomaly: 'normal'/'anomaly'}) ---
            const clusterDataLookup = new Map();
            features.forEach(metricLabel => {
                 const metricData = window.fullHeatmapData[metricLabel] || [];
                 const currentMetricData = Array.isArray(metricData) ? metricData : [];
                 currentMetricData.forEach(item => {
                     if (item && item.cluster !== undefined && item.value !== undefined) {
                         const clusterId = String(item.cluster);
                         if (!clusterDataLookup.has(clusterId)) { clusterDataLookup.set(clusterId, {}); }
                         const numericValue = parseFloat(item.value);
                         clusterDataLookup.get(clusterId)[metricLabel] = !isNaN(numericValue) ? numericValue : null;
                         clusterDataLookup.get(clusterId)[`${metricLabel}_anomaly`] = item.clusterAnomaly || 'normal';
                     }
                 });
             });
             // Create a flat array of objects for D3 data binding (one object per cell)
             const heatmapFeatureData = [];
             heatmapClusterIds.forEach(clusterId => { // Iterate through clusters in the METRIC order
                 const clusterMetrics = clusterDataLookup.get(clusterId) || {};
                 features.forEach(metricLabel => { // For each feature (row)
                     heatmapFeatureData.push({
                         cluster_id: clusterId,
                         feature: metricLabel,
                         value: clusterMetrics[metricLabel] ?? null,
                         anomaly: clusterMetrics[`${metricLabel}_anomaly`] || 'normal'
                     });
                 });
             });

            // --- Color scales for heatmap cells ---
            const colorScales = {};
            const minIntensity = 0.05; // Minimum color intensity
            const customBluesInterpolator = t => d3.interpolateBlues(minIntensity + Math.max(0, Math.min(1, t)) * (1 - minIntensity));
             features.forEach(metricLabel => { // Create a scale for each metric (row)
                 const metricData = window.fullHeatmapData[metricLabel] || [];
                 const currentMetricData = Array.isArray(metricData) ? metricData : [];
                 const numericValues = currentMetricData.map(d => parseFloat(d.value)).filter(v => !isNaN(v) && v !== null);
                 let scale;
                 if (numericValues.length > 0) {
                     const rowMin = d3.min(numericValues);
                     const rowMax = d3.max(numericValues);
                     const domain = [Math.min(0, rowMin), Math.max(1e-9, rowMax)];
                     scale = d3.scaleSequential(customBluesInterpolator).domain(domain).clamp(true);
                 } else {
                     scale = d3.scaleSequential(d3.interpolateGreys).domain([0, 1]); // Fallback grey
                 }
                 colorScales[metricLabel] = scale; // Store the scale
             });

            // --- Feature (Y) scale for heatmap rows ---
            const featureScale = d3.scaleBand()
                .domain(features) // Order of features array determines Y order
                .range([heatmapStartY, heatmapEndY]) // Use calculated start/end Y
                .paddingInner(0.1); // Small padding between rows

            // --- Draw Heatmap Cells ---
            if (heatmapXScale.bandwidth() > 0 && featureScale.bandwidth() > 0) { // Check for valid scales
                const cellSelection = svgContent.selectAll(".heatmap-cell")
                    .data(heatmapFeatureData, d => `${d.cluster_id}-${d.feature}`) // Key function
                    .join("rect") // Create/update rectangles
                    .attr("class", "heatmap-cell")
                    .attr("x", d => { // X position based on METRIC scale
                        const xVal = heatmapXScale(d.cluster_id);
                        return (typeof xVal === 'number' && isFinite(xVal)) ? xVal : -1000;
                    })
                    .attr("width", heatmapXScale.bandwidth()) // Width based on METRIC scale
                    .attr("y", d => { // Y position based on feature scale
                        const yVal = featureScale(d.feature);
                        return (typeof yVal === 'number' && isFinite(yVal)) ? yVal : -1000;
                    })
                    .attr("height", featureScale.bandwidth()); // Height based on feature scale

                 // --- Set original fill data AND initial visual state (fill/stroke) ---
                 cellSelection.filter(function() { // Filter out cells with invalid positions
                        const x = +d3.select(this).attr("x");
                        const y = +d3.select(this).attr("y");
                        return x >= 0 && y >= 0;
                    })
                    .each(function(d) { // Use .each to set attributes based on data and highlight state
                        const cell = d3.select(this);
                        const scale = colorScales[d.feature];
                        let originalFill;

                        // 1. Determine and store the original fill color based on value/anomaly
                        if (d.anomaly === 'anomaly') {
                            originalFill = anomalyOverrideColor;
                        } else if (scale && d.value !== null && typeof d.value === 'number' && isFinite(d.value)) {
                            originalFill = scale(d.value); // Use color scale
                        } else {
                            originalFill = "#eee"; // Default grey for null/invalid
                        }
                        cell.attr("data-original-fill", originalFill); // Store it on the element

                        // 2. Set initial visual attributes based on current highlight status
                        const clusterIdStr = String(d.cluster_id);
                        const highlightColor = clusterHighlightColors.get(clusterIdStr); // Is this cluster selected?

                        // Apply styles: Fill is always original, Stroke depends on highlight
                        cell.attr("fill", originalFill)
                            .style("stroke", highlightColor ? highlightColor : defaultStrokeColor) // Use highlight color or default
                            .style("stroke-width", highlightColor ? highlightStrokeWidth : defaultStrokeWidth); // Use highlight width or default
                    })
                    .style("cursor", "pointer") // Indicate cells are clickable
                    // --- Event Handlers for Heatmap Cells ---
                    .on("click", function(event, d) {
                        event.stopPropagation(); // Prevent triggering underlying SVG events
                        const clickedClusterID = String(d.cluster_id);

                        // Select all cells belonging to this cluster
                        const cellsForCluster = svgContent.selectAll('.heatmap-cell')
                            .filter(cell_d => String(cell_d.cluster_id) === clickedClusterID);

                        // --- Bring selected/deselected cells to front ---
                        // Raise the elements to ensure their stroke draws on top
                        if (!cellsForCluster.empty()) {
                        cellsForCluster.raise();
                        }
                        // --- End Bring to front ---

                        // Toggle highlight state
                        if (clusterHighlightColors.has(clickedClusterID)) {
                            // --- DESELECT: Remove Outline ---
                            clusterHighlightColors.delete(clickedClusterID); // Remove from map
                            // Animate stroke back to default AFTER raising (optional, raise is instant)
                            cellsForCluster.transition().duration(100)
                                .style('stroke', defaultStrokeColor)       // Reset stroke color
                                .style('stroke-width', defaultStrokeWidth); // Reset stroke width
                            console.log(`Removed highlight outline for Cluster ${clickedClusterID}`);

                        } else {
                            // --- SELECT: Add Outline ---
                            const targetHighlightColor = generateUniqueHighlightColor();
                            clusterHighlightColors.set(clickedClusterID, targetHighlightColor); // Add to map
                            visualizeClusterInSidebar(clickedClusterID, targetHighlightColor); // Trigger sidebar update

                            // Animate stroke to highlight state AFTER raising
                            cellsForCluster.transition().duration(100)
                                .style('stroke', targetHighlightColor)     // Set highlight stroke color
                                .style('stroke-width', highlightStrokeWidth); // Set highlight stroke width
                            console.log(`Applied highlight outline ${targetHighlightColor} to Cluster ${clickedClusterID}`);
                        }
                        // Update the highlights on the tree leaf circles (still uses fill)
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                    })
                    .on("mouseover", function(event, d) { // Tooltip & temporary border highlight on hover
                        // Store current stroke state before applying hover style
                        const currentStroke = d3.select(this).style('stroke');
                        const currentStrokeWidth = d3.select(this).style('stroke-width');
                        d3.select(this).attr('data-hover-temp-stroke', currentStroke);
                        d3.select(this).attr('data-hover-temp-stroke-width', currentStrokeWidth);

                        // Apply hover style (thicker black border)
                        d3.select(this).style("stroke", "black").style("stroke-width", 1.5);

                        // Show tooltip
                        const tooltip = d3.select("#tooltip");
                        const metricLabel = d.feature;
                        const clusterId = d.cluster_id;
                        const value = d.value;
                        const anomalyStatus = d.anomaly === 'anomaly' ? 'Anomaly Detected' : 'Normal';
                        let displayValue = 'N/A'; // Format value for display
                        if (value !== null && typeof value === 'number' && isFinite(value)) {
                            if (metricLabel.includes('%')) { displayValue = `${value.toFixed(2)}%`; }
                            else if (Number.isInteger(value)) { displayValue = value.toLocaleString(); }
                            else { const valueStr = String(value); displayValue = (valueStr.includes('e') || valueStr.includes('E')) ? value.toExponential(2) : value.toFixed(3); }
                        }
                        tooltip.style("display", "block")
                            .html(`Cluster: ${clusterId}<br>Metric: ${metricLabel}<br>Value: ${displayValue}<br>Status: ${anomalyStatus}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 15) + "px");
                    })
                    .on("mouseout", function(event, d) { // Hide tooltip and restore border intelligently
                        d3.select("#tooltip").style("display", "none");

                        const cell = d3.select(this);
                        const clusterIdStr = String(d.cluster_id); // Get cluster ID of the cell being moused out
                        const defaultStrokeColor = '#fff'; // Make sure this matches your definition
                        const defaultStrokeWidth = 0.2;   // Make sure this matches your definition
                        const highlightStrokeWidth = 1.5; // Make sure this matches your definition

                        // Determine the correct stroke width and color to restore to:
                        let targetStrokeWidth;
                        let targetStrokeColor;

                        if (clusterHighlightColors.has(clusterIdStr)) {
                            // If this cluster IS currently selected, restore/keep the highlight state
                            targetStrokeWidth = highlightStrokeWidth;
                            targetStrokeColor = clusterHighlightColors.get(clusterIdStr); // Use the specific highlight color
                        } else {
                            // If this cluster is NOT selected, restore to default state
                            targetStrokeWidth = defaultStrokeWidth;
                            targetStrokeColor = defaultStrokeColor;
                        }

                        // Restore the determined stroke width and color
                        // Using transition can make it smoother, but direct style ensures it applies
                        cell.style("stroke", targetStrokeColor)
                            .style("stroke-width", targetStrokeWidth);

                        // It's good practice to clear temporary attributes if you were using them
                        // cell.attr('data-hover-temp-stroke', null);
                        // cell.attr('data-hover-temp-stroke-width', null);
                    });

                // --- Draw Heatmap Feature Labels (Y-axis) & Highlight Selected Metric ---
                svgContent.selectAll(".heatmap-feature-label")
                   .data(features) // Bind feature names
                   .join("text") // Create/update text elements
                   .attr("class", "heatmap-feature-label")
                   .attr("x", margin.left - 5) // Position left of heatmap
                   .attr("y", d => { // Y position from feature scale
                       const yVal = featureScale(d);
                       return (typeof yVal === 'number' && isFinite(yVal)) ? yVal + featureScale.bandwidth() / 2 : -1000; // Center in band
                   })
                   .attr("text-anchor", "end") // Right-align text
                   .attr("dominant-baseline", "middle") // Vertically center
                   .attr("font-size", "9px")
                   .text(d => d); // Set text content

                // Highlight the label matching the selected sort metric
                const metricSelectElement = document.getElementById('dendrogramSortMetricSelect');
                const selectedMetricValue = metricSelectElement ? metricSelectElement.value : 'Default'; // Get selected VALUE
                const selectedMetricLabel = metricSelectElement ? metricSelectElement.options[metricSelectElement.selectedIndex].text : null; // Get selected TEXT

                const featureLabels = svgContent.selectAll(".heatmap-feature-label"); // Select all labels

                // Reset all labels to default style first
                featureLabels.style("fill", "#333").style("font-weight", "normal");

                // Apply highlight style if a metric (not 'Default') is selected
                if (selectedMetricValue !== 'Default' && selectedMetricLabel) {
                    featureLabels.filter(function(d) { return d === selectedMetricLabel; }) // Find matching label text
                    .style("fill", "#4299e1") // Blue color
                    .style("font-weight", "bold"); // Bold
                    console.log(`Highlighting metric label: ${selectedMetricLabel}`);
                } else {
                    console.log("Metric selection is 'Default' or label not found, no highlight applied.");
                }
                // --- End Highlight Code ---

            } else { // Handle case where scales have invalid bandwidth
                console.error("Heatmap scales have zero or negative bandwidth! Cannot draw heatmap cells.");
                 svgContent.append("text").attr("x", margin.left).attr("y", heatmapStartY + 20)
                    .text("Error: Cannot draw heatmap cells due to scale issue.")
                    .attr("fill", "red").attr("font-size", "10px");
            }
        } else { // Handle case where no heatmap data is available
             console.log("Skipping heatmap drawing and label highlighting: No features or cluster data available.");
        }


        // --- Zoom and Pan Calculation & Application ---
        let dx = 0, dy = 0, initialScale = 1; // Initialize transform variables
        try { // Calculate initial transform to center and fit the content
             const bounds = svgContent.node()?.getBBox(); // Get bounding box of the content group
             if (bounds && bounds.width > 0 && bounds.height > 0) { // Check if bounds are valid
                 const scaleX = viewBoxWidth / bounds.width;
                 const scaleY = viewBoxHeight / bounds.height;
                 initialScale = Math.min(scaleX, scaleY) * 0.95; // Fit with padding
                 initialScale = Math.max(0.05, Math.min(initialScale, 5)); // Clamp scale
                 dx = (viewBoxWidth / 2) - ((bounds.x + bounds.width / 2) * initialScale); // Center X
                 dy = (viewBoxHeight / 2) - ((bounds.y + bounds.height / 2) * initialScale); // Center Y
                 // Validate results
                 if (!isFinite(dx)) dx = margin.left;
                 if (!isFinite(dy)) dy = margin.top;
                 if (!isFinite(initialScale) || initialScale <= 0) initialScale = 1;
             } else { // Fallback if BBox invalid
                 console.warn("Could not get valid BBox for zoom calculation, using defaults.");
                 dx = margin.left; dy = margin.top; initialScale = 1;
             }
        } catch(e) { // Catch any errors during BBox calculation
             console.error("Error calculating initial zoom transform:", e);
             dx = margin.left; dy = margin.top; initialScale = 1; // Fallback
        }

        // Store the calculated initial transform globally
        initialTreeTransform = d3.zoomIdentity.translate(dx, dy).scale(initialScale);
        console.log(`Initial Transform: translate(${dx.toFixed(2)}, ${dy.toFixed(2)}) scale(${initialScale.toFixed(2)})`);

        // --- Apply Zoom Behavior ---
        const zoomBehavior = d3.zoom()
            .scaleExtent([0.05, 10]) // Set min/max zoom levels
            .on("zoom.main", (event) => { // Define zoom event handler
                svgContent.attr("transform", event.transform); // Apply transform to the content group
                // Update threshold bar position dynamically on zoom/pan
                const thresholdSliderElem = document.getElementById('thresholdSlider');
                if (thresholdSliderElem && window.lastTreeRoot && svgContent.node()) {
                    // Use rAF for smoother updates during interactive zoom/pan
                    requestAnimationFrame(() => {
                         thresholdSliderElem.dispatchEvent(new Event('input')); // Trigger recalculation
                    });
                } else {
                    d3.select("#threshold-bar").style("display", "none"); // Hide bar if needed data missing
                }
            });

        window.inlineZoom = zoomBehavior; // Store behavior globally for reset button

        // Apply zoom behavior to the main SVG element
        svg.call(zoomBehavior)
           .call(zoomBehavior.transform, initialTreeTransform) // Set the initial view
           .on("dblclick.zoom", null); // Disable default double-click zoom reset

        // --- Final Steps ---
        if (treeControls) { treeControls.style.display = "flex"; } // Show controls now tree is drawn
        window.lastTreeData = data; // Store the raw data used for this drawing

        // Store cluster count/hash for recluster comparison (optional)
        try { previousClusterCount = leafCount; previousClusterHash = JSON.stringify(data); } catch(e) { console.warn("Could not stringify data for hash comparison."); }

        // Apply initial highlights to leaves (fill) and heatmap (stroke) based on current selections
        highlightTreeClusters(new Set(clusterHighlightColors.keys()));

        // Trigger initial threshold calculation and bar drawing after rendering
        const initialSlider = document.getElementById('thresholdSlider');
        if (initialSlider && window.lastTreeRoot && svgContent.node()) {
            requestAnimationFrame(() => { // Ensure rendering is complete before triggering
                initialSlider.dispatchEvent(new Event('input'));
            });
        } else {
             d3.select("#threshold-bar").style("display", "none"); // Hide bar if cannot calculate
        }

        console.log(`--- Debug showInlineDendrogram (End) ---`);

    } // --- End of showInlineDendrogram ---

    function highlightTreeClusters(selectedClusterIds = new Set()) {
        const svgContent = d3.select("#inlineDendrogramSvg g");
        if (svgContent.empty()) {
            return; // Tree not rendered yet
        }

        const leafNodes = svgContent.selectAll(".node--leaf"); // Select the group containing circle and text
        const leafCircles = leafNodes.select("circle");
        const leafTexts = leafNodes.select("text");
        const defaultTextColor = "#333"; // Default text color

        // Reset all leaves first
        leafCircles.classed("highlighted", false)
                  .transition().duration(150)
                  .attr("r", 4) // Default radius
                  .style("fill", "#999") // Default leaf circle color
                  .style("stroke", "none");

        leafTexts.transition().duration(150)
                .style("fill", defaultTextColor) // Reset text color
                .style("font-weight", "normal"); // Reset font weight

        // Apply highlights based on the provided set and stored colors
        if (selectedClusterIds.size > 0) {
            selectedClusterIds.forEach(clusterId => {
                const stringClusterId = String(clusterId); // Ensure string comparison
                // Get the correct highlight color from the global map
                const highlightColor = clusterHighlightColors.get(stringClusterId);

                if (highlightColor) { // Only highlight if found in the map
                    // Find the matching leaf node(s)
                    const matchedNodes = leafNodes.filter(function(d) {
                        return d && d.data && String(d.data.cluster_id) === stringClusterId;
                    });

                    // Highlight the circle
                    matchedNodes.select("circle")
                        .classed("highlighted", true)
                        .transition().duration(150)
                        .attr("r", 6) // Highlighted radius
                        .style("fill", highlightColor) // Use the specific highlight color from map
                        .style("stroke", "none");

                    // --- Modify Text Color ---
                    try {
                        // Parse the highlight color (assuming HSL format like "hsl(H, S%, L%)")
                        let color = d3.hsl(highlightColor);

                        // Lower saturation (e.g., reduce by 40%, ensure it's between 0 and 1)
                        color.s = Math.max(0, Math.min(1, color.s * 0.6));

                        // Optional: Slightly increase lightness for readability, especially if saturation is low
                        if (color.s < 0.3) {
                            color.l = Math.min(1, color.l + 0.1);
                        }
                        // Ensure lightness isn't too high (avoid white on white)
                        color.l = Math.min(0.85, color.l);

                        const textColor = color.toString(); // Convert back to string

                        // Apply the modified color to the text
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", textColor)
                            .style("font-weight", "bold"); // Make text bold for emphasis

                    } catch (e) {
                        console.error("Could not parse highlight color for text:", highlightColor, e);
                        // Fallback: Apply a default highlight color to text if parsing fails
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", "#d95f02") // Fallback color (dark orange)
                            .style("font-weight", "bold");
                    }
                    // --- End Text Color Modification ---

                } else {
                    console.warn(`Highlight color not found in map for cluster ${stringClusterId}`);
                }
            });
        }
    }

    function hideDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'none';
        showButton.style.display = 'inline-block'; // Show the 'Show Tree' button
        console.log("Dendrogram hidden.");
    }

    function showDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'block';    // Show the card
        showButton.style.display = 'none'; // Hide the 'Show Tree' button

        // Optional: Reload or redraw if needed when shown
        if (!window.lastTreeData) {
            console.log("No tree data, loading...");
            loadInlineDendrogram(); // Load data if it wasn't loaded before
        } else {
            console.log("Showing existing dendrogram.");
            // You could potentially redraw or fit view here if desired
            // showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight);
            // resetInlineZoom();
        }
    }
    
    // Optional Helper Function to fit view (Example)
    function fitView() {
        const svg = d3.select("#inlineDendrogramSvg");
        const svgContent = svg.select("g"); // Assumes content is in the first 'g'
        if (!svgContent.empty() && window.inlineZoom) {
            const bounds = svgContent.node().getBBox();
            const parent = svg.node();
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width === 0 || height === 0) return; // Nothing to fit

            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

            svg.transition().duration(750).call(
                window.inlineZoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }
    }

    // Make sure the resetInlineZoom function still uses d3.zoomIdentity
    function resetInlineZoom() {
        const svg = d3.select("#inlineDendrogramSvg");
        if (window.inlineZoom) {
            // Reset zoom with a smooth transition TO THE STORED INITIAL CENTERED TRANSFORM
            svg.transition().duration(500)
                .call(window.inlineZoom.transform, initialTreeTransform);
            console.log("Inline dendrogram zoom reset to initial view.");
        } else {
            console.warn("Cannot reset zoom, zoom behavior not initialized.");
        }
    }

    function loadInlineDendrogram() {
        console.log("Attempting to load inline dendrogram data...");
        // Return the promise chain directly
        return fetch(`${API_BASE_URL}/hierarchical_clusters`) // Use API_BASE_URL
            .then(response => {
                if (!response.ok) {
                    // Try to get specific error from JSON, fallback to text/status
                    return response.json()
                       .catch(() => response.text()) // If JSON fails, get text
                       .then(errBody => {
                           let errMsg = errBody?.error || errBody || `HTTP error ${response.status}`;
                           throw new Error(errMsg);
                       });
                }
                return response.json();
            })
            .then(data => {
                console.log("Dendrogram data received:", data);
                if (Object.keys(data).length === 0 || (data.error)) {
                    console.error("Empty or error data received for dendrogram:", data.error || "Empty object");
                    showInlineDendrogram(null); // Show error state
                } else {
                    showInlineDendrogram(data); // Render the tree
                }
                // Resolve indicating the load attempt is complete, visual errors handled in showInlineDendrogram
                return Promise.resolve();
            })
            .catch(err => {
                console.error("Failed to load or render inline dendrogram:", err);
                showInlineDendrogram(null); // Show error state in the SVG
                // Propagate the error for the DOMContentLoaded handler
                return Promise.reject(err);
            });
    }

    function formatDuration(seconds) {
        if (seconds === null || seconds === undefined || isNaN(seconds) || seconds < 0) {
            return "N/A";
        }
        if (seconds < 60) {
            return `${seconds.toFixed(2)}s`; // More concise seconds
        }
        let minutes = Math.floor(seconds / 60);
        let remainingSeconds = Math.floor(seconds % 60); // Use floor for whole seconds
        if (minutes < 60) {
            return `${minutes}m ${remainingSeconds}s`;
        }
        let hours = Math.floor(minutes / 60);
        let remainingMinutes = minutes % 60;
        if (hours < 24) {
            return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
        }
        let days = Math.floor(hours / 24);
        let remainingHours = hours % 24;
        // Omit seconds for durations >= 1 day for brevity
        return `${days}d ${remainingHours}h ${remainingMinutes}m`;
    }

    function updateTimeInfoDisplay() { // Return promise
        return new Promise((resolve, reject) => { // Wrap in promise
            const timeInfoSpan = document.getElementById('timeInfoSpan');
            if (!timeInfoSpan) {
                console.error("timeInfoSpan element not found");
                // Don't reject here, just log and resolve as it's not critical path
                console.warn("timeInfoSpan element not found, cannot update time display.");
                return resolve();
            }

            timeInfoSpan.textContent = 'Loading time info...'; // Indicate loading

            fetch(`${API_BASE_URL}/time_info`)
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            return response.json().then(err => {
                                console.log("Time info not available:", err.error);
                                return null; // Resolve with null for 404
                            });
                        }
                        return response.text().then(text => { throw new Error(text || `HTTP error ${response.status}`) });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.start_time && data.end_time && data.duration_seconds !== null && !isNaN(data.duration_seconds)) {
                        let startTimeStr = "Invalid Date";
                        let endTimeStr = "Invalid Date";
                        try {
                            startTimeStr = new Date(data.start_time).toLocaleString();
                            endTimeStr = new Date(data.end_time).toLocaleString();
                            if (startTimeStr === "Invalid Date" || endTimeStr === "Invalid Date") {
                                throw new Error("Date parsing resulted in Invalid Date");
                            }
                        } catch (dateError) {
                            console.error("Error formatting dates:", dateError);
                            startTimeStr = data.start_time || "N/A";
                            endTimeStr = data.end_time || "N/A";
                        }
                        const durationFormatted = formatDuration(data.duration_seconds);
                        timeInfoSpan.textContent = `| Start: ${startTimeStr} | End: ${endTimeStr} | Duration: ${durationFormatted}`;
                    } else {
                        console.log("Clearing time info span (no/incomplete data received).");
                        timeInfoSpan.textContent = ''; // Clear if no data or incomplete data
                    }
                    resolve(); // Resolve promise on success or handled 404
                })
                .catch(error => {
                    console.error('Error fetching or processing time info:', error);
                    timeInfoSpan.textContent = '| Time info unavailable'; // Display error message
                    reject(error); // Reject promise on unhandled error
                });
        }); // End promise wrapper
    }

    function reclusterAndRedraw() {
        const resolutionInput = document.getElementById('resolutionInput');
        const resolution = parseFloat(resolutionInput.value);
        const messageDiv = document.getElementById('reclusterMessage');
        const treeInfoSpan = document.getElementById('treeInfoSpan'); // Get info span

        if (isNaN(resolution) || resolution <= 0) {
            messageDiv.textContent = "Please enter a valid resolution > 0.";
            resolutionInput.focus();
            return;
        }

        messageDiv.textContent = "Applying resolution and reclustering..."; // Loading message
        if (treeInfoSpan) treeInfoSpan.textContent = ''; // Clear tree info during recluster
        console.log(`Requesting recluster with resolution: ${resolution}`);
        showLoading(); // Show main loading overlay

        // Fetch new hierarchy data with the specified resolution
        // --- CORRECTED FETCH CALL ---
        fetch(`${API_BASE_URL}/hierarchical_clusters?resolution=${resolution}`)
            .then(response => {
                    if (!response.ok) {
                        // Try to parse error message from backend JSON response
                        return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) });
                    }
                    return response.json();
            })
            .then(treeData => {
                    console.log("Reclustered tree data received:", treeData);

                    // Check for structural changes to provide feedback
                    let currentLeafCount = 0;
                    (function countLeaves(node) { // Simple recursive leaf counter
                        if (!node || typeof node !== 'object') return;
                        if (!node.children || node.children.length === 0) {
                        if(node.cluster_id !== undefined) currentLeafCount++; // Count only actual leaves with cluster_id
                        } else {
                        node.children.forEach(countLeaves);
                        }
                    })(treeData);

                    // --- Update Tree Info Span ---
                    if (treeInfoSpan) {
                        treeInfoSpan.textContent = `${currentLeafCount} Clusters`;
                    }
                    // --- End Update ---

                    // Basic structural comparison (can be improved)
                    const currentHash = JSON.stringify(treeData);
                    const structureChanged = (
                        previousClusterCount === null ||
                        currentLeafCount !== previousClusterCount ||
                        currentHash !== previousClusterHash
                    );

                    previousClusterCount = currentLeafCount; // Update state
                    previousClusterHash = currentHash;      // Update state

                    if (structureChanged) {
                        messageDiv.textContent = `Reclustering complete. ${currentLeafCount} leaf clusters found.`;
                        showInlineDendrogram(treeData, currentDendrogramHeight); // Redraw with current height
                        // Do NOT reset zoom automatically, let user do it if needed
                        resetInlineZoom();

                        // --- IMPORTANT: Update the main heatmap and legend ---
                        console.log("Updating heatmap and legend after recluster...");
                        updateHeatmap(); // This uses the updated cluster IDs from the backend
                        updateLegend(); // Update legend based on new global state
                        clearSidebarVisualization(); // Clear sidebar as clusters changed
                        toggleSidebar(false); // Close sidebar
                        // --- End Updates ---

                    } else {
                        messageDiv.textContent = "No structural change in clusters. Try a different resolution.";
                        // Even if no structural change, redraw to apply potential sorting changes if metric selected
                        showInlineDendrogram(treeData, currentDendrogramHeight);
                    }
                    hideLoading(); // Hide loading overlay
            })
            .catch(err => {
                console.error("Error during recluster/redraw:", err);
                messageDiv.textContent = `Error: ${err.message || "Failed to recluster."}`;
                if (treeInfoSpan) treeInfoSpan.textContent = ''; // Clear info on error
                hideLoading(); // Hide loading overlay on error too
            });
        }

    // --- END Dendrogram JS Functions ---
  </script>
</body>
</html>