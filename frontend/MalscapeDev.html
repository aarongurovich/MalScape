<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Cluster Heatmap with Network Visualization</title>
  <!-- Including D3.js for data-driven visualizations and Cytoscape for network graphs -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
  <style>
    /* General Styles: importing font and setting basic box-model properties */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      color: #333;
      background-color: #f8f9fa;
    }
    /* Use a flex layout for the overall page */
    body { display: flex; }
    
    /* Main container styles where our visualization and controls live */
    #main-container {
      flex: 1;
      padding: 24px;
      height: 100vh;
      overflow-y: auto;
    }
    /* Set consistent width for node and edge size input fields */
    #nodeSizeMin, #nodeSizeMax, #edgeWidthMin, #edgeWidthMax {
      width: 200px;
    }

    /* Legend container styles on the side */
    #legend-container {
      width: 220px;
      background-color: #fff;
      border-left: 1px solid #e9ecef;
      padding: 16px 12px;
      height: 100vh;
      overflow-y: auto;
      box-shadow: -4px 0 8px rgba(0,0,0,0.05);
    }
    
    /* Header styles (h2 and h3) for section titles */
    h2 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 28px;
      font-weight: 600;
      border-bottom: 2px solid #4299e1;
      padding-bottom: 8px;
      display: inline-block;
    }
    h3 {
      color: #2c3e50;
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      font-weight: 600;
    }
    
    /* Control group styling for various filters and controls */
    .control-group {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Input and label styling */
    label {
      display: inline-block;
      margin-right: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      margin-right: 12px;
      margin-bottom: 8px;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus {
      border-color: #4299e1;
      outline: none;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    
    /* Button styling */
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-right: 8px;
    }
    button:hover { background-color: #3182ce; }
    
    /* Specific buttons hidden by default or with special colors */
    #loadMoreBtn {
      display: none;
      margin-top: 16px;
      background-color: #38a169;
    }
    #loadMoreBtn:hover { background-color: #2f855a; }
    
    /* Cytoscape network container style */
    #cy {
      width: 100%;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 24px;
      background-color: #fff;
      display: none;
    }

    /* Table container for CSV data, initially hidden */
    #table-container {
      margin-bottom: 24px;
      border-radius: 8px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }
    #table-container table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
    }
    #table-container th, #table-container td {
      padding: 12px 15px;
      border-bottom: 1px solid #e9ecef;
      text-align: left;
      white-space: nowrap;
    }
    
    /* Pagination controls styling */
    #table-pagination {
      display: none;
      margin-top: 8px;
      text-align: center;
    }
    #table-pagination input {
      width: 60px;
      text-align: center;
    }
    
    /* Tooltip styling for hover details */
    #tooltip {
      position: absolute;
      display: none;
      background: #fff;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 13px;
      color: #2d3748;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      max-width: 300px;
      line-height: 1.5;
    }
    
    /* Styles for colored boxes used in the legend */
    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      vertical-align: middle;
      margin-right: 4px;
      border: 1px solid #ccc;
    }
    #legend {
      font-size: 12px;
      line-height: 1.4;
    }
    #legend th, #legend td {
      padding: 4px 6px;
    }
    #backToHeatmap {
      margin: 20px;
      padding: 8px 16px;
      font-size: 14px;
      display: none;
    }
    
    /* Edge Filter Panel styling: appears when filtering edges in network view */
    #edgeFilterPanel {
      position: absolute;
      top: 80px;
      right: 40px;
      width: 320px;
      padding: 12px;
      background-color: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      display: none;
      z-index: 9999;
    }
    #edgeFilterPanel h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
    }
    #edgeFilterPanel label {
      display: block;
      margin-top: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    #edgeFilterPanel input {
      margin-bottom: 8px;
      width: 100%;
    }
    
    /* Loading overlay styles: covers the page when data is loading */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.8);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #4299e1;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    .loading-text {
      font-size: 18px;
      color: #333;
    }
    
    /* Keyframe animation for spinner rotation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay: shows while fetching or processing data -->
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
  </div>
  
  <!-- Main container with controls and visualization elements -->
  <div id="main-container" style="margin-top: 60px;">
    <h2>MalScape</h2>
    <!-- File Upload and Download Button (for CSV file input/output) -->
    <div id="topControls">
      <!-- File Upload and Download Button (for CSV file input/output) -->
      <div style="top: 16px; left: 16px; z-index: 1000; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <label for="fileInput"><strong>Upload CSV File:</strong></label>
        <input type="file" id="fileInput" accept=".csv">
        <button id="downloadButton">Download Processed CSV File</button>
      </div>
    
      <!-- Heatmap & filter controls section -->
      <div class="control-group">
        <!-- These controls let you choose how to order and filter the heatmap rows -->
        <label for="rowOrderSelect">Order Cells in Each Row By:</label>
        <select id="rowOrderSelect">
          <option value="descending">Descending (by value)</option>
          <option value="ascending">Ascending (by value)</option>
        </select>
        <label for="minSourceAmtFilter">Min Unique Sources:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="e.g., 1" step="1">
        <label for="maxSourceAmtFilter">Max Unique Sources:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="e.g., 100" step="1">
        <label for="minDestinationAmtFilter">Min Unique Destinations:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="e.g., 1" step="1">
        <label for="maxDestinationAmtFilter">Max Unique Destinations:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="e.g., 100" step="1">
        <label for="payloadSearch">Search Payload Content:</label>
        <input type="text" id="payloadSearch" placeholder="Enter keyword">
        <label for="sourceFilter">Source IP:</label>
        <input type="text" id="sourceFilter" placeholder="e.g., 192.168.1.1">
        <label for="destinationFilter">Destination IP:</label>
        <input type="text" id="destinationFilter" placeholder="e.g., 172.16.0.1">
        <label for="protocolFilter">Network Protocol:</label>
        <input type="text" id="protocolFilter" placeholder="e.g., TCP">
        <label for="entropyMinFilter">Min Cluster Variation:</label>
        <input type="number" id="entropyMinFilter"  placeholder="e.g., 1.0" step="0.1">
        <label for="entropyMaxFilter">Max Cluster Variation:</label>
        <input type="number" id="entropyMaxFilter" placeholder="e.g., 3.0" step="0.1">
        <label for="isLargePacketFilter">Show only large packets:</label>
        <input type="checkbox" id="isLargePacketFilter">
        <label for="isSuspiciousAckFilter">Show only suspicious ACKs:</label>
        <input type="checkbox" id="isSuspiciousAckFilter">
      </div>
    </div>

    <div id="sizeControls" style="display: none; margin-top: 16px;">
    <label for="edgeWidthMin">Min Edge Width:</label>
    <input type="number" id="edgeWidthMin" placeholder="e.g., 2" step="1" min="1">
    <label for="edgeWidthMax">Max Edge Width:</label>
    <input type="number" id="edgeWidthMax" placeholder="e.g., 12" step="1" min="1">
    <label for="nodeSizeMin">Min Node Size:</label>
    <input type="number" id="nodeSizeMin" placeholder="e.g., 15" step="1" min="1">
    <label for="nodeSizeMax">Max Node Size:</label>
    <input type="number" id="nodeSizeMax" placeholder="e.g., 50" step="1" min="1">
    </div>

    <!-- Container where the heatmap visualization will be drawn -->
    <div id="heatmap"></div>
    <!-- Hidden button to load additional heatmap data -->
    <button id="loadMoreBtn">Load More</button>
    <!-- Back to Heatmap button: lets you return from the network view -->
    <button id="backToHeatmap">Back to Heatmap</button>
    <!-- Refresh cluster -->
    <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;">Refresh Network</button>
    <!-- Cytoscape network visualization container -->
    <div id="cy"></div>

    <!-- Search bar to filter by Payload (client-side only) -->
    <div id="table-search-container" style="display:none; margin-bottom: 12px;">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>

    <!-- Table container for CSV data of the selected cluster -->
    <div id="table-container"></div>
    <!-- Pagination controls for the CSV data table -->
    <div id="table-pagination">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
  </div>
  
  <!-- Legend container for network protocol colors -->
  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <tr>
        <th>Protocol</th>
        <th>Color</th>
      </tr>
    </table>
  </div>
  
  <!-- Edge Filter Panel: shows filtering options when an edge in the network is clicked -->
  <div id="edgeFilterPanel">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label>
    <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label>
    <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label>
    <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label>
    <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label>
    <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn">Filter Edges</button>
    <button id="clearEdgeFilterBtn">Clear Filter</button>
  </div>
  
  <script>
    // Global Variables for protocol colors, Cytoscape instance, and cluster details
    let protocolColorMap = {};
    let globalCy;
    let selectedEdges = new Set();
    let currentClusterID = null;
    const TABLE_PAGE_SIZE = 50;
    
    // Function to show the loading overlay while data is being processed/fetched
    function showLoading() {
      document.getElementById('loading-overlay').style.display = 'flex';
    }
    // Function to hide the loading overlay
    function hideLoading() {
      document.getElementById('loading-overlay').style.display = 'none';
    }
    
    // Update legend based on the data in window.globalData
    function updateLegend() {
      const legendTable = document.getElementById('legend');
      legendTable.innerHTML = '<tr><th>Protocol</th><th>Color</th></tr>';
      if (window.globalData) {
        let protocols = new Set();
        window.globalData.forEach(d => {
          if (d.Protocol) protocols.add(d.Protocol.trim());
        });
        Array.from(protocols).sort().forEach(protocol => {
          if (!protocolColorMap[protocol]) {
            // Assign a random color to each new protocol
            protocolColorMap[protocol] = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
          }
          const row = document.createElement('tr');
          row.innerHTML = `<td>${protocol}</td><td><span class="color-box" style="background-color:${protocolColorMap[protocol]}"></span></td>`;
          legendTable.appendChild(row);
        });
      }
    }
    
    // Fetch aggregated heatmap data based on the selected filters and metrics
    function updateHeatmap() {
      showLoading(); // Show overlay while fetching
      
      const metrics = [
        { label: "Count", value: "count" },
        { label: "Packet Length", value: "Length" },
        { label: "Payload Length", value: "Len" },
        { label: "% SYN packets", value: "% SYN packets" },
        { label: "% RST packets", value: "% RST packets" },
        { label: "% ACK packets", value: "% ACK packets" },
        { label: "% PSH packets", value: "% PSH packets" },
        { label: "Unique Destinations", value: "Unique Destinations" },
        { label: "Unique Sources", value: "Unique Sources" },
        { label: "Payload Size Variance", value: "Payload Size Variance" },
        { label: "Packets per Second", value: "Packets per Second" },
        { label: "Total Data Sent", value: "Total Data Sent" }
      ];

      // Base filter parameters from user inputs
      const filterParamsBase = {
        payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
        sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
        destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
        protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
        entropyMin: document.getElementById('entropyMinFilter').value,
        entropyMax: document.getElementById('entropyMaxFilter').value,
        isLargePacketOnly: document.getElementById('isLargePacketFilter').checked,
        isSuspiciousAckOnly: document.getElementById('isSuspiciousAckFilter').checked,
        minSourceAmt: document.getElementById('minSourceAmtFilter').value,
        maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
        minDestinationAmt: document.getElementById('minDestinationAmtFilter').value,
        maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
      };

      // Send a separate request per metric and then combine results to draw the heatmap
      Promise.all(metrics.map(m => {
          const filterParams = Object.assign({}, filterParamsBase, { metric: m.value });
          return fetch("http://127.0.0.1:5000/filter_and_aggregate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(filterParams)
          })
          .then(response => response.json())
          .then(data => ({ metric: m.label, pivotData: data }));
        }))
        .then(results => {
          renderCombinedHeatmap(results);
          hideLoading();  // Hide overlay once done
        })
        .catch(error => {
          console.error("Error fetching aggregated data:", error);
          hideLoading();
        });
    }
    
    // Function to render the heatmap using D3 based on the aggregated data received
    function renderCombinedHeatmap(dataByMetric) {
      const orderOption = document.getElementById("rowOrderSelect").value || "descending";
      const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;
      const heatmapData = dataByMetric.map(({ metric, pivotData }) => ({
        metric,
        values: [...pivotData].sort(comparator).slice(0, 700)
      }));
      
      // Compute maximum number of columns among all metrics rows
      const maxCols = d3.max(heatmapData, r => r.values.length);
      
      // Set dimensions for each cell and overall heatmap layout
      const cellWidth = 2;
      const cellHeight = 15;
      const labelMargin = 150;
      const verticalSpacing = 10;
      const numRows = heatmapData.length;
      const totalHeight = 20 + numRows * cellHeight + (numRows - 1) * verticalSpacing + 20;
      const width = labelMargin + maxCols * cellWidth + 40;
      
      // Clear any existing heatmap SVG so it can be redrawn
      d3.select("#heatmap").select("svg").remove();
      const svg = d3.select("#heatmap").append("svg")
                    .attr("width", width)
                    .attr("height", totalHeight);
      
      // Reset any selected cluster if not already set
      if (!window.selectedCluster) {
        window.selectedCluster = null;
      }
      
      // Loop over each metric row and draw the corresponding cells
      heatmapData.forEach((rowData, rowIndex) => {
        const rowY = 20 + rowIndex * (cellHeight + verticalSpacing);
        // Draw row label to the left of the heatmap cells
        svg.append("text")
           .attr("x", labelMargin - 10)
           .attr("y", rowY + cellHeight / 2)
           .attr("text-anchor", "end")
           .attr("alignment-baseline", "middle")
           .attr("font-size", "12px")
           .attr("fill", "black")
           .text(rowData.metric);

        // Create a color scale for the current row based on its maximum value
        let rowMax = d3.max(rowData.values, d => d.value) || 1;
        const localColorScale = d3.scaleSequential(d3.interpolateBlues).domain([0, rowMax]);

        // Draw each cell (as a rect) in the row
        rowData.values.forEach((cellData, colIndex) => {
          let cellX = labelMargin + colIndex * cellWidth;
          svg.append("rect")
             .attr("class", "cell")
             .attr("data-cluster", cellData.cluster)  // Save cluster ID in the DOM element
             .attr("data-original-fill", localColorScale(cellData.value)) // Remember original fill color
             .attr("x", cellX)
             .attr("y", rowY)
             .attr("width", cellWidth)
             .attr("height", cellHeight)
             .attr("fill", localColorScale(cellData.value))
             // Handle mouseover events to highlight the hovered cluster
             .on("mouseover", function(event) {
               if (!window.selectedCluster) {
                 let hoveredCluster = cellData.cluster;
                 d3.selectAll("rect.cell")
                   .transition()
                   .duration(200)
                   .style("opacity", function() {
                     return d3.select(this).attr("data-cluster") === hoveredCluster ? 1 : 0.2;
                   });
               }
               tooltip.style.display = "block";
               tooltip.innerHTML = `<strong>${rowData.metric}</strong><br>Cluster: ${cellData.cluster}<br>Value: ${cellData.value}`;
               tooltip.style.left = (event.pageX + 10) + "px";
               tooltip.style.top = (event.pageY + 10) + "px";
             })
             // Reset opacity on mouseout if no cluster is fixed
             .on("mouseout", function() {
               if (!window.selectedCluster) {
                 d3.selectAll("rect.cell")
                   .transition()
                   .duration(200)
                   .style("opacity", 1);
               }
               tooltip.style.display = "none";
             })
             // On click, fix the view on the selected cluster and add the "Explore Cluster Further" button
             .on("click", function(event) {
               // Prevent the global click listener from firing
               event.stopPropagation();
               let clickedCluster = cellData.cluster;
               window.selectedCluster = clickedCluster;
               
               d3.selectAll("rect.cell")
                 .transition()
                 .duration(200)
                 .style("opacity", function() {
                   return d3.select(this).attr("data-cluster") === clickedCluster ? 1 : 0.2;
                 })
                 .style("fill", function() {
                   let cell = d3.select(this);
                   return cell.attr("data-cluster") === clickedCluster ? "#003366" : cell.attr("data-original-fill");
                 });
               
               // Add or update the "Explore Cluster Further" button for the clicked cluster
               if (d3.select("#exploreClusterBtn").empty()) {
                 d3.select("#main-container")
                   .append("button")
                   .attr("id", "exploreClusterBtn")
                   .text("Explore Cluster Further")
                   .style("margin-left", "10px")
                   .on("click", function() {
                     showClusterNetwork(clickedCluster);
                     document.getElementById('sizeControls').style.display = 'block';
                   });
               } else {
                 d3.select("#exploreClusterBtn")
                   .on("click", function() {
                     showClusterNetwork(clickedCluster);
                     document.getElementById('sizeControls').style.display = 'block';
                   });
               }
             });
        });
      });
      
      // Hide the load more button if there was one showing
      d3.select("#loadMoreBtn").style("display", "none");
    }
    
    // Show the heatmap view and hide other panels (network/table)
    function showHeatmap() {
    document.getElementById('cy').style.display = 'none';
    document.getElementById('backToHeatmap').style.display = 'none';
    document.getElementById('edgeFilterPanel').style.display = 'none';
    document.getElementById('table-container').style.display = 'none';
    document.getElementById('table-pagination').style.display = 'none';
    document.getElementById('refreshNetworkBtn').style.display = 'none';
    document.getElementById('sizeControls').style.display = 'none';
    document.getElementById('table-search-container').style.display = "none";
    document.getElementById('topControls').style.display = 'block'; // âœ… SHOW top controls
    d3.select("#heatmap").style("display", "block");
    clearEdgeFilter();
  }
    document.getElementById('backToHeatmap').addEventListener('click', showHeatmap);
    
    // When a cluster is selected, fetch its network data from the server and show it
    function showClusterNetwork(clusterID) {
    currentClusterID = clusterID;
    fetch("http://127.0.0.1:5000/cluster_network?cluster_id=" + clusterID)
      .then(response => response.json())
      .then(data => {
        if (data.nodes.length === 0 && data.edges.length === 0) {
          alert("No network data for this cluster.");
          return;
        }
        const elementsCombined = data.nodes.concat(data.edges);
        visualizeNetwork(elementsCombined);
        d3.select("#heatmap").style("display", "none");
        document.getElementById('backToHeatmap').style.display = 'inline-block';
        document.getElementById('refreshNetworkBtn').style.display = 'inline-block';
        document.getElementById('topControls').style.display = 'none'; // ðŸ”´ HIDE top controls
        createClusterTable(clusterID);
        document.getElementById('cy').scrollIntoView({ behavior: 'smooth', block: 'center' });
      })
      .catch(error => console.error("Error fetching network data:", error));
  }
    
    // Load a page of cluster data table using pagination
    function loadClusterTablePage(clusterID, page) {
      fetch(`http://127.0.0.1:5000/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
      .then(response => response.text())
      .then(html => {
         const container = document.getElementById('table-container');
         container.innerHTML = html;
         document.getElementById('table-pagination').style.display = 'block';
         const summaryElem = document.getElementById('table-summary');
         if(summaryElem) {
             const total = parseInt(summaryElem.dataset.total);
             const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
             document.getElementById('totalPages').textContent = totalPages;
             document.getElementById('currentPageInput').value = page;
         }
      })
      .catch(error => console.error("Error fetching cluster table:", error));
    }
    
    // Create the data table for the current cluster
    function createClusterTable(clusterID) {
      loadClusterTablePage(clusterID, 1);
      document.getElementById('table-container').style.display = "block";
      document.getElementById('table-search-container').style.display = "block";
    }
    
    // Pagination button to navigate to a specified page
    document.getElementById('goPageBtn').addEventListener('click', function () {
    let page = parseInt(document.getElementById('currentPageInput').value);
    if (page >= 1) {
      if (window.edgeFilterState) {
        const { source, destination, protocol } = window.edgeFilterState;
        fetch(`http://127.0.0.1:5000/get_edge_table?source=${source}&destination=${destination}&protocol=${protocol}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
          .then(res => res.text())
          .then(html => {
            const container = document.getElementById('table-container');
            container.innerHTML = html;
            const summaryElem = document.getElementById('table-summary');
            if (summaryElem) {
              const total = parseInt(summaryElem.dataset.total);
              const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
              document.getElementById('totalPages').textContent = totalPages;
              document.getElementById('currentPageInput').value = page;
            }
          });
      } else if (currentClusterID) {
        loadClusterTablePage(currentClusterID, page);
      }
    }
  });

    // Group nodes into directed components in the network using BFS
    function groupDirectedComponents(cy) {
      let visited = new Set();
      let groupCount = 0;
      function randomColor(){
        return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      }
      cy.nodes().forEach(node => {
        if (!visited.has(node.id())) {
          groupCount++;
          const color = randomColor();
          let bfs = cy.elements().bfs({ roots: node, directed: true });
          bfs.path.forEach(ele => {
            if (ele.isNode()) {
              visited.add(ele.id());
              ele.data('groupID', groupCount);
              ele.data('color', color);
            }
          });
        }
      });
    }
    
    // Position grouped network components in a tree layout
    function positionGroupedComponentsTree(cy) {
      let groupMap = {};
      cy.nodes().forEach(n => {
        let g = n.data('groupID') || 0;
        if (!groupMap[g]) groupMap[g] = [];
        groupMap[g].push(n);
      });
      let sortedGroups = Object.entries(groupMap).sort((a, b) => b[1].length - a[1].length);
      let groupYOffset = 0;
      const verticalSpacingBetweenGroups = 300;
      const levelHeight = 80;
      const siblingSpacing = 500;
      sortedGroups.forEach(([groupID, nodes]) => {
        let root = nodes.reduce((prev, curr) => {
          return (!prev || (curr.data('timeIndex') < prev.data('timeIndex'))) ? curr : prev;
        }, null);
        if (!root) return;
        let levels = {};
        let visited = new Set();
        let queue = [];
        levels[root.id()] = 0;
        visited.add(root.id());
        queue.push(root);
        while (queue.length > 0) {
          let current = queue.shift();
          let currentLevel = levels[current.id()];
          current.outgoers('edge').forEach(edge => {
            let target = edge.target();
            if (target.data('groupID') == groupID && !visited.has(target.id())) {
              levels[target.id()] = currentLevel + 1;
              visited.add(target.id());
              queue.push(target);
            }
          });
        }
        let levelNodes = {};
        nodes.forEach(n => {
          let lvl = levels[n.id()] !== undefined ? levels[n.id()] : 0;
          if (!levelNodes[lvl]) levelNodes[lvl] = [];
          levelNodes[lvl].push(n);
        });
        Object.keys(levelNodes).forEach(lvlKey => {
          let lvl = parseInt(lvlKey);
          let nodesAtLevel = levelNodes[lvl];
          nodesAtLevel.sort((a, b) => (a.data('timeIndex') || 0) - (b.data('timeIndex') || 0));
          let totalWidth = (nodesAtLevel.length - 1) * siblingSpacing;
          let startX = -totalWidth / 2;
          nodesAtLevel.forEach((n, idx) => {
            let x = startX + idx * siblingSpacing;
            let y = groupYOffset + lvl * levelHeight;
            n.position({x: x, y: y});
          });
        });
        let maxLevel = Math.max(...Object.keys(levelNodes).map(Number));
        groupYOffset += (maxLevel + 1) * levelHeight + verticalSpacingBetweenGroups;
      });
    }
    
    // Helper function to compute the clamped node size
    function getNodeSize(ele) {
      let minSize = parseFloat(document.getElementById('nodeSizeMin').value);
      let maxSize = parseFloat(document.getElementById('nodeSizeMax').value);

      // Apply defaults only if both are missing
      if (isNaN(minSize) && isNaN(maxSize)) {
        minSize = 30;
        maxSize = 65;
      } else {
        // If one is missing, use the other as a fallback
        if (isNaN(minSize)) minSize = maxSize;
        if (isNaN(maxSize)) maxSize = minSize;
      }

      // Prevent accidental inversion
      if (maxSize < minSize) {
        const temp = maxSize;
        maxSize = minSize;
        minSize = temp;
      }

      // Get min/max NodeWeight from all nodes
      let maxWeight = 0;
      let minWeight = Infinity;
      ele.cy().nodes().forEach(n => {
        const w = parseFloat(n.data('NodeWeight')) || 0;
        if (w > maxWeight) maxWeight = w;
        if (w < minWeight) minWeight = w;
      });
      if (!isFinite(minWeight)) minWeight = 0;

      const currentWeight = parseFloat(ele.data('NodeWeight')) || 0;

      if (maxWeight === minWeight) return minSize;

      const scaled = minSize + ((currentWeight - minWeight) / (maxWeight - minWeight)) * (maxSize - minSize);
      return Math.min(Math.max(scaled, minSize), maxSize);
    }


    // Visualize the network using Cytoscape with our configured styles and layout
    function visualizeNetwork(elements) {
      document.getElementById('cy').style.display = 'block';
      const cy = cytoscape({
        container: document.getElementById('cy'),
        elements: elements,
        layout: { name: 'preset' },
        style: [
                  {
            selector: 'node',
            style: {
              'width': function(ele) {
                return getNodeSize(ele);
              },
              'height': function(ele) {
                return getNodeSize(ele);
              },
              'background-color': 'mapData(NodeWeight, 0, 1, #d4f0d4, #006400)',
              'border-width': 2,
              'border-color': '#333',
              'content': 'data(label)',
              'font-size': 14,
              'color': '#000',
              'text-valign': 'center',
              'text-halign': 'center',
              'text-opacity': 1,
              'text-outline-width': 2,
              'text-outline-color': '#fff',
              'shape': 'ellipse'
            }
          },
          {
            selector: 'node[Classification="Internal"]',
            style: { 'shape': 'rectangle' }
          },
          {
            selector: 'node[color]',
            style: { 'background-color': 'data(color)' }
          },
          {
            selector: 'edge',
            style: {
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'control-point-step-size': 30,
              'width': 'data(normalizedWeight)',
              'line-color': function(ele) {
                return ele.data('edgeColor') || '#888';
              },
              'target-arrow-color': function(ele) {
                return ele.data('edgeColor') || '#888';
              },
              'opacity': 0.8
            }
          },
          {
            selector: 'edge.selected',
            style: {
              'line-color': 'red',
              'target-arrow-color': 'red',
              'width': 4
            }
          }
        ]
      });
      
      globalCy = cy;
      
      // Assign colors to edges based on protocol
      cy.edges().forEach(edge => {
        let protocol = edge.data('Protocol');
        edge.data('edgeColor', protocolColorMap[protocol] || '#888');
      });
      
      // Calculate normalized edge widths based on process count
      cy.edges().forEach(edge => {
        if (edge.data('processCount') !== undefined) {
          let count = parseFloat(edge.data('processCount')) || 0;
          const maxNormalizedWeight = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 12, 2);
          const minNormalizedWeight = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 2, 1);
          const computedWeight = 2 + (count * 1);
          edge.data('normalizedWeight', Math.min(Math.max(computedWeight, minNormalizedWeight), maxNormalizedWeight));
        } else {
          edge.data('normalizedWeight', 2);
        }
      });
      
      // Group components and position them in a tree layout
      groupDirectedComponents(cy);
      positionGroupedComponentsTree(cy);
      cy.fit(cy.elements(), 30);
      
      // Define interactive events for nodes and edges with tooltip popups
      cy.on('mouseover', 'node,edge', (evt) => {
        let t = evt.target;
        let px = evt.originalEvent.pageX;
        let py = evt.originalEvent.pageY;
        tooltip.style.display = 'block';
        tooltip.style.left = (px + 10) + 'px';
        tooltip.style.top = (py + 10) + 'px';
        if (t.isNode()) {
          tooltip.innerHTML = `<strong>Node IP:</strong> ${t.id()}<br>
                               <strong>Classification:</strong> ${t.data('Classification')}<br>
                               <strong>Group:</strong> ${t.data('groupID') || 'N/A'}<br>`;
        } else {
          let processes = (t.data('processCount') !== undefined) ? t.data('processCount') : 0;
          tooltip.innerHTML = `<strong>Edge:</strong><br>
                               From: ${t.data('source')}<br>
                               To: ${t.data('target')}<br>
                               Protocol: ${t.data('Protocol')}<br>
                               Processes: ${processes}<br>
                               Weight: ${t.data('EdgeWeight')}`;
        }
      });
      
      cy.on('mouseout', 'node,edge', () => {
        tooltip.style.display = 'none';
      });
      
      // On edge click: support selecting edges (with shift for group selection)
      cy.on('click', 'edge', (evt) => {
      const edge = evt.target;
      const source = edge.data('source');
      const destination = edge.data('target');
      const protocol = edge.data('Protocol');
      const pageSize = 50;
      const page = 1;

      fetch(`http://127.0.0.1:5000/get_edge_table?source=${source}&destination=${destination}&protocol=${protocol}&page=${page}&page_size=${pageSize}`)
        .then(res => res.text())
        .then(html => {
          const container = document.getElementById('table-container');
          container.innerHTML = html;
          container.style.display = 'block';
          document.getElementById('table-pagination').style.display = 'block';

          const summaryElem = document.getElementById('table-summary');
          if (summaryElem) {
            const total = parseInt(summaryElem.dataset.total);
            const totalPages = Math.ceil(total / pageSize);
            document.getElementById('totalPages').textContent = totalPages;
            document.getElementById('currentPageInput').value = page;
          }

          // Save current edge filter globally to use in pagination
          window.edgeFilterState = { source, destination, protocol };
        });
    });
    }
    
    // Show the edge filter panel and prefill with the edge's data
    function showEdgeFilterPanel(edgeData) {
      document.getElementById('edgeFilterSource').value = edgeData.source || "";
      document.getElementById('edgeFilterDestination').value = edgeData.target || "";
      document.getElementById('edgeFilterProtocol').value = edgeData.Protocol || "";
      document.getElementById('edgeFilterWeight').value = "";
      document.getElementById('edgeFilterProcessCount').value = "";
      const panel = document.getElementById('edgeFilterPanel');
      panel.style.display = 'block';
    }
    
    // Clear any active edge filters and hide the panel
    function clearEdgeFilter() {
      if (!globalCy) return;
      globalCy.edges().forEach(e => e.show());
      document.getElementById('edgeFilterSource').value = "";
      document.getElementById('edgeFilterDestination').value = "";
      document.getElementById('edgeFilterProtocol').value = "";
      document.getElementById('edgeFilterWeight').value = "";
      document.getElementById('edgeFilterProcessCount').value = "";
      document.getElementById('edgeFilterPanel').style.display = 'none';
    }
    
    // Apply edge filter based on the inputs in the filter panel
    function applyEdgeFilter() {
      if (!globalCy) return;
      let fSource = document.getElementById('edgeFilterSource').value.trim().toLowerCase();
      let fDest = document.getElementById('edgeFilterDestination').value.trim().toLowerCase();
      let fProto = document.getElementById('edgeFilterProtocol').value.trim().toLowerCase();
      let fWeight = document.getElementById('edgeFilterWeight').value.trim();
      let fProcessCount = document.getElementById('edgeFilterProcessCount').value.trim();
      
      globalCy.edges().forEach(e => {
        let d = e.data();
        let keep = true;
        if (fSource && !d.source.toLowerCase().includes(fSource)) keep = false;
        if (fDest && !d.target.toLowerCase().includes(fDest)) keep = false;
        if (fProto && !d.Protocol.toLowerCase().includes(fProto)) keep = false;
        if (fWeight) {
          let parsed = parseNumericExpression(fWeight);
          if (parsed) {
            const edgeVal = d.EdgeWeight || 0;
            switch (parsed.operator) {
              case '>':  if (!(edgeVal > parsed.number))  keep = false; break;
              case '>=': if (!(edgeVal >= parsed.number)) keep = false; break;
              case '<':  if (!(edgeVal < parsed.number))  keep = false; break;
              case '<=': if (!(edgeVal <= parsed.number)) keep = false; break;
              case '==': if (edgeVal !== parsed.number)   keep = false; break;
              default: break;
            }
          }
        }
        if (fProcessCount) {
          let parsedCount = parseNumericExpression(fProcessCount);
          if (parsedCount) {
            const countVal = d.processCount || 0;
            switch (parsedCount.operator) {
              case '>':  if (!(countVal > parsedCount.number))  keep = false; break;
              case '>=': if (!(countVal >= parsedCount.number)) keep = false; break;
              case '<':  if (!(countVal < parsedCount.number))  keep = false; break;
              case '<=': if (!(countVal <= parsedCount.number)) keep = false; break;
              case '==': if (countVal !== parsedCount.number)     keep = false; break;
              default: break;
            }
          }
        }
        if (keep) e.show(); else e.hide();
      });
    }
    
    // Listeners for the edge filter apply and clear buttons
    document.getElementById('applyEdgeFilterBtn').addEventListener('click', applyEdgeFilter);
    document.getElementById('clearEdgeFilterBtn').addEventListener('click', clearEdgeFilter);
    
    // Utility: parse a numeric expression like ">=1000" from user input
    function parseNumericExpression(value) {
      const match = value.match(/^(\>=|\<=|>|<)\s*(\d+(?:\.\d+)?)$/);
      if (match) {
        return { operator: match[1], number: parseFloat(match[2]) };
      }
      const justNum = parseFloat(value);
      if (!isNaN(justNum) && value.trim() !== "") {
        return { operator: '==', number: justNum };
      }
      return null;
    }
    
    // Handle CSV file upload: read file and send its content to the server for processing
    document.getElementById("fileInput").addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        showLoading();
        const csvText = e.target.result;
        fetch("http://127.0.0.1:5000/process_csv", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ csv_text: csvText })
        })
        .then(response => response.text())
        .then(processedText => {
          try {
            window.globalData = d3.csvParse(processedText, d3.autoType);
            updateLegend();
            updateHeatmap();
          } catch (error) {
            console.error("Error parsing processed CSV:", error);
          } finally {
            hideLoading();
          }
        })
        .catch(error => {
          console.error("Error processing CSV on server:", error);
          hideLoading();
        });
      };
      reader.readAsText(file);
    });
    
    // Download button just sends the browser to our download endpoint
    document.getElementById("downloadButton").addEventListener("click", function() {
      window.location.href = "http://127.0.0.1:5000/download_csv";
    });

    // Cluster refresh button
    document.getElementById("refreshNetworkBtn").addEventListener("click", function() {
      if (currentClusterID && window.globalData) {
        showClusterNetwork(currentClusterID);
      }
    });
    
    // Create a tooltip element that will be used for hover details on the heatmap and network
    const tooltip = document.createElement('div');
    tooltip.id = 'tooltip';
    document.body.appendChild(tooltip);
    
    // Add keydown events on all the filter inputs so that pressing "Enter" triggers the heatmap update
    const filterIds = [
      'payloadSearch', 'sourceFilter', 'destinationFilter',
      'protocolFilter', 'entropyMinFilter', 'entropyMaxFilter',
      'isLargePacketFilter', 'isSuspiciousAckFilter', 'rowOrderSelect',
      'minSourceAmtFilter', 'maxSourceAmtFilter', 'minDestinationAmtFilter', 'maxDestinationAmtFilter'
    ];
    
    filterIds.forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('keydown', function (event) {
        if (event.key === "Enter") {
          updateHeatmap();
        }
      });
    });
    
    // GLOBAL CLICK LISTENER:
    // When clicking anywhere that's not a cell, clear any selected cluster.
    document.addEventListener('click', function(event) {
      // If the target does NOT have the "cell" class, clear the selection.
      if (!event.target.classList.contains('cell')) {
        if (window.selectedCluster) {
          window.selectedCluster = null;
          d3.selectAll("rect.cell")
            .transition()
            .duration(200)
            .style("opacity", 1)
            .style("fill", function() {
              return d3.select(this).attr("data-original-fill");
            });
          // Remove the Explore Cluster Further button if it exists.
          d3.select("#exploreClusterBtn").remove();
        }
      }
    });

    // Payload search filter for the displayed table
    document.getElementById('tableSearchInput').addEventListener('input', function () {
      const query = this.value.trim().toLowerCase();
      const rows = document.querySelectorAll('#table-container table tbody tr');

      rows.forEach(row => {
        const match = Array.from(row.cells).some(cell =>
          cell.textContent.toLowerCase().includes(query)
        );
        row.style.display = match ? "" : "none";
      });
    });
    
  </script> 
</body>
</html>
