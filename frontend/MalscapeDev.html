<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MalScape</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; color: #333; background-color: #f8f9fa; overflow-x: hidden; }
        body { display: flex; }

        #sidebar {
            width: 0;
            height: 100vh;
            background-color: #f1f3f5;
            border-right: 1px solid #dee2e6;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.3s ease, padding 0.3s ease;
            position: fixed;
            top: 0;
            left: 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1100;
            display: flex;
            flex-direction: column;
        }
        #sidebar.open {
            width: 500px;
            padding: 20px;
        }
        #sidebar-content {
            opacity: 0;
            transition: opacity 0.3s ease 0.1s;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #sidebar.open #sidebar-content {
            opacity: 1;
            overflow: visible;
        }
        #sidebar-cy {
            width: 100%;
            height: 40%;
            min-height: 250px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background-color: #fff;
            margin-top: 10px;
            flex-shrink: 0;
        }

        #sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            z-index: 1200;
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 15px 8px;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, left 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        #sidebar-toggle:hover {
            background-color: #3182ce;
        }

        #main-container {
            flex: 1;
            padding: 24px;
            height: 100vh;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            margin-left: 0; /* Keep existing margin-left */
            padding-left: 40px; /* Keep existing padding-left */
            margin-right: 230px; /* ADDED: Legend width (220px) + buffer (10px) */
        }

        #nodeSizeMin, #nodeSizeMax, #edgeWidthMin, #edgeWidthMax { width: 200px; }
        #legend-container { width: 220px; background-color: #fff; border-left: 1px solid #e9ecef; padding: 16px 12px; height: 100vh; overflow-y: auto; box-shadow: -4px 0 8px rgba(0,0,0,0.05); position: fixed; right: 0; top: 0; z-index: 1000; }
        h2 { color: #2c3e50; margin-top: 0; margin-bottom: 24px; font-size: 28px; font-weight: 600; border-bottom: 2px solid #4299e1; padding-bottom: 8px; display: inline-block; }
        h3 { color: #2c3e50; font-size: 16px; margin-top: 0; margin-bottom: 12px; font-weight: 600; }
        #sidebar h3 { font-size: 18px; margin-bottom: 10px; flex-shrink: 0; }

        .control-group { margin-bottom: 20px; padding: 16px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .sidebar-control {
            padding: 8px 0;
            margin-bottom: 5px;
            background: none;
            box-shadow: none;
            border-radius: 0;
        }
        .sidebar-control label {
            font-size: 13px;
            margin-right: 5px;
        }

        label { display: inline-block; margin-right: 8px; font-weight: 500; color: #4a5568; }
        input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] { padding: 8px 12px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; margin-right: 12px; margin-bottom: 8px; transition: border-color 0.2s; }
        input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus { border-color: #4299e1; outline: none; box-shadow: 0 0 0 3px rgba(66,153,225,0.15); }
        button { background-color: #4299e1; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s; margin-right: 8px; }
        button:hover { background-color: #3182ce; }
        #loadMoreBtn { display: none; margin-top: 16px; background-color: #38a169; }
        #loadMoreBtn:hover { background-color: #2f855a; }
        #cy { width: 100%; height: 600px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-top: 24px; margin-bottom: 24px; background-color: #fff; display: none; }

        #table-container { margin-top: 24px; margin-bottom: 24px; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: none; max-height: 300px; overflow-y: auto; }
        #table-container table { width: 100%; border-collapse: collapse; table-layout: auto; }
        #table-container th, #table-container td { padding: 12px 15px; border-bottom: 1px solid #e9ecef; text-align: left; white-space: nowrap; }
        #table-pagination { display: none; margin-top: 8px; text-align: center; }
        #table-pagination input { width: 60px; text-align: center; }

        #tooltip { position: absolute; display: none; background: rgba(255, 255, 255, 0.95); border-radius: 4px; padding: 8px 12px; font-size: 13px; color: #2d3748; pointer-events: none; z-index: 2000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px; line-height: 1.5; border: 1px solid #dee2e6; }
        .color-box { display: inline-block; width: 12px; height: 12px; vertical-align: middle; margin-right: 4px; border: 1px solid #ccc; }
        #legend { font-size: 12px; line-height: 1.4; table-layout: fixed; width: 100%;}
        #legend th, #legend td { padding: 4px 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        #legend td:first-child, #legend th:first-child { width: 45%; }
        #legend td:nth-child(2), #legend th:nth-child(2) { width: 25%; }
        #legend td:last-child, #legend th:last-child { width: 30%; text-align: right;}
        #backToHeatmap { margin: 20px 0; padding: 8px 16px; font-size: 14px; display: none; }
        #edgeFilterPanel { position: absolute; top: 80px; right: 260px; width: 320px; padding: 12px; background-color: #fff; border: 1px solid #e2e8f0; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); display: none; z-index: 999; }
        #edgeFilterPanel h4 { margin-top: 0; margin-bottom: 8px; font-size: 16px; font-weight: 600; color: #2c3e50; }
        #edgeFilterPanel label { display: block; margin-top: 8px; font-weight: 500; color: #4a5568; }
        #edgeFilterPanel input { margin-bottom: 8px; width: 100%; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4299e1; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 16px; }
        .loading-text { font-size: 18px; color: #333; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #resetSidebarBtn { background-color: #6c757d; margin-top: 5px; margin-bottom: 10px; width: 100%; flex-shrink: 0; }
        #resetSidebarBtn:hover { background-color: #5a6268; }

        #sidebar-table-container {
            margin-top: 15px;
            flex-grow: 1;
            overflow: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: #fff;
            display: none;
        }
        #sidebar-table-container table {
            font-size: 11px;
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }
        #sidebar-table-container th {
            background-color: #f1f3f5;
            padding: 8px 10px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom: 2px solid #dee2e6;
            font-weight: 600;
            white-space: nowrap;
        }
        #sidebar-table-container td {
            padding: 8px 10px;
            white-space: normal;
            word-break: break-word;
            border: none;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
            line-height: 1.4;
        }
        #sidebar-table-container tr:last-child td { border-bottom: none; }
        #sidebar-table-container tbody tr:nth-child(even) { background-color: #f8f9fa; }
        #sidebar-table-container tbody tr:hover { background-color: #e9ecef; }

        #sidebar-table-container th,
        #sidebar-table-container td {
          min-width: 150px;
          word-break: break-word;
        }
        #sidebar-table-pagination {
            text-align: center;
            margin-top: 8px;
            display: none;
            flex-shrink: 0;
        }
        #sidebar-table-pagination button { padding: 4px 8px; font-size: 12px; }
        #sidebar-table-pagination input { width: 45px; font-size: 12px; padding: 4px 6px; }

        #loading-overlay .cancel-button {
            margin-top: 20px; /* Space below the loading text */
            padding: 8px 16px;
            font-size: 14px;
            background-color: #dc3545; /* Red color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #loading-overlay .cancel-button:hover {
            background-color: #c82333;
        }

        /* --- BEGIN ADDED Dendrogram CSS --- */
        #dendrogramCard {
            /* Styles copied from MalscapeDev - Copy.html */
            display: none; /* Initially hidden */
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0; /* Added margin */
            border: 1px solid #e2e8f0; /* Added subtle border */
        }
        #inline-dendrogram-container {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-bottom: 10px; /* Reduced margin */
            width: 100%;
            height: 400px; /* Default height */
            overflow: hidden; /* Needed for SVG zoom/pan */
            border: 1px solid #dee2e6; /* Added border */
            border-radius: 6px; /* Added radius */
            position: relative; /* For positioning controls or overlays if needed */
        }
        #inlineDendrogramSvg {
            /* Styles copied from MalscapeDev - Copy.html */
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab; /* Indicate draggable */
        }
        #inlineDendrogramSvg:active {
            cursor: grabbing;
        }
        #treeControls {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #treeControls label {
            margin-bottom: 0; /* Align with inputs */
        }
        #treeControls input[type="number"] {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-bottom: 0;
            vertical-align: middle;
            width: 70px; /* Adjust width */
            padding: 6px 8px; /* Adjust padding */
        }
        #treeControls button {
            padding: 6px 12px; /* Adjust padding */
        }
        #treeControls select {
            padding-top: 6px;
            padding-bottom: 6px;
            padding-left: 8px;
            padding-right: 8px;
            margin-bottom: 0;
        }
        #reclusterMessage {
            /* Styles copied from MalscapeDev - Copy.html */
            color: #e53e3e; /* Use a red color */
            font-size: 13px;
            margin-top: 8px;
            font-weight: 500;
        }
        /* Adjustments for button groups */
        .tree-height-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto; /* Push height controls to the right */
        }
        .tree-height-controls button {
            background: none;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 4px 10px;
        }
        .tree-height-controls button:hover {
            background-color: #edf2f7;
            border-color: #a0aec0;
        }
        .custom-height-link {
            background: none;
            border: none;
            color: #4299e1; /* Link color */
            cursor: pointer;
            font-size: 13px;
            text-decoration: underline;
            padding: 0;
            margin-left: 5px;
        }
        .custom-height-link:hover {
            color: #3182ce;
        }
            .show-tree-button {
            padding: 6px 12px;
            font-size: 14px;
            background-color: #28a745; /* Green color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .show-tree-button:hover {
            background-color: #218838;
        }

        /* Style for the existing Hide Tree button */
        .small-utility-button {
            padding: 3px 8px;
            font-size: 12px;
            background-color: #6c757d; /* Grey color */
            /* ... keep other existing styles for .small-utility-button ... */
            border-radius: 4px;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .small-utility-button:hover {
            background-color: #5a6268;
        }
        .node--leaf circle.highlighted {
            fill: #ff7f0e; /* Orange color for highlight - Use specific color from map now */
            r: 6; /* Slightly larger radius */
        }
        /* --- END ADDED Dendrogram CSS --- */
    </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
    <button id="cancelLoadingBtn" class="cancel-button">Cancel</button>
  </div>

  <button id="sidebar-toggle">&#9776;</button>

  <div id="sidebar">
      <div id="sidebar-content">
          <h3>Cluster Visualization</h3>
          <button id="resetSidebarBtn">Reset Node Selection</button>

          <div class="control-group sidebar-control">
              <label for="sidebarLayoutSelect">Layout:</label>
              <select id="sidebarLayoutSelect" style="padding: 4px 8px; font-size: 12px; max-width: 150px;">
                  <option value="cose" selected>Cose (Default)</option>
                  <option value="breadthfirst">Hierarchical</option>
                  <option value="circle">Circle</option>
                  <option value="grid">Grid</option>
                  <option value="concentric">Concentric</option>
                  <option value="random">Random</option>
              </select>
          </div>

          <div id="sidebar-cy-loading" style="display: none; text-align: center; margin-top: 5px; color: #6c757d;">Loading graph...</div>
          <div id="sidebar-cy"></div>
          <div id="sidebar-info" style="margin-top: 10px; font-size: 14px; text-align: center; flex-shrink: 0;">Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.</div>
          <div id="sidebar-table-loading" style="display: none; text-align: center; margin-top: 20px; color: #6c757d;">Loading table...</div>
          <div id="sidebar-table-container"></div>
          <div id="sidebar-table-pagination">
              <span>Page <input type="number" id="sidebarCurrentPageInput" value="1" min="1" style="width:45px;"> of <span id="sidebarTotalPages">?</span></span>
              <button id="sidebarGoPageBtn">Go</button>
          </div>
      </div>
  </div>

  <div id="main-container">
    <h2>MalScape</h2>
    <div id="topControls">
      <div style="margin-bottom: 16px; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <label for="fileInput"><strong>Upload CSV File:</strong></label>
        <input type="file" id="fileInput" accept=".csv">
        <button id="downloadButton">Download Processed CSV File</button>
      </div>
      <div class="control-group">
        <label for="rowOrderSelect">Order Cells By:</label>
        <select id="rowOrderSelect"> <option value="descending">Descending</option> <option value="ascending">Ascending</option> </select>
        <label for="minSourceAmtFilter">Min Src:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="1" step="1" style="width:60px;">
        <label for="maxSourceAmtFilter">Max Src:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="Inf" step="1" style="width:60px;">
        <label for="minDestinationAmtFilter">Min Dst:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="1" step="1" style="width:60px;">
        <label for="maxDestinationAmtFilter">Max Dst:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="Inf" step="1" style="width:60px;">
        <label for="payloadSearch">Payload:</label>
        <input type="text" id="payloadSearch" placeholder="Keyword" style="width:100px;">
        <label for="sourceFilter">Src IP:</label>
        <input type="text" id="sourceFilter" placeholder="IP" style="width:100px;">
        <label for="destinationFilter">Dst IP:</label>
        <input type="text" id="destinationFilter" placeholder="IP" style="width:100px;">
        <label for="protocolFilter">Proto:</label>
        <input type="text" id="protocolFilter" placeholder="TCP" style="width:60px;">
        <label for="entropyMinFilter">Min Ent:</label>
        <input type="number" id="entropyMinFilter" placeholder="0.0" step="0.1" style="width:60px;">
        <label for="entropyMaxFilter">Max Ent:</label>
        <input type="number" id="entropyMaxFilter" placeholder="Inf" step="0.1" style="width:60px;">
        <label for="isLargePacketFilter">Large Pkts:</label>
        <input type="checkbox" id="isLargePacketFilter">
        <label for="isSuspiciousAckFilter">Susp ACK:</label>
        <input type="checkbox" id="isSuspiciousAckFilter">
        <button id="applyFiltersBtn" style="margin-left: 10px;">Apply Filters</button>
      </div>
    </div>
    <button id="showTreeBtn" class="show-tree-button" style="display: none; margin-bottom: 15px;">Show Hierarchical Cluster Tree</button>
    <div id="dendrogramCard">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h3>Hierarchical Cluster Tree</h3>
        <button id="hideTreeBtn" class="small-utility-button">Hide Tree</button>
      </div>
      <div id="inline-dendrogram-container">
        <svg id="inlineDendrogramSvg"></svg>
      </div>
      <div id="treeControls">
        <label for="dendrogramSortMetricSelect">Order Leaves By:</label>
        <select id="dendrogramSortMetricSelect">
            <option value="Count" selected>Count (Default)</option>
            <option value="Unique IPs">Unique IPs</option>
            <option value="Unique Sources">Unique Sources</option>
            <option value="Unique Destinations">Unique Destinations</option>
            <option value="Payload Size Variance">Payload Size Variance</option>
            <option value="Packets per Second">Packets per Second</option>
            <option value="Total Data Sent">Total Data Sent</option>
             <option value="% SYN packets">% SYN packets</option>
             <option value="% RST packets">% RST packets</option>
             <option value="% ACK packets">% ACK packets</option>
             <option value="% PSH packets">% PSH packets</option>
             <option value="Length">Packet Length</option>
             <option value="Len">Payload Length</option>
            </select>
        <label for="resolutionInput">Louvain Resolution:</label>
        <input type="number" id="resolutionInput" value="2.5" step="0.1" min="0.1" placeholder="default 2.5">
        <button onclick="reclusterAndRedraw()">Apply Resolution</button>
        <button onclick="resetInlineZoom()">Reset Zoom</button>
        <div class="tree-height-controls">
          <button class="custom-height-link" onclick="showCustomHeightInput()">Set Custom Height</button>
        </div>
        <div id="reclusterMessage" style="width: 100%; margin-top: 5px;"></div>
      </div>
    </div>
    <div id="heatmap"></div>
    <div id="table-search-container" style="display:none; margin-bottom: 12px; margin-top: 24px;">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>
    <div id="table-container"></div>
    <div id="table-pagination">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
    <div style="margin-top: 20px;">
        <button id="loadMoreBtn">Load More</button>
        <button id="backToHeatmap">Back to Heatmap</button>
        <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;">Refresh Network</button>
    </div>
    <div id="sizeControls" style="display: none; margin-top: 16px;">
      <label for="edgeWidthMin">Min Edge Width:</label>
      <input type="number" id="edgeWidthMin" placeholder="1" step="0.1" min="0.1" value="1">
      <label for="edgeWidthMax">Max Edge Width:</label>
      <input type="number" id="edgeWidthMax" placeholder="10" step="0.1" min="0.1" value="10">
      <label for="nodeSizeMin">Min Node Size:</label>
      <input type="number" id="nodeSizeMin" placeholder="15" step="1" min="1" value="15">
      <label for="nodeSizeMax">Max Node Size:</label>
      <input type="number" id="nodeSizeMax" placeholder="60" step="1" min="1" value="60">
    </div>
    <div id="cy"></div>
  </div>

  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <thead><tr><th>Protocol</th><th>Color</th><th>Process %</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="edgeFilterPanel">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label> <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label> <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label> <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label> <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label> <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn">Filter Edges</button> <button id="clearEdgeFilterBtn">Clear Filter</button>
  </div>

  <div id="tooltip"></div>

  <script>
    const API_BASE_URL = 'http://127.0.0.1:5000';
    const DEFAULT_UNKNOWN_COLOR = '#cccccc';
    const SELECTED_EDGE_COLOR = '#ff0000'; // Red
    const SELECTED_NODE_COLOR = '#ff0000'; // Red
    const SELECTED_EDGE_WIDTH = 3.5;
    const SELECTED_EDGE_ZINDEX = 999;
    
    let previousClusterCount = null; // dendrogram change detection
    let previousClusterHash = null; // dendrogram change detection
    let treeHeightExpanded = false; // endrogram height toggle
    let customTreeHeightActive = false; // dendrogram custom height
    window.lastTreeData = null; // store dendrogram data
    window.inlineZoom = null; // store zoom behavior
    let csvProcessingController = null; // Controller to abort CSV processing fetch
    let initialTreeTransform = d3.zoomIdentity;
    let currentDendrogramHeight = 400; // Default height

    let protocolColorMap = {};
    let globalCy; // For main #cy element, if used
    let sidebarCy; // For #sidebar-cy element
    let currentClusterID = null; // Cluster ID shown in main table/graph
    let currentSidebarTableClusterId = null; // Cluster ID shown in sidebar table (cluster mode)
    const TABLE_PAGE_SIZE = 30;
    const heatmapCellWidth = 2;
    const heatmapCellHeight = 15;
    let tooltip;
    let clusterHighlightColors = new Map(); // Maps clusterID -> highlight color for heatmap/nodes
    let addedSidebarClusters = new Set(); // Tracks clusterIDs added to sidebar graph
    let selectedSidebarEdges = new Set(); // Tracks individually selected edges (edgeKey format)
    let selectedNodeId = null; // Tracks ID of the currently selected node in sidebar graph
    let sidebarTableMode = 'cluster'; // 'cluster' or 'edges'
    let isSidebarOpen = false;
    let sidebarWidth = 500;

    const sidebar = document.getElementById('sidebar');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle');
    const mainContainer = document.getElementById('main-container');
    const resetSidebarBtn = document.getElementById('resetSidebarBtn');
    const sidebarTableContainer = document.getElementById('sidebar-table-container');
    const sidebarTablePagination = document.getElementById('sidebar-table-pagination');
    const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');

    // --- Layout Options Definitions ---
    const sidebarLayoutOptions = {
        cose: {
            name: 'cose', animate: true, animationDuration: 500, padding: 30,
            idealEdgeLength: 100, nodeRepulsion: node => node.degree() * 15000,
            edgeElasticity: edge => 100, gravity: 60, numIter: 1000,
            initialTemp: 200, coolingFactor: 0.95, minTemp: 1.0, fit: true
        },
        breadthfirst: {
            name: 'breadthfirst', directed: true, padding: 20, circle: false,
            grid: false, spacingFactor: 1.4, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, roots: undefined,
            animate: true, animationDuration: 500, fit: true
        },
        circle: {
            name: 'circle', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1.2, radius: undefined,
            startAngle: 3/2 * Math.PI,
            animate: true, animationDuration: 500, fit: true
        },
        grid: {
            name: 'grid', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1,
            rows: undefined, cols: undefined,
            position: function( node ){},
            animate: true, animationDuration: 500, fit: true
        },
        random: {
            name: 'random', fit: true, padding: 30,
            animate: true, animationDuration: 300
        },
        concentric: {
            name: 'concentric', fit: true, padding: 30, startAngle: 3 / 2 * Math.PI,
            sweep: undefined, clockwise: true, equidistant: false,
            minNodeSpacing: 20, avoidOverlap: true, nodeDimensionsIncludeLabels: false,
            concentric: function( node ){ return node.degree(); }, // Level based on degree
            levelWidth: function( nodes ){ return nodes.maxDegree() / 4; }, // Dynamic level width
            animate: true, animationDuration: 500
        }
    };

    // --- Function to Apply Selected Layout ---
    function applySidebarLayout() {
        if (!sidebarCy) {
            console.log("Sidebar graph not initialized yet.");
            return;
        }
        const selectedLayoutName = document.getElementById('sidebarLayoutSelect').value;
        const layoutConfig = sidebarLayoutOptions[selectedLayoutName];

        if (!layoutConfig) {
            console.error(`Layout configuration for '${selectedLayoutName}' not found.`);
            return;
        }

        console.log(`Applying sidebar layout: ${selectedLayoutName}`);
        // Run the layout
        let layout = sidebarCy.layout(layoutConfig);
        layout.run();
        // Optional: Refit after layout animation if needed (might depend on layout behavior)
        // layout.one('layoutstop', () => {
        //     if (sidebarCy) sidebarCy.fit(null, 30); // Fit with padding
        // });
    }

    function toggleSidebar(forceOpen = null) {
        const shouldBeOpen = forceOpen !== null ? forceOpen : !isSidebarOpen;
        if (shouldBeOpen) {
            if (!isSidebarOpen) {
                sidebar.classList.add('open');
                isSidebarOpen = true;
                sidebarToggleBtn.innerHTML = '&times;';
                sidebarToggleBtn.style.left = `${sidebarWidth}px`;
                mainContainer.style.marginLeft = `${sidebarWidth}px`;
                setTimeout(() => {
                    if (sidebarCy) {
                        sidebarCy.resize();
                        // No need to fit here, layout application handles fitting
                        // sidebarCy.fit(null, 50);
                         applySidebarLayout(); // Re-apply layout on open might be desired
                    }
                }, 350);
            }
        } else {
             if (isSidebarOpen) {
                sidebar.classList.remove('open');
                isSidebarOpen = false;
                sidebarToggleBtn.innerHTML = '&#9776;';
                sidebarToggleBtn.style.left = '0px';
                mainContainer.style.marginLeft = '0px';
            }
        }
    }

    resetSidebarBtn.addEventListener('click', () => {
        console.log("Resetting sidebar view and heatmap highlights.");
        clearSidebarVisualization();
        updateLegend();
        updateHeatmap();
        selectedNodeId = null;
        document.getElementById('sidebarLayoutSelect').value = 'cose'; // Reset layout dropdown
    });

    function showSidebarLoading(isLoadingGraph, isLoadingTable) {
        document.getElementById('sidebar-cy-loading').style.display = isLoadingGraph ? 'block' : 'none';
        document.getElementById('sidebar-table-loading').style.display = isLoadingTable ? 'block' : 'none';
        const showInfo = !isLoadingGraph && !isLoadingTable && (!sidebarCy || sidebarCy.elements().length === 0) && selectedSidebarEdges.size === 0 && selectedNodeId === null;
         document.getElementById('sidebar-info').style.display = showInfo ? 'block' : 'none';
    }

    function clearSidebarVisualization() {
        if (sidebarCy) {
            sidebarCy.destroy();
            sidebarCy = null;
        }
        addedSidebarClusters.clear();
        clusterHighlightColors.clear(); // Keep this if heatmap uses it
        selectedSidebarEdges.clear();
        selectedNodeId = null;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = null;
        sidebarTableContainer.innerHTML = '';
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        document.getElementById('sidebar-cy').innerHTML = '';
        document.getElementById('sidebar-info').innerHTML = 'Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to filter the table below.';
        document.getElementById('sidebar-info').style.display = 'block';
        document.getElementById('sidebar-cy-loading').style.display = 'none';
        document.getElementById('sidebar-table-loading').style.display = 'none';
        document.getElementById('sidebarLayoutSelect').value = 'cose'; // Reset layout dropdown

        console.log("Sidebar visualization, selections, and table cleared.");
    }

    function calculateEdgeWidth(processCount) {
        const count = processCount || 1;
        const minCount = 1;
        const maxCount = 100;
        const minWidth = 1;
        const maxWidth = 10;
        const range = (maxCount - minCount) || 1;
        const width = minWidth + (maxWidth - minWidth) * ((count - minCount) / range);
        return Math.max(minWidth, Math.min(width, maxWidth));
    }

    // Cytoscape Style Configuration (Borders Removed)
    const CYTOSCAPE_STYLE = [
        { selector: 'node', style: {
            'background-color': '#888',
            'label': 'data(label)',
            'width': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'height': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'font-size': 10, 'color': '#000',
            'text-valign': 'bottom', 'text-halign': 'center', 'text-margin-y': 4,
            'border-width': 0, // No borders
            'transition-property': 'background-color',
            'transition-duration': '0.15s'
        }},
        { selector: 'edge', style: {
            'line-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-shape': 'triangle', 'curve-style': 'bezier',
            'transition-property': 'line-color, target-arrow-color, width, z-index',
            'transition-duration': '0.15s',
            'z-index': 1
        }}
    ];

    function generateUniqueHighlightColor() {
        const MIN_HUE_DIFF = 30;
        let attempts = 0;
        const existingHues = Array.from(clusterHighlightColors.values()).map(hslString => {
            const match = hslString.match(/hsl\((\d+),/);
            return match ? parseInt(match[1], 10) : -1;
        }).filter(h => h !== -1);

        while (attempts < 100) {
            let hue = Math.floor(Math.random() * 360);
            if ((hue >= 0 && hue <= 25) || (hue >= 335 && hue <= 360) || (hue >= 195 && hue <= 265)) {
                attempts++;
                continue;
            }
            let isDistinct = existingHues.every(existingHue => {
                let diff = Math.abs(hue - existingHue);
                return diff >= MIN_HUE_DIFF && (360 - diff) >= MIN_HUE_DIFF;
            });
            if (isDistinct) {
                const newColor = `hsl(${hue}, 85%, 60%)`;
                console.log(`Generated distinct color: ${newColor} (Hue: ${hue})`);
                return newColor;
            }
            attempts++;
        }
        console.warn("Could not find highly distinct color, using fallback random hue.");
        let fallbackHue;
        do {
             fallbackHue = Math.floor(Math.random() * 360);
        } while ((fallbackHue >= 0 && fallbackHue <= 25) || (fallbackHue >= 335 && fallbackHue <= 360) || (fallbackHue >= 195 && fallbackHue <= 265));
        return `hsl(${fallbackHue}, 85%, 60%)`;
    }

    function deselectCurrentNode() {
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const originalColor = node.scratch('_originalColor');
                if (originalColor) {
                    node.style('background-color', originalColor);
                } else {
                    const clusterID = node.data('clusterID');
                    const clusterColor = clusterHighlightColors.get(clusterID) || '#888';
                    node.style('background-color', clusterColor);
                    console.warn(`Missing scratch color for node ${selectedNodeId}, reverted using cluster/default color.`);
                }
                node.connectedEdges().forEach(edge => {
                    const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                    const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                    edge.style({
                        'line-color': originalEdgeColor,
                        'target-arrow-color': originalEdgeColor,
                        'width': originalEdgeWidth,
                        'z-index': 1
                    });
                });
                 console.log(`Node ${selectedNodeId} and its edges deselected.`);
            } else {
                 console.warn(`Attempted to deselect node ${selectedNodeId}, but it was not found.`);
            }
            selectedNodeId = null;
        }
        selectedSidebarEdges.clear();
    }

    function visualizeClusterInSidebar(clusterID, nodeColor) {
        if (addedSidebarClusters.has(clusterID)) {
             console.log(`Cluster ${clusterID} is already visualized.`);
             if (sidebarCy) {
                 sidebarCy.nodes(`[clusterID = "${clusterID}"]`).animate({ style: { 'opacity': 0.5 } }, { duration: 200 }).animate({ style: { 'opacity': 1 } }, { duration: 200 });
             }
             if (currentSidebarTableClusterId !== clusterID || sidebarTableMode !== 'cluster') {
                 loadSidebarClusterTable(clusterID, 1);
             }
             deselectCurrentNode();
             return;
        }

        toggleSidebar(true);
        showSidebarLoading(true, false);
        document.getElementById('sidebar-info').innerHTML = `Loading network for Cluster ${clusterID}...`;
        document.getElementById('sidebar-info').style.display = 'block';

        fetch(`${API_BASE_URL}/cluster_network?cluster_id=${clusterID}`)
             .then(response => { if (!response.ok) throw new Error(`Network error (${response.status})`); return response.json(); })
             .then(data => {
                 showSidebarLoading(false, false);

                 if (!data || (!data.nodes || data.nodes.length === 0)) {
                     console.log(`No network data for Cluster ${clusterID}.`);
                     if (!sidebarCy) {
                         sidebarCy = cytoscape({ container: document.getElementById('sidebar-cy'), style: CYTOSCAPE_STYLE });
                         bindSidebarGraphEvents();
                     }
                     addedSidebarClusters.add(clusterID);
                     loadSidebarClusterTable(clusterID, 1);
                     updateLegend(sidebarCy?.edges());
                     deselectCurrentNode();
                     return;
                 }

                 const nodesToAdd = data.nodes.map(node => ({
                     group: 'nodes',
                     data: { ...node.data, clusterID: clusterID },
                     style: { ...(node.style || {}), 'background-color': nodeColor },
                     scratch: { _originalColor: nodeColor }
                 }));

                 const edgesToAdd = data.edges.map(edge => {
                     const protocol = edge.data.Protocol || 'Unknown';
                     if (!protocolColorMap[protocol]) {
                         protocolColorMap[protocol] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                     }
                     const edgeColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                     const originalWidth = calculateEdgeWidth(edge.data.processCount);
                     return {
                         group: 'edges',
                         data: { ...edge.data, clusterID: clusterID },
                         style: { 'line-color': edgeColor, 'target-arrow-color': edgeColor, 'width': originalWidth },
                         scratch: { _protocolColor: edgeColor, _originalWidth: originalWidth }
                     };
                 });

                 if (!sidebarCy) {
                     sidebarCy = cytoscape({
                         container: document.getElementById('sidebar-cy'),
                         elements: { nodes: nodesToAdd, edges: edgesToAdd },
                         style: CYTOSCAPE_STYLE
                     });
                     bindSidebarGraphEvents();
                     applySidebarLayout(); // Apply selected layout on creation
                 } else {
                     sidebarCy.add(nodesToAdd.concat(edgesToAdd));
                     applySidebarLayout(); // Apply selected layout after adding elements
                 }

                 addedSidebarClusters.add(clusterID);
                 document.getElementById('sidebar-info').style.display = 'none';
                 updateLegend(sidebarCy.edges());
                 loadSidebarClusterTable(clusterID, 1);
                 deselectCurrentNode();

             })
             .catch(error => {
                 console.error(`Error visualizing cluster ${clusterID} in sidebar:`, error);
                 showSidebarLoading(false, false);
                 document.getElementById('sidebar-info').innerHTML = `Error loading graph data for Cluster ${clusterID}.`;
                 document.getElementById('sidebar-info').style.display = 'block';
                 loadSidebarClusterTable(clusterID, 1);
                 deselectCurrentNode();
             });
    }

    function bindSidebarGraphEvents() {
        if (!sidebarCy) return;

        sidebarCy.removeListener('mouseover'); // Keep mouseover/mouseout for tooltips
        sidebarCy.removeListener('mouseout');
        sidebarCy.removeListener('click');    // Remove previous click/tap listeners
        sidebarCy.removeListener('tap');

        sidebarCy.on('mouseover', 'node', (event) => { /* ... tooltip logic ... */ });
        sidebarCy.on('mouseover', 'edge', (event) => { /* ... tooltip logic ... */ });
        sidebarCy.on('mouseout', 'node, edge', () => { tooltip.style("display", "none"); });

        // --- Modified Click/Tap Handlers ---
        sidebarCy.on('click', 'edge', (event) => {
            if (selectedNodeId) {
                console.log("Node selection active, ignoring individual edge click.");
                return;
            }
            const edge = event.target;
            const source = edge.data('source');
            const target = edge.data('target');
            const protocol = edge.data('Protocol');
            const edgeKey = `${source}|${target}|${protocol}`;

            if (selectedSidebarEdges.has(edgeKey)) {
                selectedSidebarEdges.delete(edgeKey);
                // Reset style... (keep existing style reset)
                const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
            } else {
                selectedSidebarEdges.add(edgeKey);
                // Apply selected style... (keep existing style apply)
                edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
            }
            updateSidebarTableForSelectedEdges(); // This will now also update tree highlights
        });

        sidebarCy.on('click', 'node', (event) => {
            const clickedNode = event.target;
            const clickedNodeId = clickedNode.id();

            if (selectedSidebarEdges.size > 0) {
                // Clear individual edge selections visually and logically
                sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                    .forEach(edge => {
                        const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                        const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                        edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                    });
                selectedSidebarEdges.clear();
            }

            if (selectedNodeId === clickedNodeId) {
                // Deselecting the currently selected node
                deselectCurrentNode(); // Resets node/edge styles
                // updateSidebarTableForSelectedEdges will handle table and tree highlight clearing
            } else {
                // Selecting a new node
                deselectCurrentNode(); // Deselect previous first
                if (!clickedNode.scratch('_originalColor')) {
                    clickedNode.scratch('_originalColor', clickedNode.style('background-color'));
                }
                // Apply selected style... (keep existing style apply)
                clickedNode.style('background-color', SELECTED_NODE_COLOR);
                clickedNode.connectedEdges().forEach(edge => {
                    edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
                });
                selectedNodeId = clickedNodeId;
                console.log(`Node ${selectedNodeId} and its edges selected.`);
                // updateSidebarTableForSelectedEdges will handle table and tree highlight update
            }
            updateSidebarTableForSelectedEdges(); // Update table and tree highlights based on selection state
            document.getElementById('sidebar-info').style.display = 'none';
        });

        sidebarCy.on('tap', function(event){
            if (event.target === sidebarCy) { // Tapped on background
                let selectionCleared = false;
                if(selectedNodeId){
                    deselectCurrentNode(); // Resets node/edge styles
                    selectionCleared = true;
                } else if (selectedSidebarEdges.size > 0) {
                    // Clear visual selection for edges
                    sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                        .forEach(edge => {
                            const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                            const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                            edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                        });
                    selectedSidebarEdges.clear();
                    selectionCleared = true;
                }

                if (selectionCleared) {
                    updateSidebarTableForSelectedEdges(); // Update table (to cluster default) and clear tree highlights
                }
            }
        });
    }

    function updateSidebarTableForSelectedEdges() {
        // NOTE: clusterIdsToHighlight Set is removed

        if (selectedNodeId && sidebarCy) {
            // --- Node Selection Logic ---
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                // Get connected edges data WITHOUT collecting cluster IDs for tree highlighting
                const connectedEdgeData = node.connectedEdges().map(edge => {
                    return { source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') };
                });

                if (connectedEdgeData.length > 0) {
                    loadSidebarMultiEdgeTable(connectedEdgeData, 1); // Load table for connected edges
                } else {
                    sidebarTableContainer.innerHTML = '<p style="padding:10px; text-align:center; color:#6c757d;">Selected node has no connections.</p>';
                    sidebarTableContainer.style.display = 'block';
                    sidebarTablePagination.style.display = 'none';
                }
                document.getElementById('sidebar-info').style.display = 'none';
            } else {
                selectedNodeId = null; // Node not found, reset state
                // Fall through to edge/default logic
            }
            // --- End Node Selection Logic ---
        }

        if (!selectedNodeId && selectedSidebarEdges.size > 0) {
            // --- Individual Edge Selection Logic ---
            // Get edge list WITHOUT collecting cluster IDs for tree highlighting
            const edgeList = Array.from(selectedSidebarEdges).map(key => {
                const parts = key.split('|');
                return { source: parts[0], destination: parts[1], protocol: parts[2] };
            });
            loadSidebarMultiEdgeTable(edgeList, 1); // Load table for selected edges
            document.getElementById('sidebar-info').style.display = 'none';
            // --- End Individual Edge Selection Logic ---
        }

        if (!selectedNodeId && selectedSidebarEdges.size === 0) {
            // --- No Selection Logic ---
            if (currentSidebarTableClusterId) {
                // If a cluster was previously loaded (e.g., via heatmap click), show its table
                loadSidebarClusterTable(currentSidebarTableClusterId, 1);
                // No need to add this cluster ID for tree highlighting here
            } else {
                // Default state: Clear table, show info
                sidebarTableContainer.innerHTML = '';
                sidebarTableContainer.style.display = 'none';
                sidebarTablePagination.style.display = 'none';
                document.getElementById('sidebar-info').innerHTML = 'Click nodes or edges in the graph to filter the table below, or click a heatmap cell.';
                document.getElementById('sidebar-info').style.display = 'block';
            }
        }
    }

    function loadSidebarMultiEdgeTable(edgeList, page) {
        if (!edgeList || edgeList.length === 0) {
             updateSidebarTableForSelectedEdges();
             return;
         }
        sidebarTableMode = 'edges';
        console.log(`Loading sidebar table for ${edgeList.length} edges, page ${page}`);
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        const payload = { edges: edgeList, page: page, page_size: TABLE_PAGE_SIZE };

        fetch(`${API_BASE_URL}/get_multi_edge_table`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
        .then(response => response.ok ? response.text() : Promise.reject(`Failed multi-edge table page (${response.status})`))
        .then(html => {
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = html;
            sidebarTableContainer.style.display = 'block';
            const summaryElem = sidebarTableContainer.querySelector('#table-summary');
            if (summaryElem && summaryElem.dataset.total) {
                const total = parseInt(summaryElem.dataset.total, 10);
                 if (total > 0) {
                    sidebarTablePagination.style.display = 'block';
                    const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                    document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                    document.getElementById('sidebarCurrentPageInput').value = page;
                    document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                 } else { sidebarTablePagination.style.display = 'none'; }
            } else {
                document.getElementById('sidebarTotalPages').textContent = '?';
                document.getElementById('sidebarCurrentPageInput').value = page;
                sidebarTablePagination.style.display = 'none';
                console.warn("No table summary total found in multi-edge sidebar table response.");
            }
             sidebarTableContainer.scrollTop = 0;
        })
        .catch(error => {
            console.error("Error fetching multi-edge sidebar table:", error);
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data for selected edges.</p>`;
            sidebarTableContainer.style.display = 'block';
            sidebarTablePagination.style.display = 'none';
        });
    }

    function applyAllHeatmapHighlights() {
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill");
            if (originalColor) { cell.attr("fill", originalColor); }
        });
        clusterHighlightColors.forEach((color, clusterId) => {
            d3.selectAll('rect.cell[data-cluster="' + clusterId + '"]').attr('fill', color);
        });
     }

     function renderCombinedHeatmap(dataByMetric) {
        const orderOption = document.getElementById("rowOrderSelect").value || "descending";
        const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;
        const maxCellsPerRow = 700; // Limit max cells processed if desired
        // Ensure data is sorted *before* potential slicing
        const heatmapData = dataByMetric.map(({ metric, pivotData }) => ({
             metric,
             values: [...pivotData].sort(comparator) //.slice(0, maxCellsPerRow) // Uncomment slice if performance is an issue
        }));


        const heatmapDiv = d3.select("#heatmap");
        heatmapDiv.select("svg").remove(); // Clear previous heatmap

        if (heatmapData.length === 0 || heatmapData.every(row => row.values.length === 0)) {
            heatmapDiv.html('<p style="text-align: center; padding: 20px; color: #6c757d;">No heatmap data to display based on current filters.</p>');
            return; // Don't render if no data
        }

        // --- Dynamic Cell Width Calculation ---
        const minCellWidth = 2;
        const maxCellWidth = 10;
        const heatmapCellHeight = 15;
        const labelMargin = 150; // Space for row labels
        const rightPadding = 40; // Space right of cells
        const verticalSpace = 10; // Space between rows

        const heatmapContainerWidth = document.getElementById('heatmap').clientWidth;
        const availableWidthForCells = Math.max(0, heatmapContainerWidth - labelMargin - rightPadding);
        const maxCols = d3.max(heatmapData, r => r.values.length) || 1;
        let calculatedCellWidth = availableWidthForCells / maxCols;
        const finalCellWidth = Math.max(minCellWidth, Math.min(calculatedCellWidth, maxCellWidth));
        // --- End Dynamic Cell Width Calculation ---

        const numRows = heatmapData.length;
        const totalHeight = 20 + numRows * heatmapCellHeight + (numRows - 1) * verticalSpace + 20; // Top/bottom padding
        const svgWidth = labelMargin + maxCols * finalCellWidth + rightPadding; // Actual width needed

        const svg = heatmapDiv.append("svg")
                              .attr("width", svgWidth)
                              .attr("height", totalHeight);

        // Draw rows
        heatmapData.forEach((rowData, rowIndex) => {
            const rowY = 20 + rowIndex * (heatmapCellHeight + verticalSpace); // Top padding + row index * (cell + space)

            // Add row label (metric name)
            svg.append("text")
               .attr("x", labelMargin - 10) // Position left of cells
               .attr("y", rowY + heatmapCellHeight / 2)
               .attr("text-anchor", "end")
               .attr("alignment-baseline", "middle")
               .attr("font-size", "12px")
               .attr("fill", "black")
               .text(rowData.metric);

            // Color scale for the row
            const numericValues = rowData.values.map(d => typeof d.value === 'number' ? d.value : 0).filter(v => !isNaN(v));
            const rowMax = numericValues.length > 0 ? d3.max(numericValues) : 1;
            // Ensure domain is never [0, 0] which causes issues
            const colorDomain = [0, rowMax === 0 ? 1 : rowMax];
            const colorScale = d3.scaleSequential(d3.interpolateBlues).domain(colorDomain);

            // Draw cells within the row
            rowData.values.forEach((cellData, colIndex) => {
                const cellX = labelMargin + colIndex * finalCellWidth;
                const numericValue = typeof cellData.value === 'number' && !isNaN(cellData.value) ? cellData.value : 0;
                // Determine fill color (anomaly or scale)
                const originalFillColor = cellData.clusterAnomaly === 'anomaly' ? 'red' : colorScale(numericValue);
                // Check if this cluster is highlighted
                const initialHighlightColor = clusterHighlightColors.get(cellData.cluster);
                const initialFill = initialHighlightColor || originalFillColor; // Use highlight or original

                svg.append("rect")
                  .attr("class", "cell")
                  .attr("data-cluster", cellData.cluster)
                  .attr("data-clusteranomaly", cellData.clusterAnomaly)
                  .attr("data-metric", rowData.metric)
                  .attr("data-value", cellData.value)
                  .attr("data-original-fill", originalFillColor) // Store original color
                  .attr("x", cellX)
                  .attr("y", rowY)
                  .attr("width", finalCellWidth)
                  .attr("height", heatmapCellHeight)
                  .attr("fill", initialFill) // Set initial fill
                  .style("cursor", "pointer")
                  .on("mouseover", function (event) {
                      const d = d3.select(this);
                      const tip = tooltip.node(); // Use shorter name 'tip'

                      // Set content and make visible for measurement
                      tooltip.html(`<strong>${d.attr("data-metric")}</strong><br>Cluster: ${d.attr("data-cluster")}<br>Value: ${d.attr("data-value")}<br>Anomaly: ${d.attr("data-clusteranomaly")}`)
                             .style("display", "block")
                             .style("opacity", 1);

                      // Get dimensions using shorter names, declare together
                      const tW = tip.offsetWidth, tH = tip.offsetHeight;
                      const wW = window.innerWidth, wH = window.innerHeight;
                      const buffer = 15; // A small buffer from window edges
                      let newLeft = event.pageX + 10; // Initial position right of cursor
                      let newTop = event.pageY + 10;  // Initial position below cursor

                      // Adjust horizontal position
                      if (newLeft + tW > wW - buffer) { // If overflows right edge
                          newLeft = event.pageX - tW - 10; // Place left of cursor
                      }
                      if (newLeft < buffer) { // If overflows left edge (after potential adjustment)
                          newLeft = buffer; // Pin to left buffer
                      }

                      // Adjust vertical position
                      if (newTop + tH > wH - buffer) { // If overflows bottom edge
                          newTop = event.pageY - tH - 10; // Place above cursor
                      }
                      if (newTop < buffer) { // If overflows top edge (after potential adjustment)
                          newTop = buffer; // Pin to top buffer
                      }

                      // Apply the final calculated position
                      tooltip.style("left", newLeft + "px")
                             .style("top", newTop + "px");
                  })
                  .on("mouseout", () => {
                      // Hide tooltip on mouse out
                      tooltip.style("opacity", 0).style("display", "none");
                  })
                  .on("click", function (event) {
                      // --- Heatmap Cell Click Logic (Unchanged) ---
                      event.stopPropagation();
                      const cell = d3.select(this);
                      const clusterID = cell.attr("data-cluster");
                      const originalColor = cell.attr("data-original-fill");
                      let targetHighlightColor;

                      if (clusterHighlightColors.has(clusterID)) {
                          console.log(`Deselecting cluster ${clusterID} from heatmap.`);
                          clusterHighlightColors.delete(clusterID);
                          targetHighlightColor = originalColor; // Revert to original
                      } else {
                          console.log(`Selecting cluster ${clusterID} on heatmap.`);
                          targetHighlightColor = generateUniqueHighlightColor(); // Get new color
                          clusterHighlightColors.set(clusterID, targetHighlightColor);
                          visualizeClusterInSidebar(clusterID, targetHighlightColor); // Add to sidebar
                      }

                      // Update all cells for this cluster
                      d3.selectAll('rect.cell[data-cluster="' + clusterID + '"]')
                        .transition().duration(100)
                        .attr('fill', targetHighlightColor);

                      // Update tree highlights
                      highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                      // --- End Heatmap Cell Click Logic ---
                  });
            });
        });
    }

    function showHeatmap() {
        if (globalCy) { globalCy.destroy(); globalCy = null; }
        document.getElementById('cy').style.display = 'none';
        document.getElementById('backToHeatmap').style.display = 'none';
        document.getElementById('edgeFilterPanel').style.display = 'none';
        document.getElementById('refreshNetworkBtn').style.display = 'none';
        document.getElementById('sizeControls').style.display = 'none';
        document.getElementById('table-container').style.display = 'none';
        document.getElementById('table-pagination').style.display = 'none';
        document.getElementById('table-search-container').style.display = "none";
        document.getElementById('topControls').style.display = 'block';
        d3.select("#heatmap").style("display", "block");
        clearEdgeFilter();
        clearSidebarVisualization();
        updateLegend();
        updateHeatmap();
        toggleSidebar(false);
    }
    document.getElementById('backToHeatmap').addEventListener('click', showHeatmap);

    function showLoading() { document.getElementById('loading-overlay').style.display = 'flex'; }
    function hideLoading() { document.getElementById('loading-overlay').style.display = 'none'; }

    function updateLegend(cyEdges = null) {
         const legendTableBody = d3.select('#legend tbody');
         legendTableBody.html('');
         let protocols = new Set();
         let calculationPromise;
         let totalCount = 0;

         if (cyEdges && cyEdges.length > 0) {
             document.querySelector('#legend-container h3').textContent = "Sidebar Protocols";
             const counts = {};
             cyEdges.forEach(edge => {
                 const protocol = (edge.data('Protocol') || 'Unknown').trim(); if (!protocol) return;
                 protocols.add(protocol);
                 const count = edge.data('processCount') || 1;
                 counts[protocol] = (counts[protocol] || 0) + count;
                 totalCount += count;
             });
             totalCount = totalCount || 1;
             const percentages = {};
             Object.entries(counts).forEach(([p, c]) => { percentages[p] = (c / totalCount) * 100; });
             calculationPromise = Promise.resolve(percentages);
         } else {
              document.querySelector('#legend-container h3').textContent = "Protocol Legend";
             calculationPromise = fetch(`${API_BASE_URL}/protocol_percentages`).then(res => res.ok ? res.json() : Promise.reject('Failed global percentages')).catch(error => { console.error("Error fetching global protocol percentages:", error); return {}; });
         }

         calculationPromise.then(percentages => {
             if (!cyEdges) { Object.keys(percentages).forEach(proto => { if(proto) protocols.add(proto); }); }
             protocols.forEach(proto => { if (proto && !protocolColorMap[proto]) { protocolColorMap[proto] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0'); } });
             if (!protocolColorMap['Unknown']) { protocolColorMap['Unknown'] = DEFAULT_UNKNOWN_COLOR; }

             const sortedProtocols = Array.from(protocols).filter(p => p).sort((a, b) => (percentages[b] || 0) - (percentages[a] || 0));
             sortedProtocols.forEach(protocol => {
                 const pct = percentages[protocol] || 0;
                 const pctText = (pct > 0.01 ? pct.toFixed(2) : '<0.01') + '%';
                 const color = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                 legendTableBody.append('tr').html(`<td>${protocol}</td><td><span class="color-box" style="background-color:${color}"></span></td><td>${pctText}</td>`);
             });

             if (sidebarCy) {
                 sidebarCy.edges().forEach(edge => {
                     const protocol = edge.data('Protocol') || 'Unknown';
                     const newColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                     const nodeIsSelected = selectedNodeId && (edge.source().id() === selectedNodeId || edge.target().id() === selectedNodeId);
                     const edgeIsSelected = selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`);
                     if (!nodeIsSelected && !edgeIsSelected) { edge.style({'line-color': newColor, 'target-arrow-color': newColor}); }
                     edge.scratch('_protocolColor', newColor); // Update scratch always
                 });
             }
         });
     }

     function updateHeatmap() {
        showLoading();
        // Define the metrics to display in the heatmap
        const metrics = [
            { label: "Count", value: "count" }, { label: "Unique IPs", value: "Unique IPs" },
            { label: "Unique Sources", value: "Unique Sources" }, { label: "Unique Destinations", value: "Unique Destinations" },
            { label: "Packet Length", value: "Length" }, { label: "Payload Length", value: "Len" },
            { label: "Payload Size Variance", value: "Payload Size Variance" }, { label: "Packets per Second", value: "Packets per Second" },
            { label: "Total Data Sent", value: "Total Data Sent" }, { label: "% SYN packets", value: "% SYN packets" },
            { label: "% RST packets", value: "% RST packets" }, { label: "% ACK packets", value: "% ACK packets" },
            { label: "% PSH packets", value: "% PSH packets" }
            // Add or remove metrics here as needed
        ];
        // Get filter parameters from the UI
        const filterParamsBase = {
            payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
            sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
            destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
            protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
            entropyMin: document.getElementById('entropyMinFilter').value, entropyMax: document.getElementById('entropyMaxFilter').value,
            isLargePacketOnly: document.getElementById('isLargePacketFilter').checked, isSuspiciousAckOnly: document.getElementById('isSuspiciousAckFilter').checked,
            minSourceAmt: document.getElementById('minSourceAmtFilter').value, maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
            minDestinationAmt: document.getElementById('minDestinationAmtFilter').value, maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
        };

        // Fetch data for all metrics in parallel
        Promise.all(metrics.map(m => {
            const filterParams = { ...filterParamsBase, metric: m.value };
            return fetch(`${API_BASE_URL}/filter_and_aggregate`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(filterParams) })
                .then(response => response.ok ? response.json() : Promise.reject(`Failed ${m.label} (${response.status})`))
                .then(data => ({ metric: m.label, pivotData: data })) // Use label for keys
                .catch(error => { console.error(`Error fetching ${m.label}:`, error); return { metric: m.label, pivotData: [], error: true }; });
        }))
        .then(results => {
            // Filter out errors
            const validResults = results.filter(r => !r.error);

            // --- Store sort orders for ALL available metrics ---
            window.heatmapSortOrders = {}; // Initialize/reset
            // const availableMetrics = []; // Uncomment if dynamically populating dropdown

            const orderOption = document.getElementById("rowOrderSelect").value || "descending";
            const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;

            validResults.forEach(r => {
                const metricName = r.metric; // The label (e.g., "Count", "Unique IPs")
                if (r.pivotData && r.pivotData.length > 0) {
                     const sortedData = [...r.pivotData].sort(comparator);
                     window.heatmapSortOrders[metricName] = sortedData.map(d => d.cluster);
                    // availableMetrics.push(metricName); // Uncomment if dynamically populating
                    // console.log(`Stored sort order for ${metricName}`);
                } else {
                     window.heatmapSortOrders[metricName] = []; // Store empty if no data
                    // console.log(`No data found for metric ${metricName}`);
                }
            });

            // Keep old variable for compatibility or remove if fully transitioned
            window.heatmapCountSortOrder = window.heatmapSortOrders['Count'] || [];
            // --- End Storing Sort Orders ---

            renderCombinedHeatmap(validResults); // Render the heatmap
            hideLoading();
        })
        .catch(error => {
            console.error("Major error fetching heatmap data:", error);
            d3.select("#heatmap").html('<p style="color: red;">Error loading heatmap data.</p>');
            hideLoading();
        });
        applyAllHeatmapHighlights(); // Apply any existing highlights
    }

    function loadSidebarClusterTable(clusterID, page) {
         if (!clusterID) return;
         sidebarTableMode = 'cluster';
         currentSidebarTableClusterId = clusterID;
         console.log(`Loading sidebar table for Cluster ${clusterID}, page ${page}`);
         showSidebarLoading(false, true);
         sidebarTableContainer.style.display = 'none';
         sidebarTablePagination.style.display = 'none';

         fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
             .then(response => response.ok ? response.text() : Promise.reject(`Failed cluster table page (${response.status})`))
             .then(html => {
                 showSidebarLoading(false, false);
                 sidebarTableContainer.innerHTML = html;
                 sidebarTableContainer.style.display = 'block';
                 const summaryElem = sidebarTableContainer.querySelector('#table-summary');
                 if (summaryElem && summaryElem.dataset.total) {
                     const total = parseInt(summaryElem.dataset.total, 10);
                      if (total > 0) {
                         sidebarTablePagination.style.display = 'block';
                         const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                         document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                         document.getElementById('sidebarCurrentPageInput').value = page;
                         document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                      } else { sidebarTablePagination.style.display = 'none'; }
                 } else {
                     document.getElementById('sidebarTotalPages').textContent = '?';
                     document.getElementById('sidebarCurrentPageInput').value = page;
                     sidebarTablePagination.style.display = 'none';
                     console.warn("No table summary total found in sidebar cluster table response.");
                 }
                  sidebarTableContainer.scrollTop = 0;
             })
             .catch(error => {
                 console.error("Error fetching sidebar cluster table:", error);
                 showSidebarLoading(false, false);
                 sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                 sidebarTableContainer.style.display = 'block';
                 sidebarTablePagination.style.display = 'none';
             });
     }

    sidebarGoPageBtn.addEventListener('click', function () {
        let pageInput = document.getElementById('sidebarCurrentPageInput');
        let page = parseInt(pageInput.value, 10);
        const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
        const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);

        if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
             if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                 loadSidebarClusterTable(currentSidebarTableClusterId, page);
             } else if (sidebarTableMode === 'edges') {
                 let edgeList = [];
                 if (selectedNodeId && sidebarCy) {
                      const node = sidebarCy.getElementById(selectedNodeId);
                      if (node && node.length > 0) { edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') })); }
                 } else if (selectedSidebarEdges.size > 0) {
                      edgeList = Array.from(selectedSidebarEdges).map(key => { const parts = key.split('|'); return { source: parts[0], destination: parts[1], protocol: parts[2] }; });
                 }
                 if (edgeList.length > 0) { loadSidebarMultiEdgeTable(edgeList, page); }
                 else { console.warn("Sidebar pagination clicked in edge mode, but no edges identified as selected."); }
             } else { console.warn("Sidebar pagination clicked but current table context is unclear."); }
        } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
    });

    function loadClusterTablePage(clusterID, page) {
         currentClusterID = clusterID;
         fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
             .then(response => response.ok ? response.text() : Promise.reject(`Failed main table page (${response.status})`))
             .then(html => {
                 const container = document.getElementById('table-container');
                 container.innerHTML = html;
                 container.style.display = 'block';
                 document.getElementById('table-pagination').style.display = 'block';
                 const summaryElem = container.querySelector('#table-summary');
                 if (summaryElem && summaryElem.dataset.total) {
                     const total = parseInt(summaryElem.dataset.total, 10);
                     const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                     document.getElementById('totalPages').textContent = totalPages || 1;
                     document.getElementById('currentPageInput').value = page;
                     document.getElementById('currentPageInput').max = totalPages || 1;
                 } else {
                     document.getElementById('totalPages').textContent = '?';
                     document.getElementById('currentPageInput').value = page;
                     console.warn("No table summary total in main table response.");
                 }
                 container.scrollTop = 0;
             }).catch(error => {
                 console.error("Error fetching main cluster table:", error);
                 document.getElementById('table-container').innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                 document.getElementById('table-container').style.display = 'block';
                 document.getElementById('table-pagination').style.display = 'none';
             });
     }

    function createClusterTable(clusterID) {
        loadClusterTablePage(clusterID, 1);
        document.getElementById('table-search-container').style.display = "block";
    }

    function visualizeNetwork(elements) {
         if (globalCy) { globalCy.destroy(); }
         globalCy = cytoscape({ container: document.getElementById('cy'), elements: elements, style: CYTOSCAPE_STYLE, layout: { name: 'cose' } }); // Default layout for main graph
         applySizeControls();
     }

    function applySizeControls() {
         if (!globalCy) return;
         const minNS = Math.max(parseFloat(document.getElementById('nodeSizeMin').value) || 15, 1);
         const maxNS = Math.max(parseFloat(document.getElementById('nodeSizeMax').value) || 60, minNS + 1);
         const minEW = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 1, 0.1);
         const maxEW = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 10, minEW + 0.1);

         globalCy.batch(() => {
             globalCy.nodes().forEach(n => {
                 const weight = n.data('NodeWeight') ?? 0.5;
                 let size = minNS + (maxNS - minNS) * weight;
                 size = Math.max(minNS, Math.min(size, maxNS));
                 n.style({ 'width': size, 'height': size });
             });
             const counts = globalCy.edges().map(e => e.data('processCount') || 1);
             if (counts.length > 0) {
                 const minCount = Math.min(...counts);
                 const maxCount = Math.max(...counts);
                 const countRange = (maxCount - minCount) || 1;
                 globalCy.edges().forEach(e => {
                     const count = e.data('processCount') || 1;
                     let width = minEW + (maxEW - minEW) * ((count - minCount) / countRange);
                     width = Math.max(minEW, Math.min(width, maxEW));
                     e.style('width', width);
                 });
             }
         });
     }

    function applyEdgeFilter() {
         if (!globalCy) return;
         const sourceFilter = document.getElementById('edgeFilterSource').value.toLowerCase();
         const destFilter = document.getElementById('edgeFilterDestination').value.toLowerCase();
         const protoFilter = document.getElementById('edgeFilterProtocol').value.toLowerCase();
         const weightFilterStr = document.getElementById('edgeFilterWeight').value;
         const countFilterStr = document.getElementById('edgeFilterProcessCount').value;

         const parseFilter = (filterStr) => { const match = filterStr.match(/^([<>=!]+)?\s*(\d+(\.\d+)?)$/); if (match) { const operator = match[1] || '=='; const value = parseFloat(match[2]); return { operator, value }; } return null; };
         const weightFilter = parseFilter(weightFilterStr);
         const countFilter = parseFilter(countFilterStr);

         globalCy.edges().forEach(edge => {
             let show = true;
             const data = edge.data();
             if (sourceFilter && !data.source?.toLowerCase().includes(sourceFilter)) show = false;
             if (destFilter && !data.target?.toLowerCase().includes(destFilter)) show = false;
             if (protoFilter && !data.Protocol?.toLowerCase().includes(protoFilter)) show = false;
             if (weightFilter) { const edgeWeight = data.EdgeWeight || 0; if (weightFilter.operator === '>=' && !(edgeWeight >= weightFilter.value)) show = false; else if (weightFilter.operator === '>' && !(edgeWeight > weightFilter.value)) show = false; else if (weightFilter.operator === '<=' && !(edgeWeight <= weightFilter.value)) show = false; else if (weightFilter.operator === '<' && !(edgeWeight < weightFilter.value)) show = false; else if (weightFilter.operator === '==' && !(edgeWeight == weightFilter.value)) show = false; else if (weightFilter.operator === '!=' && !(edgeWeight != weightFilter.value)) show = false; }
             if (countFilter) { const processCount = data.processCount || 0; if (countFilter.operator === '>=' && !(processCount >= countFilter.value)) show = false; else if (countFilter.operator === '>' && !(processCount > countFilter.value)) show = false; else if (countFilter.operator === '<=' && !(processCount <= countFilter.value)) show = false; else if (countFilter.operator === '<' && !(processCount < countFilter.value)) show = false; else if (countFilter.operator === '==' && !(processCount == countFilter.value)) show = false; else if (countFilter.operator === '!=' && !(processCount != countFilter.value)) show = false; }
             edge.style('display', show ? 'element' : 'none');
         });
     }

    function resetHeatmapHighlights() {
        console.log("Resetting heatmap cell highlights.");
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) {
                cell.transition().duration(100) // Optional quick transition
                    .attr("fill", originalColor);
            } else {
                // Fallback if original color wasn't stored somehow
                cell.style("fill", null); // Let CSS/default handle it
            }
        });
    }

    function clearEdgeFilter() {
         document.getElementById('edgeFilterSource').value = '';
         document.getElementById('edgeFilterDestination').value = '';
         document.getElementById('edgeFilterProtocol').value = '';
         document.getElementById('edgeFilterWeight').value = '';
         document.getElementById('edgeFilterProcessCount').value = '';
         if(globalCy) { globalCy.edges().style('display', 'element'); }
     }

     document.addEventListener('DOMContentLoaded', () => {
        tooltip = d3.select("#tooltip");
        showHeatmap(); // Initial heatmap load attempt
        updateLegend(); // Initial legend load attempt
        loadInlineDendrogram(); // Initial tree load attempt

        // --- Listener for Cancel Loading Button ---
        const cancelLoadingButton = document.getElementById('cancelLoadingBtn');
        if (cancelLoadingButton) {
            cancelLoadingButton.addEventListener('click', () => {
                console.log("Cancel button clicked - Attempting to abort ongoing CSV processing.");
                if (csvProcessingController) {
                    csvProcessingController.abort();
                    console.log("Abort signal sent to CSV processing fetch.");
                } else {
                    console.log("No active CSV processing fetch to abort.");
                }
                hideLoading();
            });
        } else {
            console.error("Cancel loading button not found.");
        }

        // --- Listeners for Hide/Show Dendrogram Buttons ---
        const hideBtn = document.getElementById('hideTreeBtn');
        const showBtn = document.getElementById('showTreeBtn');
        if (hideBtn) { hideBtn.addEventListener('click', hideDendrogram); }
        else { console.error("Hide Tree button not found."); }
        if (showBtn) { showBtn.addEventListener('click', showDendrogram); }
        else { console.error("Show Tree button not found."); }

        // --- Listener for Sidebar Layout Selector ---
        document.getElementById('sidebarLayoutSelect').addEventListener('change', applySidebarLayout);

        // --- Listener for Main Filter Button ---
        document.getElementById('applyFiltersBtn').addEventListener('click', updateHeatmap);

        // --- Listener for Main Table Pagination Button ---
        document.getElementById('goPageBtn').addEventListener('click', function () {
             let pageInput = document.getElementById('currentPageInput');
             let page = parseInt(pageInput.value, 10);
             const totalPagesStr = document.getElementById('totalPages').textContent;
             const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
             if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity) && currentClusterID) {
                 loadClusterTablePage(currentClusterID, page);
             } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
         });

        // --- Listeners for Main Graph Size Controls ---
        document.getElementById('nodeSizeMin').addEventListener('input', applySizeControls);
        document.getElementById('nodeSizeMax').addEventListener('input', applySizeControls);
        document.getElementById('edgeWidthMin').addEventListener('input', applySizeControls);
        document.getElementById('edgeWidthMax').addEventListener('input', applySizeControls);

        // --- Listeners for Edge Filter Panel ---
        document.getElementById('applyEdgeFilterBtn').addEventListener('click', applyEdgeFilter);
        document.getElementById('clearEdgeFilterBtn').addEventListener('click', clearEdgeFilter);

        // --- Listener for File Input ---
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                if (csvProcessingController) {
                    console.log("Aborting previous CSV processing request...");
                    csvProcessingController.abort();
                }
                csvProcessingController = new AbortController();
                const signal = csvProcessingController.signal;

                showLoading();
                const reader = new FileReader();
                reader.onload = function(e) {
                    const csvText = e.target.result;
                    fetch(`${API_BASE_URL}/process_csv`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ csv_text: csvText }),
                        signal: signal
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.text().then(text => { throw new Error(text || `Processing failed (${response.status})`) });
                        }
                        return response.text();
                    })
                    .then(confirmation => {
                        console.log('CSV processed successfully');
                        csvProcessingController = null;
                        updateHeatmap();
                        updateLegend();
                        loadInlineDendrogram();
                        clearSidebarVisualization();
                        toggleSidebar(false);
                        document.getElementById('showTreeBtn').style.display = 'inline-block';
                        hideLoading();
                    })
                    .catch(error => {
                        if (error.name === 'AbortError') {
                            console.log('Fetch aborted (CSV processing cancelled by user).');
                        } else {
                            console.error('Error processing file:', error);
                            alert(`Error processing file: ${error.message}`);
                        }
                        hideLoading();
                        csvProcessingController = null;
                    });
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                    alert("Error reading file.");
                    hideLoading();
                    csvProcessingController = null;
                };
                reader.readAsText(file);
            }
            event.target.value = null;
        });

        // --- Listener for Download Button ---
        document.getElementById('downloadButton').addEventListener('click', function() {
            window.location.href = `${API_BASE_URL}/download_csv`;
        });

        // --- Listener for Sidebar Pagination ---
        sidebarGoPageBtn.addEventListener('click', function () {
            let pageInput = document.getElementById('sidebarCurrentPageInput');
            let page = parseInt(pageInput.value, 10);
            const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
            const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
            if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
                if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                    loadSidebarClusterTable(currentSidebarTableClusterId, page);
                } else if (sidebarTableMode === 'edges') {
                    let edgeList = [];
                    if (selectedNodeId && sidebarCy) { const node = sidebarCy.getElementById(selectedNodeId); if (node && node.length > 0) { edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') })); } }
                    else if (selectedSidebarEdges.size > 0) { edgeList = Array.from(selectedSidebarEdges).map(key => { const parts = key.split('|'); return { source: parts[0], destination: parts[1], protocol: parts[2] }; }); }
                    if (edgeList.length > 0) { loadSidebarMultiEdgeTable(edgeList, page); }
                    else { console.warn("Sidebar pagination clicked in edge mode, but no edges identified as selected."); }
                } else { console.warn("Sidebar pagination clicked but current table context is unclear."); }
            } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
        });

        // --- Listener for Sidebar Reset Button ---
        resetSidebarBtn.addEventListener('click', () => {
            console.log("Resetting sidebar view and associated highlights.");
            clearSidebarVisualization();
            resetHeatmapHighlights();
            highlightTreeClusters();
            selectedNodeId = null;
            document.getElementById('sidebarLayoutSelect').value = 'cose';
            updateLegend();
            console.log("Sidebar reset complete.");
        });

        // --- Listener for Sidebar Toggle Button ---
        sidebarToggleBtn.addEventListener('click', () => toggleSidebar());

        // --- Listener for Dendrogram Sort Metric Dropdown ---
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        if (metricSelect) {
            metricSelect.addEventListener('change', () => {
                if (window.lastTreeData) {
                    // Redraw using the stored height to prevent shrinking
                    console.log(`Redrawing dendrogram, ordering by: ${metricSelect.value}`);
                    showInlineDendrogram(window.lastTreeData, currentDendrogramHeight); // <<< USE STORED HEIGHT
                    resetInlineZoom()
                } else {
                     console.warn("Cannot redraw dendrogram: No tree data available (window.lastTreeData is null). Load tree first.");
                }
            });
        }
        // --- END Listener ---

    }); // End DOMContentLoaded

    // --- BEGIN Dendrogram JS Functions ---
    function showInlineDendrogram(data, svgH = 400) { // Keep default param
        currentDendrogramHeight = svgH; // <<< STORE the height being used
        document.getElementById('dendrogramCard').style.display = 'block';
        document.getElementById('showTreeBtn').style.display = 'none';

        const containerDiv = document.getElementById("inline-dendrogram-container");
        containerDiv.style.height = `${svgH}px`; // Set container height

        const svg = d3.select("#inlineDendrogramSvg");
        svg.selectAll("*").remove(); // Clear previous drawing

        if (!data || data.id === undefined || data.dist === undefined) {
            console.error("Invalid or empty tree data received:", data);
            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central")
               .text("No hierarchical data available or error loading.");
            document.getElementById("treeControls").style.display = "none";
            return;
        }

        const margin = { top: 30, right: 30, bottom: 120, left: 30 };
        const containerWidth = containerDiv.clientWidth || 600;
        // Calculate drawing height based on the passed svgH
        const height = Math.max(200, svgH - margin.top - margin.bottom);

        const root = d3.hierarchy(data); // Create hierarchy

        // --- BEGIN MANUAL LAYOUT CALCULATION ---

        // 1. Run d3.cluster() primarily to calculate DEPTH (y-coordinates)
        const initialClusterLayout = d3.cluster().size([1, height]); // Use dummy width
        initialClusterLayout(root);
        // Now all nodes 'd' have a d.y based on their depth.

        // 2. Get leaves AND the currently selected sort order
        const leaves = root.leaves();
        let sortedLeaves = [...leaves]; // Create a mutable copy

        // --- Get selected metric and corresponding order ---
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        const selectedMetric = metricSelect ? metricSelect.value : 'Count'; // Default to 'Count'
        const currentSortOrder = (window.heatmapSortOrders && window.heatmapSortOrders[selectedMetric]) ? window.heatmapSortOrders[selectedMetric] : null;
        // ---

        // 3. Sort the LEAVES array according to the selected order (if available)
        if (currentSortOrder && currentSortOrder.length > 0) {
             console.log(`Applying manual layout based on heatmap '${selectedMetric}' sort order.`);
             const orderMap = new Map(currentSortOrder.map((id, index) => [String(id), index]));

             sortedLeaves.sort((a, b) => {
                 const aClusterId = String(a.data.cluster_id).trim();
                 const bClusterId = String(b.data.cluster_id).trim();
                 const aIndex = orderMap.get(aClusterId);
                 const bIndex = orderMap.get(bClusterId);

                 if (aIndex !== undefined && bIndex !== undefined) return aIndex - bIndex;
                 if (aIndex !== undefined) return -1;
                 if (bIndex !== undefined) return 1;
                 // Fallback for leaves NOT in map (sort by ID)
                 const idA = parseInt(aClusterId, 10);
                 const idB = parseInt(bClusterId, 10);
                 if (!isNaN(idA) && !isNaN(idB)) return idA - idB;
                 return aClusterId.localeCompare(bClusterId);
             });
        } else {
             console.warn(`Sort order for metric '${selectedMetric}' unavailable, using default structural order for layout.`);
        }

        // 4. Calculate layout width based on number of leaves
        const numLeaves = sortedLeaves.length;
        const minLeafSpacing = 14;
        const requiredWidth = numLeaves * minLeafSpacing;
        const widthAvailableInContainer = Math.max(300, containerWidth - margin.left - margin.right);
        const layoutWidth = Math.max(requiredWidth, widthAvailableInContainer);

        // 5. Assign x coordinates to leaves based on the sortedLeaves array order
        const leafSpacing = numLeaves > 1 ? layoutWidth / (numLeaves - 1) : layoutWidth / 2;
        sortedLeaves.forEach((leaf, i) => {
            leaf.x = i * leafSpacing;
        });

        // 6. Recursively calculate x for internal nodes as the mean of their children's x
        root.eachAfter(node => {
            if (!node.children) return; // Skip leaves
            let childXSum = 0;
            node.children.forEach(child => { childXSum += child.x; });
            node.x = childXSum / node.children.length;
        });

        // --- END MANUAL LAYOUT CALCULATION ---


        // --- Rendering Code ---
        const viewBoxWidth = layoutWidth + margin.left + margin.right;
        const viewBoxHeight = height + margin.top + margin.bottom; // Use layout height + margins
        svg.attr("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`)
           .attr("preserveAspectRatio", "xMidYMid meet");

        const svgContent = svg.append("g"); // Group for SVG content (for zoom)

        // Draw Links
        svgContent.selectAll(".link")
            .data(root.links())
            .join("path")
            .attr("class", "link")
            .attr("d", d => `M${d.source.x},${d.source.y}V${(d.source.y + d.target.y) / 2}H${d.target.x}V${d.target.y}`)
            .attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 1.5);

        // Draw Node groups
        const node = svgContent.selectAll(".node")
            .data(root.descendants())
            .join("g")
            .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
            .attr("transform", d => `translate(${d.x},${d.y})`);

        // Draw Circles
        node.append("circle").attr("r", 4).attr("fill", d => d.children ? "#555" : "#999");

        // Draw Labels (Restoring Rotation)
        node.append("text")
            .attr("dy", "0.31em")
            .attr("y", d => d.children ? -10 : 10) // Offset labels from node circle
            .attr("text-anchor", d => d.children ? "middle" : "start") // Anchor middle for internal, start for leaves before rotation
            .attr("font-size", "9px")
            .attr("fill", "#333")
            .text(d => d.data.id || "") // Use node ID (e.g., "Cluster X") for label
            .style("user-select", "none")
            // Apply transform only to leaf nodes using .filter()
            .filter(d => !d.children)
                .attr("transform", "translate(4, 0) rotate(45)"); // Apply rotation and slight offset


        // --- Zoom and Controls ---
        let dx = margin.left;
        let dy = margin.top;
        let initialScale = 1;
        // Calculate initial transform for centering/fitting (optional refinement)
        try {
            const bounds = svgContent.node().getBBox();
            if (bounds.width > 0 && bounds.height > 0) {
                 dx = (containerWidth / initialScale - bounds.width) / 2 - bounds.x / initialScale + (margin.left / initialScale);
                 dy = margin.top / initialScale;
           }
        } catch (e) { console.error("Error calculating tree bounds for initial zoom:", e); }
        initialTreeTransform = d3.zoomIdentity.translate(dx, dy).scale(initialScale);

        // Setup and Apply Zoom
        const zoomBehavior = d3.zoom()
            .scaleExtent([0.05, 10]) // Set zoom scale limits
            .on("zoom", (event) => {
                svgContent.attr("transform", event.transform); // Apply zoom transform to content group
            });
        window.inlineZoom = zoomBehavior; // Store zoom behavior reference
        svg.call(zoomBehavior) // Apply zoom behavior to the main SVG element
           .call(zoomBehavior.transform, initialTreeTransform) // Set initial zoom state
           .on("dblclick.zoom", () => { // Reset zoom on double-click
               svg.transition().duration(500).call(zoomBehavior.transform, initialTreeTransform);
           });

        document.getElementById("treeControls").style.display = "flex"; // Show controls
        window.lastTreeData = data; // Store data for redraws
        highlightTreeClusters(new Set(clusterHighlightColors.keys())); // Apply any existing highlights
    }

    function highlightTreeClusters(selectedClusterIds = new Set()) {
        const svgContent = d3.select("#inlineDendrogramSvg g");
        if (svgContent.empty()) {
            return; // Tree not rendered yet
        }

        const leafNodes = svgContent.selectAll(".node--leaf"); // Select the group containing circle and text
        const leafCircles = leafNodes.select("circle");
        const leafTexts = leafNodes.select("text");
        const defaultTextColor = "#333"; // Default text color

        // Reset all leaves first
        leafCircles.classed("highlighted", false)
                  .transition().duration(150)
                  .attr("r", 4) // Default radius
                  .style("fill", "#999") // Default leaf circle color
                  .style("stroke", "none");

        leafTexts.transition().duration(150)
                .style("fill", defaultTextColor) // Reset text color
                .style("font-weight", "normal"); // Reset font weight

        // Apply highlights based on the provided set and stored colors
        if (selectedClusterIds.size > 0) {
            selectedClusterIds.forEach(clusterId => {
                const stringClusterId = String(clusterId); // Ensure string comparison
                // Get the correct highlight color from the global map
                const highlightColor = clusterHighlightColors.get(stringClusterId);

                if (highlightColor) { // Only highlight if found in the map
                    // Find the matching leaf node(s)
                    const matchedNodes = leafNodes.filter(function(d) {
                        return d && d.data && String(d.data.cluster_id) === stringClusterId;
                    });

                    // Highlight the circle
                    matchedNodes.select("circle")
                        .classed("highlighted", true)
                        .transition().duration(150)
                        .attr("r", 6) // Highlighted radius
                        .style("fill", highlightColor) // Use the specific highlight color from map
                        .style("stroke", "none");

                    // --- Modify Text Color ---
                    try {
                        // Parse the highlight color (assuming HSL format like "hsl(H, S%, L%)")
                        let color = d3.hsl(highlightColor);

                        // Lower saturation (e.g., reduce by 40%, ensure it's between 0 and 1)
                        color.s = Math.max(0, Math.min(1, color.s * 0.6));

                        // Optional: Slightly increase lightness for readability, especially if saturation is low
                        if (color.s < 0.3) {
                            color.l = Math.min(1, color.l + 0.1);
                        }
                        // Ensure lightness isn't too high (avoid white on white)
                        color.l = Math.min(0.85, color.l);

                        const textColor = color.toString(); // Convert back to string

                        // Apply the modified color to the text
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", textColor)
                            .style("font-weight", "bold"); // Make text bold for emphasis

                    } catch (e) {
                        console.error("Could not parse highlight color for text:", highlightColor, e);
                        // Fallback: Apply a default highlight color to text if parsing fails
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", "#d95f02") // Fallback color (dark orange)
                            .style("font-weight", "bold");
                    }
                    // --- End Text Color Modification ---

                } else {
                    console.warn(`Highlight color not found in map for cluster ${stringClusterId}`);
                }
            });
        }
    }

    function hideDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'none';
        showButton.style.display = 'inline-block'; // Show the 'Show Tree' button
        console.log("Dendrogram hidden.");
    }

    function showDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'block';    // Show the card
        showButton.style.display = 'none'; // Hide the 'Show Tree' button

        // Optional: Reload or redraw if needed when shown
        if (!window.lastTreeData) {
            console.log("No tree data, loading...");
            loadInlineDendrogram(); // Load data if it wasn't loaded before
        } else {
            console.log("Showing existing dendrogram.");
            // You could potentially redraw or fit view here if desired
            // showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight);
            // resetInlineZoom();
        }
    }
    
    // Optional Helper Function to fit view (Example)
    function fitView() {
        const svg = d3.select("#inlineDendrogramSvg");
        const svgContent = svg.select("g"); // Assumes content is in the first 'g'
        if (!svgContent.empty() && window.inlineZoom) {
            const bounds = svgContent.node().getBBox();
            const parent = svg.node();
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width === 0 || height === 0) return; // Nothing to fit

            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

            svg.transition().duration(750).call(
                window.inlineZoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }
    }

    // Make sure the resetInlineZoom function still uses d3.zoomIdentity
    function resetInlineZoom() {
        const svg = d3.select("#inlineDendrogramSvg");
        if (window.inlineZoom) {
            // Reset zoom with a smooth transition TO THE STORED INITIAL CENTERED TRANSFORM
            svg.transition().duration(500)
                .call(window.inlineZoom.transform, initialTreeTransform);
            console.log("Inline dendrogram zoom reset to initial view.");
        } else {
            console.warn("Cannot reset zoom, zoom behavior not initialized.");
        }
    }

    function loadInlineDendrogram() {
      console.log("Attempting to load inline dendrogram data...");
      fetch(`${API_BASE_URL}/hierarchical_clusters`) // Use API_BASE_URL
          .then(response => {
              if (!response.ok) {
                  return response.text().then(text => { throw new Error(text || `HTTP error ${response.status}`) });
              }
              return response.json();
            })
          .then(data => {
              console.log("Dendrogram data received:", data);
              if (Object.keys(data).length === 0 || (data.error)) {
                  console.error("Empty or error data received for dendrogram.");
                  showInlineDendrogram(null); // Show error state
              } else {
                    showInlineDendrogram(data); // Render the tree
              }
          })
          .catch(err => {
              console.error("Failed to load or render inline dendrogram:", err);
                showInlineDendrogram(null); // Show error state in the SVG
          });
    }


    function reclusterAndRedraw() {
      const resolutionInput = document.getElementById('resolutionInput');
      const resolution = parseFloat(resolutionInput.value);
      const messageDiv = document.getElementById('reclusterMessage');

      if (isNaN(resolution) || resolution <= 0) {
          messageDiv.textContent = "Please enter a valid resolution > 0.";
          resolutionInput.focus();
          return;
      }

      messageDiv.textContent = "Applying resolution and reclustering..."; // Loading message
      console.log(`Requesting recluster with resolution: ${resolution}`);

      // Fetch new hierarchy data with the specified resolution
      fetch(`${API_BASE_URL}/hierarchical_clusters?resolution=${resolution}`)
          .then(response => {
                if (!response.ok) { return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) }); }
                return response.json();
          })
          .then(treeData => {
                console.log("Reclustered tree data received:", treeData);

              // Check for structural changes to provide feedback
                let currentLeafCount = 0;
                (function countLeaves(node) {
                    if (!node || typeof node !== 'object') return;
                    if (!node.children || node.children.length === 0) currentLeafCount++;
                    else node.children.forEach(countLeaves);
                })(treeData);

                const currentHash = JSON.stringify(treeData); // Basic structural hash

                const structureChanged = (
                    previousClusterCount === null ||
                    currentLeafCount !== previousClusterCount ||
                    currentHash !== previousClusterHash
                );

                previousClusterCount = currentLeafCount; // Update state
                previousClusterHash = currentHash;      // Update state

                if (structureChanged) {
                    messageDiv.textContent = `Reclustering complete. ${currentLeafCount} leaf clusters found.`;
                    showInlineDendrogram(treeData); // Redraw the dendrogram
                    resetInlineZoom(); // Reset zoom after redraw

                    // --- IMPORTANT: Update the main heatmap view ---
                    console.log("Updating heatmap after recluster...");
                    updateHeatmap(); // This should use the updated cluster IDs from the backend
                    updateLegend(); // Also update legend
                    // --- End Heatmap Update ---

                } else {
                    messageDiv.textContent = "No structural change in clusters. Try a different resolution.";
                }
          })
          .catch(err => {
              console.error("Error during recluster/redraw:", err);
              messageDiv.textContent = `Error: ${err.message || "Failed to recluster."}`;
          });
    }

    function showCustomHeightInput() {
        // Use the stored height for the prompt default
        const customHeight = prompt(`Enter desired tree height in pixels (current: ${currentDendrogramHeight}):`, `${currentDendrogramHeight}`);
        if (customHeight !== null) { // Check if user pressed cancel
            const val = parseInt(customHeight, 10);
            if (!isNaN(val) && val > 50 && val < 5000) { // Basic validation
                if (window.lastTreeData) {
                      currentDendrogramHeight = val; // <<< STORE the new custom height
                      // Redraw using the stored tree data and the new height
                      showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                      console.log(`Tree height set to custom value: ${val}px`);
                } else {
                      console.warn("Cannot set custom height, no tree data available.");
                      // If you want the container to resize even without data:
                      // document.getElementById("inline-dendrogram-container").style.height = `${val}px`;
                      // currentDendrogramHeight = val;
                }
            } else {
                alert("Invalid height entered. Please enter a number (e.g., 500).");
            }
        }
    }

    function resetInlineZoom() {
      const svg = d3.select("#inlineDendrogramSvg");
      if (window.inlineZoom) {
          // Reset zoom with a smooth transition
          svg.transition().duration(500)
              .call(window.inlineZoom.transform, d3.zoomIdentity);
            console.log("Inline dendrogram zoom reset.");
      } else {
          console.warn("Cannot reset zoom, zoom behavior not initialized.");
      }
    }

    // --- END Dendrogram JS Functions ---
  </script>
</body>
</html>