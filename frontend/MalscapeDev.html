<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MalScape</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; color: #333; background-color: #f8f9fa; overflow-x: hidden; }
        body { display: flex; }

        #sidebar {
            width: 0;
            height: 100vh;
            background-color: #f1f3f5;
            border-right: 1px solid #dee2e6;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.3s ease, padding 0.3s ease;
            position: fixed;
            top: 0;
            left: 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1100;
            display: flex;
            flex-direction: column;
        }
        #sidebar.open {
            width: 500px;
            padding: 20px;
        }
        #sidebar-content {
            opacity: 0;
            transition: opacity 0.3s ease 0.1s;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #sidebar.open #sidebar-content {
            opacity: 1;
            overflow: visible;
        }
        #sidebar-cy {
            width: 100%;
            height: 40%;
            min-height: 250px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background-color: #fff;
            margin-top: 10px;
            flex-shrink: 0;
        }

        #sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            z-index: 1200;
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 15px 8px;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, left 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        #sidebar-toggle:hover {
            background-color: #3182ce;
        }

        #main-container {
            flex: 1;
            padding: 24px;
            height: 100vh;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            margin-left: 0; /* Keep existing margin-left */
            padding-left: 40px; /* Keep existing padding-left */
            margin-right: 230px; /* ADDED: Legend width (220px) + buffer (10px) */
        }

        #nodeSizeMin, #nodeSizeMax, #edgeWidthMin, #edgeWidthMax { width: 200px; }
        #legend-container { width: 220px; background-color: #fff; border-left: 1px solid #e9ecef; padding: 16px 12px; height: 100vh; overflow-y: auto; box-shadow: -4px 0 8px rgba(0,0,0,0.05); position: fixed; right: 0; top: 0; z-index: 1000; }
        h2 { color: #2c3e50; margin-top: 0; margin-bottom: 24px; font-size: 28px; font-weight: 600; border-bottom: 2px solid #4299e1; padding-bottom: 8px; display: inline-block; }
        h3 { color: #2c3e50; font-size: 16px; margin-top: 0; margin-bottom: 12px; font-weight: 600; }
        #sidebar h3 { font-size: 18px; margin-bottom: 10px; flex-shrink: 0; }

        .control-group { margin-bottom: 20px; padding: 16px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .sidebar-control {
            padding: 8px 0;
            margin-bottom: 5px;
            background: none;
            box-shadow: none;
            border-radius: 0;
        }
        .sidebar-control label {
            font-size: 13px;
            margin-right: 5px;
        }

        label { display: inline-block; margin-right: 8px; font-weight: 500; color: #4a5568; }
        input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] { padding: 8px 12px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; margin-right: 12px; margin-bottom: 8px; transition: border-color 0.2s; }
        input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus { border-color: #4299e1; outline: none; box-shadow: 0 0 0 3px rgba(66,153,225,0.15); }
        button { background-color: #4299e1; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s; margin-right: 8px; }
        button:hover { background-color: #3182ce; }
        #loadMoreBtn { display: none; margin-top: 16px; background-color: #38a169; }
        #loadMoreBtn:hover { background-color: #2f855a; }
        #cy { width: 100%; height: 600px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-top: 24px; margin-bottom: 24px; background-color: #fff; display: none; }

        #table-container { margin-top: 24px; margin-bottom: 24px; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: none; max-height: 300px; overflow-y: auto; }
        #table-container table { width: 100%; border-collapse: collapse; table-layout: auto; }
        #table-container th, #table-container td { padding: 12px 15px; border-bottom: 1px solid #e9ecef; text-align: left; white-space: nowrap; }
        #table-pagination { display: none; margin-top: 8px; text-align: center; }
        #table-pagination input { width: 60px; text-align: center; }

        #tooltip { position: absolute; display: none; background: rgba(255, 255, 255, 0.95); border-radius: 4px; padding: 8px 12px; font-size: 13px; color: #2d3748; pointer-events: none; z-index: 2000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px; line-height: 1.5; border: 1px solid #dee2e6; }
        .color-box { display: inline-block; width: 12px; height: 12px; vertical-align: middle; margin-right: 4px; border: 1px solid #ccc; }
        #legend { font-size: 12px; line-height: 1.4; table-layout: fixed; width: 100%;}
        #legend th, #legend td { padding: 4px 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        #legend td:first-child, #legend th:first-child { width: 45%; }
        #legend td:nth-child(2), #legend th:nth-child(2) { width: 25%; }
        #legend td:last-child, #legend th:last-child { width: 30%; text-align: right;}
        #backToHeatmap { margin: 20px 0; padding: 8px 16px; font-size: 14px; display: none; }
        #edgeFilterPanel { position: absolute; top: 80px; right: 260px; width: 320px; padding: 12px; background-color: #fff; border: 1px solid #e2e8f0; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); display: none; z-index: 999; }
        #edgeFilterPanel h4 { margin-top: 0; margin-bottom: 8px; font-size: 16px; font-weight: 600; color: #2c3e50; }
        #edgeFilterPanel label { display: block; margin-top: 8px; font-weight: 500; color: #4a5568; }
        #edgeFilterPanel input { margin-bottom: 8px; width: 100%; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4299e1; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 16px; }
        .loading-text { font-size: 18px; color: #333; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #resetSidebarBtn { background-color: #6c757d; margin-top: 5px; margin-bottom: 10px; width: 100%; flex-shrink: 0; }
        #resetSidebarBtn:hover { background-color: #5a6268; }

        #sidebar-table-container {
            margin-top: 15px;
            flex-grow: 1;
            overflow: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: #fff;
            display: none;
        }
        #sidebar-table-container table {
            font-size: 11px;
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }
        #sidebar-table-container th {
            background-color: #f1f3f5;
            padding: 8px 10px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom: 2px solid #dee2e6;
            font-weight: 600;
            white-space: nowrap;
        }
        #sidebar-table-container td {
            padding: 8px 10px;
            white-space: normal;
            word-break: break-word;
            border: none;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
            line-height: 1.4;
        }
        #sidebar-table-container tr:last-child td { border-bottom: none; }
        #sidebar-table-container tbody tr:nth-child(even) { background-color: #f8f9fa; }
        #sidebar-table-container tbody tr:hover { background-color: #e9ecef; }

        #sidebar-table-container th,
        #sidebar-table-container td {
          min-width: 150px;
          word-break: break-word;
        }
        #sidebar-table-pagination {
            text-align: center;
            margin-top: 8px;
            display: none;
            flex-shrink: 0;
        }
        #sidebar-table-pagination button { padding: 4px 8px; font-size: 12px; }
        #sidebar-table-pagination input { width: 45px; font-size: 12px; padding: 4px 6px; }

        #loading-overlay .cancel-button {
            margin-top: 20px; /* Space below the loading text */
            padding: 8px 16px;
            font-size: 14px;
            background-color: #dc3545; /* Red color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #loading-overlay .cancel-button:hover {
            background-color: #c82333;
        }

        /* --- BEGIN ADDED Dendrogram CSS --- */
        #dendrogramCard {
            /* Styles copied from MalscapeDev - Copy.html */
            display: none; /* Initially hidden */
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0; /* Added margin */
            border: 1px solid #e2e8f0; /* Added subtle border */
        }
        #inline-dendrogram-container {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-bottom: 10px; /* Reduced margin */
            width: 100%;
            height: 400px; /* Default height */
            overflow: hidden; /* Needed for SVG zoom/pan */
            border: 1px solid #dee2e6; /* Added border */
            border-radius: 6px; /* Added radius */
            position: relative; /* For positioning controls or overlays if needed */
        }
        #inlineDendrogramSvg {
            /* Styles copied from MalscapeDev - Copy.html */
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab; /* Indicate draggable */
        }
        #inlineDendrogramSvg:active {
            cursor: grabbing;
        }
        #treeControls {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #treeControls label {
            margin-bottom: 0; /* Align with inputs */
        }
        #treeControls input[type="number"] {
            /* Styles copied from MalscapeDev - Copy.html */
            margin-bottom: 0;
            vertical-align: middle;
            width: 70px; /* Adjust width */
            padding: 6px 8px; /* Adjust padding */
        }
        #treeControls button {
            padding: 6px 12px; /* Adjust padding */
        }
        #treeControls select {
            padding-top: 6px;
            padding-bottom: 6px;
            padding-left: 8px;
            padding-right: 8px;
            margin-bottom: 0;
        }
        #reclusterMessage {
            /* Styles copied from MalscapeDev - Copy.html */
            color: #e53e3e; /* Use a red color */
            font-size: 13px;
            margin-top: 8px;
            font-weight: 500;
        }
        /* Adjustments for button groups */
        .tree-height-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto; /* Push height controls to the right */
        }
        .tree-height-controls button {
            background: none;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 4px 10px;
        }
        .tree-height-controls button:hover {
            background-color: #edf2f7;
            border-color: #a0aec0;
        }
        .custom-height-link {
            background: none;
            border: none;
            color: #4299e1; /* Link color */
            cursor: pointer;
            font-size: 13px;
            text-decoration: underline;
            padding: 0;
            margin-left: 5px;
        }
        .custom-height-link:hover {
            color: #3182ce;
        }
            .show-tree-button {
            padding: 6px 12px;
            font-size: 14px;
            background-color: #28a745; /* Green color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .show-tree-button:hover {
            background-color: #218838;
        }

        /* Style for the existing Hide Tree button */
        .small-utility-button {
            padding: 3px 8px;
            font-size: 12px;
            background-color: #6c757d; /* Grey color */
            /* ... keep other existing styles for .small-utility-button ... */
            border-radius: 4px;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .small-utility-button:hover {
            background-color: #5a6268;
        }
        .node--leaf circle.highlighted {
            fill: #ff7f0e; /* Orange color for highlight - Use specific color from map now */
            r: 6; /* Slightly larger radius */
        }
        .node.grayed-out > circle {
            fill: #d3d3d3 !important; /* Light gray */
            stroke: #bbb !important;
            opacity: 0.6;
        }

        .node.grayed-out > text {
            fill: #aaa !important; /* Lighter gray for text */
            opacity: 0.7;
        }
        /* --- END ADDED Dendrogram CSS --- */
    </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
    <button id="cancelLoadingBtn" class="cancel-button">Cancel</button>
  </div>

  <button id="sidebar-toggle">&#9776;</button>

  <div id="sidebar">
      <div id="sidebar-content">
          <h3>Cluster Visualization</h3>
          <button id="resetSidebarBtn">Reset Node Selection</button>

          <div class="control-group sidebar-control">
              <label for="sidebarLayoutSelect">Layout:</label>
              <select id="sidebarLayoutSelect" style="padding: 4px 8px; font-size: 12px; max-width: 150px;">
                  <option value="cose" selected>Cose (Default)</option>
                  <option value="breadthfirst">Hierarchical</option>
                  <option value="circle">Circle</option>
                  <option value="grid">Grid</option>
                  <option value="concentric">Concentric</option>
                  <option value="random">Random</option>
              </select>
          </div>

          <div id="sidebar-cy-loading" style="display: none; text-align: center; margin-top: 5px; color: #6c757d;">Loading graph...</div>
          <div id="sidebar-cy"></div>
          <div id="sidebar-info" style="margin-top: 10px; font-size: 14px; text-align: center; flex-shrink: 0;">Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.</div>
          <div id="sidebar-table-loading" style="display: none; text-align: center; margin-top: 20px; color: #6c757d;">Loading table...</div>
          <div id="sidebar-table-container"></div>
          <div id="sidebar-table-pagination">
              <span>Page <input type="number" id="sidebarCurrentPageInput" value="1" min="1" style="width:45px;"> of <span id="sidebarTotalPages">?</span></span>
              <button id="sidebarGoPageBtn">Go</button>
          </div>
      </div>
  </div>

  <div id="main-container">
    <h2>MalScape</h2>
    <div id="topControls">
      <div style="margin-bottom: 16px; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <label for="fileInput"><strong>Upload CSV File:</strong></label>
        <input type="file" id="fileInput" accept=".csv">
        <button id="downloadButton">Download Processed CSV File</button>
      </div>
      <div class="control-group">
        <label for="rowOrderSelect">Order Cells By:</label>
        <select id="rowOrderSelect"> <option value="descending">Descending</option> <option value="ascending">Ascending</option> </select>
        <label for="minSourceAmtFilter">Min Src:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="1" step="1" style="width:60px;">
        <label for="maxSourceAmtFilter">Max Src:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="Inf" step="1" style="width:60px;">
        <label for="minDestinationAmtFilter">Min Dst:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="1" step="1" style="width:60px;">
        <label for="maxDestinationAmtFilter">Max Dst:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="Inf" step="1" style="width:60px;">
        <label for="payloadSearch">Payload:</label>
        <input type="text" id="payloadSearch" placeholder="Keyword" style="width:100px;">
        <label for="sourceFilter">Src IP:</label>
        <input type="text" id="sourceFilter" placeholder="IP" style="width:100px;">
        <label for="destinationFilter">Dst IP:</label>
        <input type="text" id="destinationFilter" placeholder="IP" style="width:100px;">
        <label for="protocolFilter">Proto:</label>
        <input type="text" id="protocolFilter" placeholder="TCP" style="width:60px;">
        <label for="entropyMinFilter">Min Ent:</label>
        <input type="number" id="entropyMinFilter" placeholder="0.0" step="0.1" style="width:60px;">
        <label for="entropyMaxFilter">Max Ent:</label>
        <input type="number" id="entropyMaxFilter" placeholder="Inf" step="0.1" style="width:60px;">
        <label for="isLargePacketFilter">Large Pkts:</label>
        <input type="checkbox" id="isLargePacketFilter">
        <label for="isSuspiciousAckFilter">Susp ACK:</label>
        <input type="checkbox" id="isSuspiciousAckFilter">
        <button id="applyFiltersBtn" style="margin-left: 10px;">Apply Filters</button>
      </div>
    </div>
    <button id="showTreeBtn" class="show-tree-button" style="display: none; margin-bottom: 15px;">Show Hierarchical Cluster Tree</button>
    <div id="dendrogramCard">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div> <h3>Hierarchical Cluster Tree</h3>
              <span id="treeInfoSpan" style="font-size: 12px; color: #555; margin-left: 10px;"></span>
              <span id="timeInfoSpan" style="font-size: 12px; color: #555; margin-left: 15px;"></span> </div>
            <button id="hideTreeBtn" class="small-utility-button">Hide Tree</button>
          </div>
      <div id="inline-dendrogram-container">
        <svg id="inlineDendrogramSvg"></svg>
      </div>
      <div id="treeControls">
        <label for="dendrogramSortMetricSelect">Order Leaves By:</label>
        <select id="dendrogramSortMetricSelect">
            <option value="Default" selected>Default (Structure)</option> <option value="Count">Count</option>
            <option value="Unique IPs">Unique IPs</option>
            <option value="Unique Sources">Unique Sources</option>
            <option value="Unique Destinations">Unique Destinations</option>
            <option value="Payload Size Variance">Payload Size Variance</option>
            <option value="Packets per Second">Packets per Second</option>
            <option value="Total Data Sent">Total Data Sent</option>
            <option value="% SYN packets">% SYN packets</option>
            <option value="% RST packets">% RST packets</option>
            <option value="% ACK packets">% ACK packets</option>
            <option value="% PSH packets">% PSH packets</option>
            <option value="Length">Packet Length</option>
            <option value="Len">Payload Length</option>
        </select>
        <label for="resolutionInput">Louvain Resolution:</label>
        <input type="number" id="resolutionInput" value="2.5" step="0.1" min="0.1" placeholder="default 2.5">
        <button onclick="reclusterAndRedraw()">Apply Resolution</button>
        <button onclick="resetInlineZoom()">Reset Zoom</button>
        <label for="thresholdSlider">Visual Threshold:</label>
        <input type="range" id="thresholdSlider" min="0" max="100" value="100" style="width: 150px; vertical-align: middle;">
        <span id="thresholdValue">100%</span>
        <div class="tree-height-controls">
          <button class="custom-height-link" onclick="showCustomHeightInput()">Set Custom Height</button>
        </div>
        <div id="reclusterMessage" style="width: 100%; margin-top: 5px;"></div>
      </div>
    </div>
    <div id="heatmap"></div>
    <div id="table-search-container" style="display:none; margin-bottom: 12px; margin-top: 24px;">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>
    <div id="table-container"></div>
    <div id="table-pagination">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
    <div style="margin-top: 20px;">
        <button id="loadMoreBtn">Load More</button>
        <button id="backToHeatmap">Back to Heatmap</button>
        <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;">Refresh Network</button>
    </div>
    <div id="sizeControls" style="display: none; margin-top: 16px;">
      <label for="edgeWidthMin">Min Edge Width:</label>
      <input type="number" id="edgeWidthMin" placeholder="1" step="0.1" min="0.1" value="1">
      <label for="edgeWidthMax">Max Edge Width:</label>
      <input type="number" id="edgeWidthMax" placeholder="10" step="0.1" min="0.1" value="10">
      <label for="nodeSizeMin">Min Node Size:</label>
      <input type="number" id="nodeSizeMin" placeholder="15" step="1" min="1" value="15">
      <label for="nodeSizeMax">Max Node Size:</label>
      <input type="number" id="nodeSizeMax" placeholder="60" step="1" min="1" value="60">
    </div>
    <div id="cy"></div>
  </div>

  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <thead><tr><th>Protocol</th><th>Color</th><th>Process %</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="edgeFilterPanel">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label> <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label> <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label> <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label> <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label> <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn">Filter Edges</button> <button id="clearEdgeFilterBtn">Clear Filter</button>
  </div>

  <div id="tooltip"></div>

  <script>
    const API_BASE_URL = 'http://127.0.0.1:5000';
    const DEFAULT_UNKNOWN_COLOR = '#cccccc';
    const SELECTED_EDGE_COLOR = '#ff0000'; // Red
    const SELECTED_NODE_COLOR = '#ff0000'; // Red
    const SELECTED_EDGE_WIDTH = 3.5;
    const SELECTED_EDGE_ZINDEX = 999;
    
    let previousClusterCount = null; // dendrogram change detection
    let previousClusterHash = null; // dendrogram change detection
    let treeHeightExpanded = false; // endrogram height toggle
    let customTreeHeightActive = false; // dendrogram custom height
    window.lastTreeData = null; // store dendrogram data
    window.inlineZoom = null; // store zoom behavior
    let csvProcessingController = null; // Controller to abort CSV processing fetch
    let initialTreeTransform = d3.zoomIdentity;
    let currentDendrogramHeight = 400; // Default height
    const margin = { top: 30, right: 30, bottom: 120, left: 30 };

    let protocolColorMap = {};
    let globalCy; // For main #cy element, if used
    let sidebarCy; // For #sidebar-cy element
    let currentClusterID = null; // Cluster ID shown in main table/graph
    let currentSidebarTableClusterId = null; // Cluster ID shown in sidebar table (cluster mode)
    const TABLE_PAGE_SIZE = 30;
    const heatmapCellWidth = 2;
    const heatmapCellHeight = 15;
    let tooltip;
    let clusterHighlightColors = new Map(); // Maps clusterID -> highlight color for heatmap/nodes
    let addedSidebarClusters = new Set(); // Tracks clusterIDs added to sidebar graph
    let selectedSidebarEdges = new Set(); // Tracks individually selected edges (edgeKey format)
    let selectedNodeId = null; // Tracks ID of the currently selected node in sidebar graph
    let sidebarTableMode = 'cluster'; // 'cluster' or 'edges'
    let isSidebarOpen = false;
    let sidebarWidth = 500;

    const sidebar = document.getElementById('sidebar');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle');
    const mainContainer = document.getElementById('main-container');
    const resetSidebarBtn = document.getElementById('resetSidebarBtn');
    const sidebarTableContainer = document.getElementById('sidebar-table-container');
    const sidebarTablePagination = document.getElementById('sidebar-table-pagination');
    const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');

    // --- Layout Options Definitions ---
    const sidebarLayoutOptions = {
        cose: {
            name: 'cose', animate: true, animationDuration: 500, padding: 30,
            idealEdgeLength: 100, nodeRepulsion: node => node.degree() * 15000,
            edgeElasticity: edge => 100, gravity: 60, numIter: 1000,
            initialTemp: 200, coolingFactor: 0.95, minTemp: 1.0, fit: true
        },
        breadthfirst: {
            name: 'breadthfirst', directed: true, padding: 20, circle: false,
            grid: false, spacingFactor: 1.4, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, roots: undefined,
            animate: true, animationDuration: 500, fit: true
        },
        circle: {
            name: 'circle', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1.2, radius: undefined,
            startAngle: 3/2 * Math.PI,
            animate: true, animationDuration: 500, fit: true
        },
        grid: {
            name: 'grid', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1,
            rows: undefined, cols: undefined,
            position: function( node ){},
            animate: true, animationDuration: 500, fit: true
        },
        random: {
            name: 'random', fit: true, padding: 30,
            animate: true, animationDuration: 300
        },
        concentric: {
            name: 'concentric', fit: true, padding: 30, startAngle: 3 / 2 * Math.PI,
            sweep: undefined, clockwise: true, equidistant: false,
            minNodeSpacing: 20, avoidOverlap: true, nodeDimensionsIncludeLabels: false,
            concentric: function( node ){ return node.degree(); }, // Level based on degree
            levelWidth: function( nodes ){ return nodes.maxDegree() / 4; }, // Dynamic level width
            animate: true, animationDuration: 500
        }
    };

    // --- Function to Apply Selected Layout ---
    function applySidebarLayout() {
        if (!sidebarCy) {
            console.log("Sidebar graph not initialized yet.");
            return;
        }
        const selectedLayoutName = document.getElementById('sidebarLayoutSelect').value;
        const layoutConfig = sidebarLayoutOptions[selectedLayoutName];

        if (!layoutConfig) {
            console.error(`Layout configuration for '${selectedLayoutName}' not found.`);
            return;
        }

        console.log(`Applying sidebar layout: ${selectedLayoutName}`);
        // Run the layout
        let layout = sidebarCy.layout(layoutConfig);
        layout.run();
        // Optional: Refit after layout animation if needed (might depend on layout behavior)
        // layout.one('layoutstop', () => {
        //     if (sidebarCy) sidebarCy.fit(null, 30); // Fit with padding
        // });
    }

    function toggleSidebar(forceOpen = null) {
        const shouldBeOpen = forceOpen !== null ? forceOpen : !isSidebarOpen;
        if (shouldBeOpen) {
            if (!isSidebarOpen) {
                sidebar.classList.add('open');
                isSidebarOpen = true;
                sidebarToggleBtn.innerHTML = '&times;';
                sidebarToggleBtn.style.left = `${sidebarWidth}px`;
                mainContainer.style.marginLeft = `${sidebarWidth}px`;
                setTimeout(() => {
                    if (sidebarCy) {
                        sidebarCy.resize();
                        // No need to fit here, layout application handles fitting
                        // sidebarCy.fit(null, 50);
                         applySidebarLayout(); // Re-apply layout on open might be desired
                    }
                }, 350);
            }
        } else {
             if (isSidebarOpen) {
                sidebar.classList.remove('open');
                isSidebarOpen = false;
                sidebarToggleBtn.innerHTML = '&#9776;';
                sidebarToggleBtn.style.left = '0px';
                mainContainer.style.marginLeft = '0px';
            }
        }
    }

    resetSidebarBtn.addEventListener('click', () => {
        console.log("Resetting sidebar view and heatmap highlights.");
        clearSidebarVisualization();
        updateLegend();
        updateHeatmap();
        selectedNodeId = null;
        document.getElementById('sidebarLayoutSelect').value = 'cose'; // Reset layout dropdown
    });

    function showSidebarLoading(isLoadingGraph, isLoadingTable) {
        document.getElementById('sidebar-cy-loading').style.display = isLoadingGraph ? 'block' : 'none';
        document.getElementById('sidebar-table-loading').style.display = isLoadingTable ? 'block' : 'none';
        const showInfo = !isLoadingGraph && !isLoadingTable && (!sidebarCy || sidebarCy.elements().length === 0) && selectedSidebarEdges.size === 0 && selectedNodeId === null;
         document.getElementById('sidebar-info').style.display = showInfo ? 'block' : 'none';
    }

    function clearSidebarVisualization() {
        if (sidebarCy) {
            sidebarCy.destroy();
            sidebarCy = null;
        }
        addedSidebarClusters.clear();
        clusterHighlightColors.clear(); // Keep this if heatmap uses it
        selectedSidebarEdges.clear();
        selectedNodeId = null;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = null;
        sidebarTableContainer.innerHTML = '';
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        document.getElementById('sidebar-cy').innerHTML = '';
        document.getElementById('sidebar-info').innerHTML = 'Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to filter the table below.';
        document.getElementById('sidebar-info').style.display = 'block';
        document.getElementById('sidebar-cy-loading').style.display = 'none';
        document.getElementById('sidebar-table-loading').style.display = 'none';
        document.getElementById('sidebarLayoutSelect').value = 'cose'; // Reset layout dropdown

        console.log("Sidebar visualization, selections, and table cleared.");
    }

    function calculateEdgeWidth(processCount) {
        const count = processCount || 1;
        const minCount = 1;
        const maxCount = 100;
        const minWidth = 1;
        const maxWidth = 10;
        const range = (maxCount - minCount) || 1;
        const width = minWidth + (maxWidth - minWidth) * ((count - minCount) / range);
        return Math.max(minWidth, Math.min(width, maxWidth));
    }

    // Cytoscape Style Configuration (Borders Removed)
    const CYTOSCAPE_STYLE = [
        { selector: 'node', style: {
            'background-color': '#888',
            'label': 'data(label)',
            'width': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'height': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'font-size': 10, 'color': '#000',
            'text-valign': 'bottom', 'text-halign': 'center', 'text-margin-y': 4,
            'border-width': 0, // No borders
            'transition-property': 'background-color',
            'transition-duration': '0.15s'
        }},
        { selector: 'edge', style: {
            'line-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-shape': 'triangle', 'curve-style': 'bezier',
            'transition-property': 'line-color, target-arrow-color, width, z-index',
            'transition-duration': '0.15s',
            'z-index': 1
        }}
    ];

    function generateUniqueHighlightColor() {
        const MIN_HUE_DIFF = 30;
        let attempts = 0;
        const existingHues = Array.from(clusterHighlightColors.values()).map(hslString => {
            const match = hslString.match(/hsl\((\d+),/);
            return match ? parseInt(match[1], 10) : -1;
        }).filter(h => h !== -1);

        while (attempts < 100) {
            let hue = Math.floor(Math.random() * 360);
            if ((hue >= 0 && hue <= 25) || (hue >= 335 && hue <= 360) || (hue >= 195 && hue <= 265)) {
                attempts++;
                continue;
            }
            let isDistinct = existingHues.every(existingHue => {
                let diff = Math.abs(hue - existingHue);
                return diff >= MIN_HUE_DIFF && (360 - diff) >= MIN_HUE_DIFF;
            });
            if (isDistinct) {
                const newColor = `hsl(${hue}, 85%, 60%)`;
                console.log(`Generated distinct color: ${newColor} (Hue: ${hue})`);
                return newColor;
            }
            attempts++;
        }
        console.warn("Could not find highly distinct color, using fallback random hue.");
        let fallbackHue;
        do {
             fallbackHue = Math.floor(Math.random() * 360);
        } while ((fallbackHue >= 0 && fallbackHue <= 25) || (fallbackHue >= 335 && fallbackHue <= 360) || (fallbackHue >= 195 && fallbackHue <= 265));
        return `hsl(${fallbackHue}, 85%, 60%)`;
    }

    function deselectCurrentNode() {
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const originalColor = node.scratch('_originalColor');
                if (originalColor) {
                    node.style('background-color', originalColor);
                } else {
                    const clusterID = node.data('clusterID');
                    const clusterColor = clusterHighlightColors.get(clusterID) || '#888';
                    node.style('background-color', clusterColor);
                    console.warn(`Missing scratch color for node ${selectedNodeId}, reverted using cluster/default color.`);
                }
                node.connectedEdges().forEach(edge => {
                    const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                    const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                    edge.style({
                        'line-color': originalEdgeColor,
                        'target-arrow-color': originalEdgeColor,
                        'width': originalEdgeWidth,
                        'z-index': 1
                    });
                });
                 console.log(`Node ${selectedNodeId} and its edges deselected.`);
            } else {
                 console.warn(`Attempted to deselect node ${selectedNodeId}, but it was not found.`);
            }
            selectedNodeId = null;
        }
        selectedSidebarEdges.clear();
    }

    function visualizeClusterInSidebar(clusterID, nodeColor) {
        if (addedSidebarClusters.has(clusterID)) {
             console.log(`Cluster ${clusterID} is already visualized.`);
             if (sidebarCy) {
                 sidebarCy.nodes(`[clusterID = "${clusterID}"]`).animate({ style: { 'opacity': 0.5 } }, { duration: 200 }).animate({ style: { 'opacity': 1 } }, { duration: 200 });
             }
             if (currentSidebarTableClusterId !== clusterID || sidebarTableMode !== 'cluster') {
                 loadSidebarClusterTable(clusterID, 1);
             }
             deselectCurrentNode();
             return;
        }

        toggleSidebar(true);
        showSidebarLoading(true, false);
        document.getElementById('sidebar-info').innerHTML = `Loading network for Cluster ${clusterID}...`;
        document.getElementById('sidebar-info').style.display = 'block';

        fetch(`${API_BASE_URL}/cluster_network?cluster_id=${clusterID}`)
             .then(response => { if (!response.ok) throw new Error(`Network error (${response.status})`); return response.json(); })
             .then(data => {
                 showSidebarLoading(false, false);

                 if (!data || (!data.nodes || data.nodes.length === 0)) {
                     console.log(`No network data for Cluster ${clusterID}.`);
                     if (!sidebarCy) {
                         sidebarCy = cytoscape({ container: document.getElementById('sidebar-cy'), style: CYTOSCAPE_STYLE });
                         bindSidebarGraphEvents();
                     }
                     addedSidebarClusters.add(clusterID);
                     loadSidebarClusterTable(clusterID, 1);
                     updateLegend(sidebarCy?.edges());
                     deselectCurrentNode();
                     return;
                 }

                 const nodesToAdd = data.nodes.map(node => ({
                     group: 'nodes',
                     data: { ...node.data, clusterID: clusterID },
                     style: { ...(node.style || {}), 'background-color': nodeColor },
                     scratch: { _originalColor: nodeColor }
                 }));

                 const edgesToAdd = data.edges.map(edge => {
                     const protocol = edge.data.Protocol || 'Unknown';
                     if (!protocolColorMap[protocol]) {
                         protocolColorMap[protocol] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                     }
                     const edgeColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                     const originalWidth = calculateEdgeWidth(edge.data.processCount);
                     return {
                         group: 'edges',
                         data: { ...edge.data, clusterID: clusterID },
                         style: { 'line-color': edgeColor, 'target-arrow-color': edgeColor, 'width': originalWidth },
                         scratch: { _protocolColor: edgeColor, _originalWidth: originalWidth }
                     };
                 });

                 if (!sidebarCy) {
                     sidebarCy = cytoscape({
                         container: document.getElementById('sidebar-cy'),
                         elements: { nodes: nodesToAdd, edges: edgesToAdd },
                         style: CYTOSCAPE_STYLE
                     });
                     bindSidebarGraphEvents();
                     applySidebarLayout(); // Apply selected layout on creation
                 } else {
                     sidebarCy.add(nodesToAdd.concat(edgesToAdd));
                     applySidebarLayout(); // Apply selected layout after adding elements
                 }

                 addedSidebarClusters.add(clusterID);
                 document.getElementById('sidebar-info').style.display = 'none';
                 updateLegend(sidebarCy.edges());
                 loadSidebarClusterTable(clusterID, 1);
                 deselectCurrentNode();

             })
             .catch(error => {
                 console.error(`Error visualizing cluster ${clusterID} in sidebar:`, error);
                 showSidebarLoading(false, false);
                 document.getElementById('sidebar-info').innerHTML = `Error loading graph data for Cluster ${clusterID}.`;
                 document.getElementById('sidebar-info').style.display = 'block';
                 loadSidebarClusterTable(clusterID, 1);
                 deselectCurrentNode();
             });
    }

    function bindSidebarGraphEvents() {
        if (!sidebarCy) return;

        sidebarCy.removeListener('mouseover'); // Keep mouseover/mouseout for tooltips
        sidebarCy.removeListener('mouseout');
        sidebarCy.removeListener('click');    // Remove previous click/tap listeners
        sidebarCy.removeListener('tap');

        sidebarCy.on('mouseover', 'node', (event) => { /* ... tooltip logic ... */ });
        sidebarCy.on('mouseover', 'edge', (event) => { /* ... tooltip logic ... */ });
        sidebarCy.on('mouseout', 'node, edge', () => { tooltip.style("display", "none"); });

        // --- Modified Click/Tap Handlers ---
        sidebarCy.on('click', 'edge', (event) => {
            if (selectedNodeId) {
                console.log("Node selection active, ignoring individual edge click.");
                return;
            }
            const edge = event.target;
            const source = edge.data('source');
            const target = edge.data('target');
            const protocol = edge.data('Protocol');
            const edgeKey = `${source}|${target}|${protocol}`;

            if (selectedSidebarEdges.has(edgeKey)) {
                selectedSidebarEdges.delete(edgeKey);
                // Reset style... (keep existing style reset)
                const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
            } else {
                selectedSidebarEdges.add(edgeKey);
                // Apply selected style... (keep existing style apply)
                edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
            }
            updateSidebarTableForSelectedEdges(); // This will now also update tree highlights
        });

        sidebarCy.on('click', 'node', (event) => {
            const clickedNode = event.target;
            const clickedNodeId = clickedNode.id();

            if (selectedSidebarEdges.size > 0) {
                // Clear individual edge selections visually and logically
                sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                    .forEach(edge => {
                        const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                        const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                        edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                    });
                selectedSidebarEdges.clear();
            }

            if (selectedNodeId === clickedNodeId) {
                // Deselecting the currently selected node
                deselectCurrentNode(); // Resets node/edge styles
                // updateSidebarTableForSelectedEdges will handle table and tree highlight clearing
            } else {
                // Selecting a new node
                deselectCurrentNode(); // Deselect previous first
                if (!clickedNode.scratch('_originalColor')) {
                    clickedNode.scratch('_originalColor', clickedNode.style('background-color'));
                }
                // Apply selected style... (keep existing style apply)
                clickedNode.style('background-color', SELECTED_NODE_COLOR);
                clickedNode.connectedEdges().forEach(edge => {
                    edge.style({ 'line-color': SELECTED_EDGE_COLOR, 'target-arrow-color': SELECTED_EDGE_COLOR, 'width': SELECTED_EDGE_WIDTH, 'z-index': SELECTED_EDGE_ZINDEX });
                });
                selectedNodeId = clickedNodeId;
                console.log(`Node ${selectedNodeId} and its edges selected.`);
                // updateSidebarTableForSelectedEdges will handle table and tree highlight update
            }
            updateSidebarTableForSelectedEdges(); // Update table and tree highlights based on selection state
            document.getElementById('sidebar-info').style.display = 'none';
        });

        sidebarCy.on('tap', function(event){
            if (event.target === sidebarCy) { // Tapped on background
                let selectionCleared = false;
                if(selectedNodeId){
                    deselectCurrentNode(); // Resets node/edge styles
                    selectionCleared = true;
                } else if (selectedSidebarEdges.size > 0) {
                    // Clear visual selection for edges
                    sidebarCy.edges().filter(edge => selectedSidebarEdges.has(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`))
                        .forEach(edge => {
                            const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                            const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                            edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                        });
                    selectedSidebarEdges.clear();
                    selectionCleared = true;
                }

                if (selectionCleared) {
                    updateSidebarTableForSelectedEdges(); // Update table (to cluster default) and clear tree highlights
                }
            }
        });
    }

    function updateSidebarTableForSelectedEdges() {
        // NOTE: clusterIdsToHighlight Set is removed

        if (selectedNodeId && sidebarCy) {
            // --- Node Selection Logic ---
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                // Get connected edges data WITHOUT collecting cluster IDs for tree highlighting
                const connectedEdgeData = node.connectedEdges().map(edge => {
                    return { source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') };
                });

                if (connectedEdgeData.length > 0) {
                    loadSidebarMultiEdgeTable(connectedEdgeData, 1); // Load table for connected edges
                } else {
                    sidebarTableContainer.innerHTML = '<p style="padding:10px; text-align:center; color:#6c757d;">Selected node has no connections.</p>';
                    sidebarTableContainer.style.display = 'block';
                    sidebarTablePagination.style.display = 'none';
                }
                document.getElementById('sidebar-info').style.display = 'none';
            } else {
                selectedNodeId = null; // Node not found, reset state
                // Fall through to edge/default logic
            }
            // --- End Node Selection Logic ---
        }

        if (!selectedNodeId && selectedSidebarEdges.size > 0) {
            // --- Individual Edge Selection Logic ---
            // Get edge list WITHOUT collecting cluster IDs for tree highlighting
            const edgeList = Array.from(selectedSidebarEdges).map(key => {
                const parts = key.split('|');
                return { source: parts[0], destination: parts[1], protocol: parts[2] };
            });
            loadSidebarMultiEdgeTable(edgeList, 1); // Load table for selected edges
            document.getElementById('sidebar-info').style.display = 'none';
            // --- End Individual Edge Selection Logic ---
        }

        if (!selectedNodeId && selectedSidebarEdges.size === 0) {
            // --- No Selection Logic ---
            if (currentSidebarTableClusterId) {
                // If a cluster was previously loaded (e.g., via heatmap click), show its table
                loadSidebarClusterTable(currentSidebarTableClusterId, 1);
                // No need to add this cluster ID for tree highlighting here
            } else {
                // Default state: Clear table, show info
                sidebarTableContainer.innerHTML = '';
                sidebarTableContainer.style.display = 'none';
                sidebarTablePagination.style.display = 'none';
                document.getElementById('sidebar-info').innerHTML = 'Click nodes or edges in the graph to filter the table below, or click a heatmap cell.';
                document.getElementById('sidebar-info').style.display = 'block';
            }
        }
    }

    function loadSidebarMultiEdgeTable(edgeList, page) {
        if (!edgeList || edgeList.length === 0) {
             updateSidebarTableForSelectedEdges();
             return;
         }
        sidebarTableMode = 'edges';
        console.log(`Loading sidebar table for ${edgeList.length} edges, page ${page}`);
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        const payload = { edges: edgeList, page: page, page_size: TABLE_PAGE_SIZE };

        fetch(`${API_BASE_URL}/get_multi_edge_table`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
        .then(response => response.ok ? response.text() : Promise.reject(`Failed multi-edge table page (${response.status})`))
        .then(html => {
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = html;
            sidebarTableContainer.style.display = 'block';
            const summaryElem = sidebarTableContainer.querySelector('#table-summary');
            if (summaryElem && summaryElem.dataset.total) {
                const total = parseInt(summaryElem.dataset.total, 10);
                 if (total > 0) {
                    sidebarTablePagination.style.display = 'block';
                    const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                    document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                    document.getElementById('sidebarCurrentPageInput').value = page;
                    document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                 } else { sidebarTablePagination.style.display = 'none'; }
            } else {
                document.getElementById('sidebarTotalPages').textContent = '?';
                document.getElementById('sidebarCurrentPageInput').value = page;
                sidebarTablePagination.style.display = 'none';
                console.warn("No table summary total found in multi-edge sidebar table response.");
            }
             sidebarTableContainer.scrollTop = 0;
        })
        .catch(error => {
            console.error("Error fetching multi-edge sidebar table:", error);
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data for selected edges.</p>`;
            sidebarTableContainer.style.display = 'block';
            sidebarTablePagination.style.display = 'none';
        });
    }

    function applyAllHeatmapHighlights() {
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill");
            if (originalColor) { cell.attr("fill", originalColor); }
        });
        clusterHighlightColors.forEach((color, clusterId) => {
            d3.selectAll('rect.cell[data-cluster="' + clusterId + '"]').attr('fill', color);
        });
     }

     function renderCombinedHeatmap(dataByMetric) {
        const orderOption = document.getElementById("rowOrderSelect").value || "descending";
        const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;
        const maxCellsPerRow = 700; // Limit max cells processed if desired
        // Ensure data is sorted *before* potential slicing
        const heatmapData = dataByMetric.map(({ metric, pivotData }) => ({
             metric,
             values: [...pivotData].sort(comparator) //.slice(0, maxCellsPerRow) // Uncomment slice if performance is an issue
        }));


        const heatmapDiv = d3.select("#heatmap");
        heatmapDiv.select("svg").remove(); // Clear previous heatmap

        if (heatmapData.length === 0 || heatmapData.every(row => row.values.length === 0)) {
            heatmapDiv.html('<p style="text-align: center; padding: 20px; color: #6c757d;">No heatmap data to display based on current filters.</p>');
            return; // Don't render if no data
        }

        // --- Dynamic Cell Width Calculation ---
        const minCellWidth = 2;
        const maxCellWidth = 10;
        const heatmapCellHeight = 15;
        const labelMargin = 150; // Space for row labels
        const rightPadding = 40; // Space right of cells
        const verticalSpace = 10; // Space between rows

        const heatmapContainerWidth = document.getElementById('heatmap').clientWidth;
        const availableWidthForCells = Math.max(0, heatmapContainerWidth - labelMargin - rightPadding);
        const maxCols = d3.max(heatmapData, r => r.values.length) || 1;
        let calculatedCellWidth = availableWidthForCells / maxCols;
        const finalCellWidth = Math.max(minCellWidth, Math.min(calculatedCellWidth, maxCellWidth));
        // --- End Dynamic Cell Width Calculation ---

        const numRows = heatmapData.length;
        const totalHeight = 20 + numRows * heatmapCellHeight + (numRows - 1) * verticalSpace + 20; // Top/bottom padding
        const svgWidth = labelMargin + maxCols * finalCellWidth + rightPadding; // Actual width needed

        const svg = heatmapDiv.append("svg")
                              .attr("width", svgWidth)
                              .attr("height", totalHeight);

        // Draw rows
        heatmapData.forEach((rowData, rowIndex) => {
            const rowY = 20 + rowIndex * (heatmapCellHeight + verticalSpace); // Top padding + row index * (cell + space)

            // Add row label (metric name)
            svg.append("text")
               .attr("x", labelMargin - 10) // Position left of cells
               .attr("y", rowY + heatmapCellHeight / 2)
               .attr("text-anchor", "end")
               .attr("alignment-baseline", "middle")
               .attr("font-size", "12px")
               .attr("fill", "black")
               .text(rowData.metric);

            // Color scale for the row
            const numericValues = rowData.values.map(d => typeof d.value === 'number' ? d.value : 0).filter(v => !isNaN(v));
            const rowMax = numericValues.length > 0 ? d3.max(numericValues) : 1;
            // Ensure domain is never [0, 0] which causes issues
            const colorDomain = [0, rowMax === 0 ? 1 : rowMax];
            const colorScale = d3.scaleSequential(d3.interpolateBlues).domain(colorDomain);

            // Draw cells within the row
            rowData.values.forEach((cellData, colIndex) => {
                const cellX = labelMargin + colIndex * finalCellWidth;
                const numericValue = typeof cellData.value === 'number' && !isNaN(cellData.value) ? cellData.value : 0;
                // Determine fill color (anomaly or scale)
                const originalFillColor = cellData.clusterAnomaly === 'anomaly' ? 'red' : colorScale(numericValue);
                // Check if this cluster is highlighted
                const initialHighlightColor = clusterHighlightColors.get(cellData.cluster);
                const initialFill = initialHighlightColor || originalFillColor; // Use highlight or original

                svg.append("rect")
                  .attr("class", "cell")
                  .attr("data-cluster", cellData.cluster)
                  .attr("data-clusteranomaly", cellData.clusterAnomaly)
                  .attr("data-metric", rowData.metric)
                  .attr("data-value", cellData.value)
                  .attr("data-original-fill", originalFillColor) // Store original color
                  .attr("x", cellX)
                  .attr("y", rowY)
                  .attr("width", finalCellWidth)
                  .attr("height", heatmapCellHeight)
                  .attr("fill", initialFill) // Set initial fill
                  .style("cursor", "pointer")
                  .on("mouseover", function (event) {
                      const d = d3.select(this);
                      const tip = tooltip.node(); // Use shorter name 'tip'

                      // Set content and make visible for measurement
                      tooltip.html(`<strong>${d.attr("data-metric")}</strong><br>Cluster: ${d.attr("data-cluster")}<br>Value: ${d.attr("data-value")}<br>Anomaly: ${d.attr("data-clusteranomaly")}`)
                             .style("display", "block")
                             .style("opacity", 1);

                      // Get dimensions using shorter names, declare together
                      const tW = tip.offsetWidth, tH = tip.offsetHeight;
                      const wW = window.innerWidth, wH = window.innerHeight;
                      const buffer = 15; // A small buffer from window edges
                      let newLeft = event.pageX + 10; // Initial position right of cursor
                      let newTop = event.pageY + 10;  // Initial position below cursor

                      // Adjust horizontal position
                      if (newLeft + tW > wW - buffer) { // If overflows right edge
                          newLeft = event.pageX - tW - 10; // Place left of cursor
                      }
                      if (newLeft < buffer) { // If overflows left edge (after potential adjustment)
                          newLeft = buffer; // Pin to left buffer
                      }

                      // Adjust vertical position
                      if (newTop + tH > wH - buffer) { // If overflows bottom edge
                          newTop = event.pageY - tH - 10; // Place above cursor
                      }
                      if (newTop < buffer) { // If overflows top edge (after potential adjustment)
                          newTop = buffer; // Pin to top buffer
                      }

                      // Apply the final calculated position
                      tooltip.style("left", newLeft + "px")
                             .style("top", newTop + "px");
                  })
                  .on("mouseout", () => {
                      // Hide tooltip on mouse out
                      tooltip.style("opacity", 0).style("display", "none");
                  })
                  .on("click", function (event) {
                      // --- Heatmap Cell Click Logic (Unchanged) ---
                      event.stopPropagation();
                      const cell = d3.select(this);
                      const clusterID = cell.attr("data-cluster");
                      const originalColor = cell.attr("data-original-fill");
                      let targetHighlightColor;

                      if (clusterHighlightColors.has(clusterID)) {
                          console.log(`Deselecting cluster ${clusterID} from heatmap.`);
                          clusterHighlightColors.delete(clusterID);
                          targetHighlightColor = originalColor; // Revert to original
                      } else {
                          console.log(`Selecting cluster ${clusterID} on heatmap.`);
                          targetHighlightColor = generateUniqueHighlightColor(); // Get new color
                          clusterHighlightColors.set(clusterID, targetHighlightColor);
                          visualizeClusterInSidebar(clusterID, targetHighlightColor); // Add to sidebar
                      }

                      // Update all cells for this cluster
                      d3.selectAll('rect.cell[data-cluster="' + clusterID + '"]')
                        .transition().duration(100)
                        .attr('fill', targetHighlightColor);

                      // Update tree highlights
                      highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                      // --- End Heatmap Cell Click Logic ---
                  });
            });
        });
    }

    function showHeatmap() {
        if (globalCy) { globalCy.destroy(); globalCy = null; }
        document.getElementById('cy').style.display = 'none';
        document.getElementById('backToHeatmap').style.display = 'none';
        document.getElementById('edgeFilterPanel').style.display = 'none';
        document.getElementById('refreshNetworkBtn').style.display = 'none';
        document.getElementById('sizeControls').style.display = 'none';
        document.getElementById('table-container').style.display = 'none';
        document.getElementById('table-pagination').style.display = 'none';
        document.getElementById('table-search-container').style.display = "none";
        document.getElementById('topControls').style.display = 'block';
        d3.select("#heatmap").style("display", "block");
        clearEdgeFilter();
        clearSidebarVisualization();
        updateLegend();
        updateHeatmap();
        toggleSidebar(false);
    }
    document.getElementById('backToHeatmap').addEventListener('click', showHeatmap);

    function showLoading() { document.getElementById('loading-overlay').style.display = 'flex'; }
    function hideLoading() { document.getElementById('loading-overlay').style.display = 'none'; }

    function updateLegend(cyEdges = null) {
        const legendTableBody = d3.select('#legend tbody');
        legendTableBody.html(''); // Clear previous rows immediately

        let protocols = new Set(); // Stores unique lowercase protocol names
        let displayLabelMap = {};  // Stores mapping: lowercase -> Original Case Display Label
        let calculationPromise;
        const currentLegendTitle = document.querySelector('#legend-container h3');

        if (cyEdges && cyEdges.length > 0) {
            // --- Sidebar Legend Calculation ---
            if (currentLegendTitle) currentLegendTitle.textContent = "Sidebar Protocols";

            const counts = {};
            let totalCount = 0;
            const localPercentages = {}; // Use lowercase keys internally

            cyEdges.forEach(edge => {
                const originalProtocol = (edge.data('Protocol') || 'Unknown').trim();
                if (!originalProtocol) return;
                const protocolLC = originalProtocol.toLowerCase(); // Lowercase for internal use

                // Add to set and map
                protocols.add(protocolLC);
                if (!displayLabelMap[protocolLC]) { // Store first encountered casing
                    displayLabelMap[protocolLC] = originalProtocol;
                }

                // Calculate counts
                const count = edge.data('processCount') || 1;
                counts[protocolLC] = (counts[protocolLC] || 0) + count; // Use lowercase key
                totalCount += count;
            });

            totalCount = totalCount || 1; // Avoid division by zero

            // Calculate percentages using lowercase keys
            Object.entries(counts).forEach(([pLC, c]) => {
                localPercentages[pLC] = (c / totalCount) * 100;
            });
            calculationPromise = Promise.resolve(localPercentages); // Resolve with lowercase-keyed percentages

        } else {
            // --- Global Legend Fetch ---
            if (currentLegendTitle) currentLegendTitle.textContent = "Global Protocol Legend";
            calculationPromise = fetch(`${API_BASE_URL}/protocol_percentages`)
                .then(res => res.ok ? res.json() : Promise.reject('Failed global percentages'))
                .then(originalPercentages => {
                    // Process fetched percentages: create lowercase keys and display map
                    const processedPercentages = {};
                    Object.entries(originalPercentages).forEach(([key, value]) => {
                         const originalDisplay = key.trim(); // Original casing for display
                         if (!originalDisplay) return; // Skip empty keys
                         const protocolLC = originalDisplay.toLowerCase(); // Lowercase for internal use

                         processedPercentages[protocolLC] = value; // Store percentage with lowercase key
                         protocols.add(protocolLC);            // Add lowercase to Set

                         if (!displayLabelMap[protocolLC]) { // Store first encountered casing
                             displayLabelMap[protocolLC] = originalDisplay;
                         }
                    });
                    return processedPercentages; // Return object keyed by lowercase
                })
                .catch(error => {
                    console.error("Error fetching/processing global protocol percentages:", error);
                    return {}; // Return empty object on error
                });
        }

        // --- Common Logic (Color Assignment, Sorting, Table Building) ---
        calculationPromise.then(percentages => { // 'percentages' object now ALWAYS has lowercase keys

            // Ensure colors exist for all unique lowercase protocols found
            protocols.forEach(protocolLC => {
                 // If color map doesn't have the lowercase key, assign one
                 if (!protocolColorMap[protocolLC]) {
                     // Special handling for 'unknown'
                     if (protocolLC === 'unknown') {
                          protocolColorMap['unknown'] = DEFAULT_UNKNOWN_COLOR;
                          // Ensure display map has 'Unknown' if not already set
                          if (!displayLabelMap['unknown']) displayLabelMap['unknown'] = 'Unknown';
                     } else {
                         // Generate random color for other protocols
                         protocolColorMap[protocolLC] = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                         // If display map is missing for some reason, fallback to lowercase
                          if (!displayLabelMap[protocolLC]) displayLabelMap[protocolLC] = protocolLC;
                     }
                 }
            });
             // Ensure 'unknown' color mapping exists as a fallback
             if (!protocolColorMap['unknown']) {
                 protocolColorMap['unknown'] = DEFAULT_UNKNOWN_COLOR;
                 if (!displayLabelMap['unknown']) displayLabelMap['unknown'] = 'Unknown';
             }


            // Sort protocols (lowercase keys) based on percentages (descending)
            // Access percentages using lowercase keys directly
            const sortedProtocols = Array.from(protocols).filter(pLC => pLC).sort((aLC, bLC) => (percentages[bLC] || 0) - (percentages[aLC] || 0));

            // Build the legend table body
            legendTableBody.html(''); // Clear existing rows first (moved to top)
            sortedProtocols.forEach(protocolLC => { // Iterate through sorted lowercase protocols
                const pct = percentages[protocolLC] || 0; // Access using lowercase key
                const pctText = (pct > 0.01 ? pct.toFixed(2) : '<0.01') + '%';
                const color = protocolColorMap[protocolLC] || protocolColorMap['unknown']; // Use lowercase key for color
                const displayLabel = displayLabelMap[protocolLC] || protocolLC; // Get display name from map

                // Corrected HTML generation line
                legendTableBody.append('tr').html(`<td>${displayLabel}</td><td><span class="color-box" style="background-color:${color}"></span></td><td style="text-align: right;">${pctText}</td>`);
            });

            // Update edge colors in the sidebar graph if it exists
            if (sidebarCy) {
                sidebarCy.edges().forEach(edge => {
                    const protocolLC = (edge.data('Protocol') || 'Unknown').trim().toLowerCase(); // lowercase for matching
                    const newColor = protocolColorMap[protocolLC] || protocolColorMap['unknown']; // Use lowercase key for color

                    // Check selection status before changing color
                    const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                    const nodeIsSelected = selectedNodeId && (edge.source().id() === selectedNodeId || edge.target().id() === selectedNodeId);
                    const edgeIsSelected = selectedSidebarEdges.has(edgeKey);

                    if (!nodeIsSelected && !edgeIsSelected) {
                       edge.style({'line-color': newColor, 'target-arrow-color': newColor});
                    }
                    // Always update scratch color, using the determined color
                    edge.scratch('_protocolColor', newColor);
                });
            }
        }).catch(error => {
           // Catch errors from the calculationPromise itself (e.g., fetch failure)
           console.error("Error processing legend data:", error);
           legendTableBody.html('<tr><td colspan="3" style="color: red;">Error loading legend</td></tr>');
        });
    }

     function updateHeatmap() {
        showLoading();
        // Define the metrics to display in the heatmap
        const metrics = [
            { label: "Count", value: "count" }, { label: "Unique IPs", value: "Unique IPs" },
            { label: "Unique Sources", value: "Unique Sources" }, { label: "Unique Destinations", value: "Unique Destinations" },
            { label: "Packet Length", value: "Length" }, { label: "Payload Length", value: "Len" },
            { label: "Payload Size Variance", value: "Payload Size Variance" }, { label: "Packets per Second", value: "Packets per Second" },
            { label: "Total Data Sent", value: "Total Data Sent" }, { label: "% SYN packets", value: "% SYN packets" },
            { label: "% RST packets", value: "% RST packets" }, { label: "% ACK packets", value: "% ACK packets" },
            { label: "% PSH packets", value: "% PSH packets" }
            // Add or remove metrics here as needed
        ];
        // Get filter parameters from the UI
        const filterParamsBase = {
            payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
            sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
            destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
            protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
            entropyMin: document.getElementById('entropyMinFilter').value, entropyMax: document.getElementById('entropyMaxFilter').value,
            isLargePacketOnly: document.getElementById('isLargePacketFilter').checked, isSuspiciousAckOnly: document.getElementById('isSuspiciousAckFilter').checked,
            minSourceAmt: document.getElementById('minSourceAmtFilter').value, maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
            minDestinationAmt: document.getElementById('minDestinationAmtFilter').value, maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
        };

        // Fetch data for all metrics in parallel
        Promise.all(metrics.map(m => {
            const filterParams = { ...filterParamsBase, metric: m.value };
            return fetch(`${API_BASE_URL}/filter_and_aggregate`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(filterParams) })
                .then(response => response.ok ? response.json() : Promise.reject(`Failed ${m.label} (${response.status})`))
                .then(data => ({ metric: m.label, pivotData: data })) // Use label for keys
                .catch(error => { console.error(`Error fetching ${m.label}:`, error); return { metric: m.label, pivotData: [], error: true }; });
        }))
        .then(results => {
            // Filter out errors
            const validResults = results.filter(r => !r.error);

            // --- Store sort orders for ALL available metrics ---
            window.heatmapSortOrders = {}; // Initialize/reset
            // const availableMetrics = []; // Uncomment if dynamically populating dropdown

            const orderOption = document.getElementById("rowOrderSelect").value || "descending";
            const comparator = orderOption === "descending" ? (a, b) => b.value - a.value : (a, b) => a.value - b.value;

            validResults.forEach(r => {
                const metricName = r.metric; // The label (e.g., "Count", "Unique IPs")
                if (r.pivotData && r.pivotData.length > 0) {
                     const sortedData = [...r.pivotData].sort(comparator);
                     window.heatmapSortOrders[metricName] = sortedData.map(d => d.cluster);
                    // availableMetrics.push(metricName); // Uncomment if dynamically populating
                    // console.log(`Stored sort order for ${metricName}`);
                } else {
                     window.heatmapSortOrders[metricName] = []; // Store empty if no data
                    // console.log(`No data found for metric ${metricName}`);
                }
            });

            // Keep old variable for compatibility or remove if fully transitioned
            window.heatmapCountSortOrder = window.heatmapSortOrders['Count'] || [];
            // --- End Storing Sort Orders ---

            renderCombinedHeatmap(validResults); // Render the heatmap
            hideLoading();
        })
        .catch(error => {
            console.error("Major error fetching heatmap data:", error);
            d3.select("#heatmap").html('<p style="color: red;">Error loading heatmap data.</p>');
            hideLoading();
        });
        applyAllHeatmapHighlights(); // Apply any existing highlights
    }

    function loadSidebarClusterTable(clusterID, page) {
         if (!clusterID) return;
         sidebarTableMode = 'cluster';
         currentSidebarTableClusterId = clusterID;
         console.log(`Loading sidebar table for Cluster ${clusterID}, page ${page}`);
         showSidebarLoading(false, true);
         sidebarTableContainer.style.display = 'none';
         sidebarTablePagination.style.display = 'none';

         fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
             .then(response => response.ok ? response.text() : Promise.reject(`Failed cluster table page (${response.status})`))
             .then(html => {
                 showSidebarLoading(false, false);
                 sidebarTableContainer.innerHTML = html;
                 sidebarTableContainer.style.display = 'block';
                 const summaryElem = sidebarTableContainer.querySelector('#table-summary');
                 if (summaryElem && summaryElem.dataset.total) {
                     const total = parseInt(summaryElem.dataset.total, 10);
                      if (total > 0) {
                         sidebarTablePagination.style.display = 'block';
                         const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                         document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
                         document.getElementById('sidebarCurrentPageInput').value = page;
                         document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
                      } else { sidebarTablePagination.style.display = 'none'; }
                 } else {
                     document.getElementById('sidebarTotalPages').textContent = '?';
                     document.getElementById('sidebarCurrentPageInput').value = page;
                     sidebarTablePagination.style.display = 'none';
                     console.warn("No table summary total found in sidebar cluster table response.");
                 }
                  sidebarTableContainer.scrollTop = 0;
             })
             .catch(error => {
                 console.error("Error fetching sidebar cluster table:", error);
                 showSidebarLoading(false, false);
                 sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                 sidebarTableContainer.style.display = 'block';
                 sidebarTablePagination.style.display = 'none';
             });
     }

    sidebarGoPageBtn.addEventListener('click', function () {
        let pageInput = document.getElementById('sidebarCurrentPageInput');
        let page = parseInt(pageInput.value, 10);
        const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
        const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);

        if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
             if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                 loadSidebarClusterTable(currentSidebarTableClusterId, page);
             } else if (sidebarTableMode === 'edges') {
                 let edgeList = [];
                 if (selectedNodeId && sidebarCy) {
                      const node = sidebarCy.getElementById(selectedNodeId);
                      if (node && node.length > 0) { edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') })); }
                 } else if (selectedSidebarEdges.size > 0) {
                      edgeList = Array.from(selectedSidebarEdges).map(key => { const parts = key.split('|'); return { source: parts[0], destination: parts[1], protocol: parts[2] }; });
                 }
                 if (edgeList.length > 0) { loadSidebarMultiEdgeTable(edgeList, page); }
                 else { console.warn("Sidebar pagination clicked in edge mode, but no edges identified as selected."); }
             } else { console.warn("Sidebar pagination clicked but current table context is unclear."); }
        } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
    });

    function loadClusterTablePage(clusterID, page) {
         currentClusterID = clusterID;
         fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
             .then(response => response.ok ? response.text() : Promise.reject(`Failed main table page (${response.status})`))
             .then(html => {
                 const container = document.getElementById('table-container');
                 container.innerHTML = html;
                 container.style.display = 'block';
                 document.getElementById('table-pagination').style.display = 'block';
                 const summaryElem = container.querySelector('#table-summary');
                 if (summaryElem && summaryElem.dataset.total) {
                     const total = parseInt(summaryElem.dataset.total, 10);
                     const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                     document.getElementById('totalPages').textContent = totalPages || 1;
                     document.getElementById('currentPageInput').value = page;
                     document.getElementById('currentPageInput').max = totalPages || 1;
                 } else {
                     document.getElementById('totalPages').textContent = '?';
                     document.getElementById('currentPageInput').value = page;
                     console.warn("No table summary total in main table response.");
                 }
                 container.scrollTop = 0;
             }).catch(error => {
                 console.error("Error fetching main cluster table:", error);
                 document.getElementById('table-container').innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                 document.getElementById('table-container').style.display = 'block';
                 document.getElementById('table-pagination').style.display = 'none';
             });
     }

    function createClusterTable(clusterID) {
        loadClusterTablePage(clusterID, 1);
        document.getElementById('table-search-container').style.display = "block";
    }

    function visualizeNetwork(elements) {
         if (globalCy) { globalCy.destroy(); }
         globalCy = cytoscape({ container: document.getElementById('cy'), elements: elements, style: CYTOSCAPE_STYLE, layout: { name: 'cose' } }); // Default layout for main graph
         applySizeControls();
     }

    function applySizeControls() {
         if (!globalCy) return;
         const minNS = Math.max(parseFloat(document.getElementById('nodeSizeMin').value) || 15, 1);
         const maxNS = Math.max(parseFloat(document.getElementById('nodeSizeMax').value) || 60, minNS + 1);
         const minEW = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 1, 0.1);
         const maxEW = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 10, minEW + 0.1);

         globalCy.batch(() => {
             globalCy.nodes().forEach(n => {
                 const weight = n.data('NodeWeight') ?? 0.5;
                 let size = minNS + (maxNS - minNS) * weight;
                 size = Math.max(minNS, Math.min(size, maxNS));
                 n.style({ 'width': size, 'height': size });
             });
             const counts = globalCy.edges().map(e => e.data('processCount') || 1);
             if (counts.length > 0) {
                 const minCount = Math.min(...counts);
                 const maxCount = Math.max(...counts);
                 const countRange = (maxCount - minCount) || 1;
                 globalCy.edges().forEach(e => {
                     const count = e.data('processCount') || 1;
                     let width = minEW + (maxEW - minEW) * ((count - minCount) / countRange);
                     width = Math.max(minEW, Math.min(width, maxEW));
                     e.style('width', width);
                 });
             }
         });
     }

    function applyEdgeFilter() {
         if (!globalCy) return;
         const sourceFilter = document.getElementById('edgeFilterSource').value.toLowerCase();
         const destFilter = document.getElementById('edgeFilterDestination').value.toLowerCase();
         const protoFilter = document.getElementById('edgeFilterProtocol').value.toLowerCase();
         const weightFilterStr = document.getElementById('edgeFilterWeight').value;
         const countFilterStr = document.getElementById('edgeFilterProcessCount').value;

         const parseFilter = (filterStr) => { const match = filterStr.match(/^([<>=!]+)?\s*(\d+(\.\d+)?)$/); if (match) { const operator = match[1] || '=='; const value = parseFloat(match[2]); return { operator, value }; } return null; };
         const weightFilter = parseFilter(weightFilterStr);
         const countFilter = parseFilter(countFilterStr);

         globalCy.edges().forEach(edge => {
             let show = true;
             const data = edge.data();
             if (sourceFilter && !data.source?.toLowerCase().includes(sourceFilter)) show = false;
             if (destFilter && !data.target?.toLowerCase().includes(destFilter)) show = false;
             if (protoFilter && !data.Protocol?.toLowerCase().includes(protoFilter)) show = false;
             if (weightFilter) { const edgeWeight = data.EdgeWeight || 0; if (weightFilter.operator === '>=' && !(edgeWeight >= weightFilter.value)) show = false; else if (weightFilter.operator === '>' && !(edgeWeight > weightFilter.value)) show = false; else if (weightFilter.operator === '<=' && !(edgeWeight <= weightFilter.value)) show = false; else if (weightFilter.operator === '<' && !(edgeWeight < weightFilter.value)) show = false; else if (weightFilter.operator === '==' && !(edgeWeight == weightFilter.value)) show = false; else if (weightFilter.operator === '!=' && !(edgeWeight != weightFilter.value)) show = false; }
             if (countFilter) { const processCount = data.processCount || 0; if (countFilter.operator === '>=' && !(processCount >= countFilter.value)) show = false; else if (countFilter.operator === '>' && !(processCount > countFilter.value)) show = false; else if (countFilter.operator === '<=' && !(processCount <= countFilter.value)) show = false; else if (countFilter.operator === '<' && !(processCount < countFilter.value)) show = false; else if (countFilter.operator === '==' && !(processCount == countFilter.value)) show = false; else if (countFilter.operator === '!=' && !(processCount != countFilter.value)) show = false; }
             edge.style('display', show ? 'element' : 'none');
         });
     }

    function resetHeatmapHighlights() {
        console.log("Resetting heatmap cell highlights.");
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) {
                cell.transition().duration(100) // Optional quick transition
                    .attr("fill", originalColor);
            } else {
                // Fallback if original color wasn't stored somehow
                cell.style("fill", null); // Let CSS/default handle it
            }
        });
    }

    function clearEdgeFilter() {
         document.getElementById('edgeFilterSource').value = '';
         document.getElementById('edgeFilterDestination').value = '';
         document.getElementById('edgeFilterProtocol').value = '';
         document.getElementById('edgeFilterWeight').value = '';
         document.getElementById('edgeFilterProcessCount').value = '';
         if(globalCy) { globalCy.edges().style('display', 'element'); }
     }

     document.addEventListener('DOMContentLoaded', () => {
        tooltip = d3.select("#tooltip");
        showHeatmap(); // Initial heatmap load attempt
        updateLegend(); // Initial legend load attempt
        loadInlineDendrogram(); // Initial tree load attempt
        updateTimeInfoDisplay(); // Fetch time info on initial load

        // --- Listener for Cancel Loading Button ---
        const cancelLoadingButton = document.getElementById('cancelLoadingBtn');
        if (cancelLoadingButton) {
            cancelLoadingButton.addEventListener('click', () => {
                console.log("Cancel button clicked - Attempting to abort ongoing CSV processing.");
                if (csvProcessingController) {
                    csvProcessingController.abort();
                    console.log("Abort signal sent to CSV processing fetch.");
                } else {
                    console.log("No active CSV processing fetch to abort.");
                }
                hideLoading();
            });
        } else { console.error("Cancel loading button not found."); }

        // --- Listener for File Input ---
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                if (csvProcessingController) {
                    console.log("Aborting previous CSV processing request...");
                    csvProcessingController.abort();
                }
                csvProcessingController = new AbortController();
                const signal = csvProcessingController.signal;

                showLoading();
                const reader = new FileReader();
                reader.onload = function(e) {
                    const csvText = e.target.result;
                    fetch(`${API_BASE_URL}/process_csv`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ csv_text: csvText }),
                        signal: signal // Pass the abort signal
                    })
                    .then(response => {
                        // Check if response is ok, otherwise parse error JSON
                        if (!response.ok) {
                            return response.json().then(err => {
                                // Construct a more informative error
                                let error = new Error(err.error || `Processing failed (${response.status})`);
                                error.status = response.status; // Add status code to error object
                                throw error;
                            });
                        }
                        return response.json(); // Parse success JSON (e.g., {"message": "..."})
                    })
                    .then(confirmationData => { // Receive the JSON data on success
                        console.log('CSV processed successfully:', confirmationData.message); // Log success message
                        csvProcessingController = null; // Reset controller
                        updateHeatmap();
                        updateLegend();
                        loadInlineDendrogram(); // Reload dendrogram after processing
                        updateTimeInfoDisplay(); // <<< UPDATE TIME INFO DISPLAY HERE
                        clearSidebarVisualization();
                        toggleSidebar(false);
                        // Show 'Show Tree' button only if dendrogram load was successful
                        // (Check if window.lastTreeData exists after loadInlineDendrogram completes)
                        // We might need loadInlineDendrogram to return a promise
                        if (window.lastTreeData && Object.keys(window.lastTreeData).length > 0) {
                            document.getElementById('showTreeBtn').style.display = 'inline-block';
                        } else {
                            document.getElementById('showTreeBtn').style.display = 'none';
                        }
                        hideLoading();
                    })
                    .catch(error => {
                        csvProcessingController = null; // Reset controller on error/abort
                        hideLoading(); // Hide loading overlay
                        if (error.name === 'AbortError') {
                            console.log('Fetch aborted (CSV processing cancelled by user).');
                            alert("CSV processing cancelled.");
                        } else {
                            console.error('Error processing file:', error);
                            // Display specific error from backend if available
                            alert(`Error processing file: ${error.message}`);
                        }
                        // Optionally clear displays on error
                        document.getElementById('heatmap').innerHTML = '<p style="color: red; text-align: center;">Could not process CSV data.</p>';
                        d3.select("#inlineDendrogramSvg").selectAll("*").remove();
                        const treeInfoSpan = document.getElementById('treeInfoSpan');
                        if(treeInfoSpan) treeInfoSpan.textContent = '';
                        const timeInfoSpan = document.getElementById('timeInfoSpan');
                        if(timeInfoSpan) timeInfoSpan.textContent = '';
                        updateLegend(); // Update legend to show global (likely empty) state
                    });
                };
                reader.onerror = function(e) {
                    console.error("Error reading file:", e);
                    alert("Error reading file.");
                    hideLoading();
                    csvProcessingController = null; // Reset controller
                };
                reader.readAsText(file);
            }
            event.target.value = null; // Allow re-uploading the same file
        });

        // --- Other event listeners (download, filters, pagination, etc.) ---
        // ... (ensure all previously added listeners are still here) ...

        // --- Listener for Hide/Show Dendrogram Buttons ---
        const hideBtn = document.getElementById('hideTreeBtn');
        const showBtn = document.getElementById('showTreeBtn');
        if (hideBtn) { hideBtn.addEventListener('click', hideDendrogram); }
        else { console.error("Hide Tree button not found."); }
        if (showBtn) { showBtn.addEventListener('click', showDendrogram); }
        else { console.error("Show Tree button not found."); }

        // --- Listener for Sidebar Layout Selector ---
        const sidebarLayoutSelect = document.getElementById('sidebarLayoutSelect');
        if(sidebarLayoutSelect) sidebarLayoutSelect.addEventListener('change', applySidebarLayout);

        // --- Listener for Main Filter Button ---
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        if(applyFiltersBtn) applyFiltersBtn.addEventListener('click', updateHeatmap);

        // --- Listener for Main Table Pagination Button ---
        const goPageBtn = document.getElementById('goPageBtn');
        if(goPageBtn) goPageBtn.addEventListener('click', function () {
            let pageInput = document.getElementById('currentPageInput');
            let page = parseInt(pageInput.value, 10);
            const totalPagesStr = document.getElementById('totalPages').textContent;
            const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
            if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity) && currentClusterID) {
                loadClusterTablePage(currentClusterID, page);
            } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
        });

        // --- Listeners for Main Graph Size Controls ---
        const nodeSizeMin = document.getElementById('nodeSizeMin');
        const nodeSizeMax = document.getElementById('nodeSizeMax');
        const edgeWidthMin = document.getElementById('edgeWidthMin');
        const edgeWidthMax = document.getElementById('edgeWidthMax');
        if(nodeSizeMin) nodeSizeMin.addEventListener('input', applySizeControls);
        if(nodeSizeMax) nodeSizeMax.addEventListener('input', applySizeControls);
        if(edgeWidthMin) edgeWidthMin.addEventListener('input', applySizeControls);
        if(edgeWidthMax) edgeWidthMax.addEventListener('input', applySizeControls);

        // --- Listeners for Edge Filter Panel ---
        const applyEdgeFilterBtn = document.getElementById('applyEdgeFilterBtn');
        const clearEdgeFilterBtn = document.getElementById('clearEdgeFilterBtn');
        if(applyEdgeFilterBtn) applyEdgeFilterBtn.addEventListener('click', applyEdgeFilter);
        if(clearEdgeFilterBtn) clearEdgeFilterBtn.addEventListener('click', clearEdgeFilter);

        // --- Listener for Download Button ---
        const downloadButton = document.getElementById('downloadButton');
        if(downloadButton) downloadButton.addEventListener('click', function() {
            // Add check if data exists?
            if(global_df && global_df.length > 0) { // Check if global_df is populated client-side (if kept)
                window.location.href = `${API_BASE_URL}/download_csv`;
            } else {
                // Check backend state via time_info or another endpoint?
                fetch(`${API_BASE_URL}/time_info`).then(res => {
                    if(res.ok) {
                        window.location.href = `${API_BASE_URL}/download_csv`;
                    } else {
                        alert("No processed data available to download. Please upload a CSV file first.");
                    }
                }).catch(() => alert("Could not check data status. Please upload a CSV file first."));
            }
        });

        // --- Listener for Sidebar Pagination ---
        const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');
        if (sidebarGoPageBtn) sidebarGoPageBtn.addEventListener('click', function () {
            let pageInput = document.getElementById('sidebarCurrentPageInput');
            let page = parseInt(pageInput.value, 10);
            const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
            const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
            if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
                if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                    loadSidebarClusterTable(currentSidebarTableClusterId, page);
                } else if (sidebarTableMode === 'edges') {
                    let edgeList = [];
                    if (selectedNodeId && sidebarCy) { const node = sidebarCy.getElementById(selectedNodeId); if (node && node.length > 0) { edgeList = node.connectedEdges().map(edge => ({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') })); } }
                    else if (selectedSidebarEdges.size > 0) { edgeList = Array.from(selectedSidebarEdges).map(key => { const parts = key.split('|'); return { source: parts[0], destination: parts[1], protocol: parts[2] }; }); }
                    if (edgeList.length > 0) { loadSidebarMultiEdgeTable(edgeList, page); }
                    else { console.warn("Sidebar pagination clicked in edge mode, but no edges identified as selected."); }
                } else { console.warn("Sidebar pagination clicked but current table context is unclear."); }
            } else { alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`); }
        });

        // --- Listener for Sidebar Reset Button ---
        const resetSidebarBtn = document.getElementById('resetSidebarBtn');
        if(resetSidebarBtn) resetSidebarBtn.addEventListener('click', () => {
            console.log("Resetting sidebar view and associated highlights.");
            clearSidebarVisualization();
            resetHeatmapHighlights(); // Resets heatmap cell colors
            highlightTreeClusters(); // Resets tree node colors/styles
            selectedNodeId = null;
            document.getElementById('sidebarLayoutSelect').value = 'cose'; // Reset layout dropdown
            updateLegend(); // Update legend to global scope if sidebar is cleared
            console.log("Sidebar reset complete.");
        });

        // --- Listener for Sidebar Toggle Button ---
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');
        if(sidebarToggleBtn) sidebarToggleBtn.addEventListener('click', () => toggleSidebar());

        // --- Listener for Dendrogram Sort Metric Dropdown ---
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        if (metricSelect) {
            metricSelect.addEventListener('change', () => {
                if (window.lastTreeData) {
                    console.log(`Redrawing dendrogram, ordering by: ${metricSelect.value}`);
                    // Use the stored height to prevent shrinking on redraw
                    showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                    // Reset zoom after redraw based on new sort? Optional.
                    // resetInlineZoom();
                } else {
                    console.warn("Cannot redraw dendrogram: No tree data available (window.lastTreeData is null). Load tree first.");
                }
            });
        }

        // --- Listener for Threshold Slider ---
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValueSpan = document.getElementById('thresholdValue');

        if (thresholdSlider && thresholdValueSpan) {
            thresholdSlider.addEventListener('input', () => {
                const percentage = parseInt(thresholdSlider.value, 10);
                thresholdValueSpan.textContent = percentage + '%';

                const svg = d3.select("#inlineDendrogramSvg");
                const svgNode = svg.node();
                if (!svgNode) return;
                const svgContent = svg.select("g"); // The group affected by zoom/pan

                // Use the stored processed hierarchy root and calculated layout width
                const root = window.lastTreeRoot;
                const treeLayoutWidth = window.currentLayoutWidth; // Width used for layout

                if (!root || svgContent.empty() || treeLayoutWidth === undefined) { // Check treeLayoutWidth too
                    // console.warn("Stored tree root, SVG content, or layout width not ready for threshold update.");
                    svg.select("#threshold-bar").style("display", "none");
                    return; // Exit if essential elements aren't ready
                }

                const allVisualNodes = svgContent.selectAll('.node'); // The <g> elements in the SVG

                if (allVisualNodes.empty()) {
                    svg.select("#threshold-bar").style("display", "none");
                    return;
                }

                // --- Calculate Threshold Y in D3 Layout Coordinate System ---
                // Height used during layout calculation (must be consistent with showInlineDendrogram)
                const height = Math.max(200, currentDendrogramHeight - margin.top - margin.bottom);
                // Percentage maps directly to the layout height (assuming root y=0, leaves y=height)
                const thresholdLayoutY = height * (percentage / 100);

                // --- Gray out Nodes based on Stored Layout Y Coordinate ---
                // D3 binds the hierarchy node data (like 'd') to the visual elements (<g class="node">)
                allVisualNodes.each(function(d) { // 'd' here *is* the bound hierarchy node data
                    if (d && typeof d.y === 'number') { // Check if data 'd' exists and has a numeric y property
                        // Apply/remove class based on layout coordinate comparison
                        d3.select(this).classed('grayed-out', d.y > thresholdLayoutY + 1e-6); // Add epsilon for floating point
                    } else {
                        // Optional: Handle cases where data binding might be missing or invalid
                        // d3.select(this).classed('grayed-out', false); // Ensure it's not grayed out if data is bad
                    }
                });

                // --- Position the Visual Threshold Bar ---
                const transform = d3.zoomTransform(svgNode); // Get the current D3 zoom transform (k, x, y)

                // --- CORRECTED VISUAL COORDINATE CALCULATION ---
                // Incorporate margin.top before applying zoom scale/translation
                const thresholdVisualY = ((thresholdLayoutY + margin.top) * transform.k) + transform.y;

                // Incorporate margin.left before applying zoom scale/translation for horizontal extent
                const barX1 = ((0 + margin.left) * transform.k) + transform.x; // Visual X for layout x=0 + margin
                const barX2 = ((treeLayoutWidth + margin.left) * transform.k) + transform.x; // Visual X for layout x=layoutWidth + margin
                // --- END CORRECTION ---

                // Ensure bar is visible and update its position and width
                svg.select("#threshold-bar")
                    .style("display", null) // Make sure it's visible
                    .attr("y1", thresholdVisualY)
                    .attr("y2", thresholdVisualY)
                    .attr("x1", barX1)
                    .attr("x2", barX2);

            }); // End of event listener callback

            // --- Initial Trigger Logic ---
            // This part tries to trigger the slider's 'input' event once after the initial tree render.
            if (window.lastTreeData) { // Check if raw data exists (used as proxy for tree load attempt)
                requestAnimationFrame(() => { // Wait for next frame render cycle
                    const initialSlider = document.getElementById('thresholdSlider');
                    // Ensure the processed root AND the SVG content group exist before triggering
                    if (initialSlider && window.lastTreeRoot && d3.select("#inlineDendrogramSvg g").node()) {
                         console.log("Triggering initial threshold calculation.");
                         initialSlider.dispatchEvent(new Event('input'));
                    } else {
                         console.warn("Initial threshold trigger skipped: Processed root or SVG content not ready yet.");
                         // Attempt to hide the bar if it can't be positioned initially
                         d3.select("#threshold-bar").style("display", "none");
                    }
                 });
            } else {
                 // Ensure bar is hidden if no tree data exists on load
                 d3.select("#threshold-bar").style("display", "none");
            }

        } else { // End of check for slider/span elements
            console.error("Could not find threshold slider or value span elements.");
        }

    }); // End DOMContentLoaded

    // --- BEGIN Dendrogram JS Functions ---
    function showInlineDendrogram(data, svgH = 400) {
        const containerDiv = document.getElementById("inline-dendrogram-container");
        if (!containerDiv) {
            console.error("Dendrogram container div (#inline-dendrogram-container) not found! Cannot render tree.");
            const svg = d3.select("#inlineDendrogramSvg");
            svg.selectAll("*").remove();
            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central")
            .text("Error: Container element not found.");
            document.getElementById("treeControls").style.display = "none";
            // Clear info spans if container is missing
            const treeInfoSpan = document.getElementById('treeInfoSpan');
            if (treeInfoSpan) treeInfoSpan.textContent = '';
            const timeInfoSpan = document.getElementById('timeInfoSpan');
            if (timeInfoSpan) timeInfoSpan.textContent = '';
            window.lastTreeRoot = null; // Reset stored root on error
            return;
        }

        currentDendrogramHeight = svgH;
        document.getElementById('dendrogramCard').style.display = 'block';
        document.getElementById('showTreeBtn').style.display = 'none';

        containerDiv.style.height = `${svgH}px`; // Set container height based on input

        const svg = d3.select("#inlineDendrogramSvg");
        svg.selectAll("*").remove(); // Clear previous drawing

        // Add the threshold bar line (initially invisible/unpositioned)
        svg.append("line")
            .attr("id", "threshold-bar")
            .attr("stroke", "rgba(220, 53, 69, 0.7)")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5 3")
            .style("pointer-events", "none")
            .style("display", "none"); // Initially hidden

        // --- Clear Info Spans Initially ---
        const treeInfoSpan = document.getElementById('treeInfoSpan');
        if (treeInfoSpan) treeInfoSpan.textContent = '';
        // Time info is updated separately by updateTimeInfoDisplay()

        if (!data || data.id === undefined || data.dist === undefined) {
            console.error("Invalid or empty tree data received:", data);
            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central")
            .text("No hierarchical data available or error loading.");
            document.getElementById("treeControls").style.display = "none";
            // Ensure info spans are cleared on error
            if (treeInfoSpan) treeInfoSpan.textContent = '';
            window.lastTreeRoot = null; // Reset stored root on error
            return;
        }

        // --- Basic Setup ---
        const containerWidth = containerDiv.clientWidth || 600; // Use clientWidth as fallback
        const height = Math.max(200, svgH - margin.top - margin.bottom); // Use global margin
        const root = d3.hierarchy(data); // Create hierarchy

        // --- Calculate and Display Tree Info ---
        const leafCount = root.leaves().length;
        if (treeInfoSpan) {
        treeInfoSpan.textContent = `(${leafCount} leaf nodes)`; // Update the span
        }
        // --- End Tree Info ---

        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        const selectedMetric = metricSelect ? metricSelect.value : 'Default';
        const minLeafSpacing = 20;

        let layoutWidth; // Declare layoutWidth

        // --- Conditional Layout Logic (Structure vs Metric) ---
        if (selectedMetric === 'Default') {
            console.log("Applying D3 default cluster layout (structure-based).");
            // Default D3 cluster layout
            const numLeaves = root.leaves().length;
            const requiredWidth = numLeaves * minLeafSpacing;
            const widthAvailableInContainer = Math.max(300, containerWidth - margin.left - margin.right);
            layoutWidth = Math.max(requiredWidth, widthAvailableInContainer);
            window.currentLayoutWidth = layoutWidth; // Store final width for threshold bar
            d3.cluster().size([layoutWidth, height])(root); // Calculates node.x and node.y
            console.log(`Default layout width: ${layoutWidth}`);
        } else {
            console.log(`Applying manual layout based on metric: ${selectedMetric}`);
            // Manual layout based on metric sort order
            // 1. Calculate d.y using d3.cluster
            d3.cluster().size([1, height])(root); // Calculates d.y based on depth

            // 2. Get leaves and sort them
            const leaves = root.leaves();
            let sortedLeaves = [...leaves];
            const currentSortOrder = (window.heatmapSortOrders && window.heatmapSortOrders[selectedMetric]) ? window.heatmapSortOrders[selectedMetric] : null;

            if (currentSortOrder && currentSortOrder.length > 0) {
                console.log(`Using heatmap '${selectedMetric}' sort order.`);
                // Use heatmap sort order
                const orderMap = new Map(currentSortOrder.map((id, index) => [String(id), index]));
                sortedLeaves.sort((a, b) => {
                    const aClusterId = String(a.data.cluster_id).trim();
                    const bClusterId = String(b.data.cluster_id).trim();
                    const aIndex = orderMap.get(aClusterId);
                    const bIndex = orderMap.get(bClusterId);
                    if (aIndex !== undefined && bIndex !== undefined) return aIndex - bIndex;
                    if (aIndex !== undefined) return -1;
                    if (bIndex !== undefined) return 1;
                    // Fallback sort (numeric if possible)
                    const idA = parseInt(aClusterId, 10); const idB = parseInt(bClusterId, 10);
                    if (!isNaN(idA) && !isNaN(idB)) return idA - idB;
                    return aClusterId.localeCompare(bClusterId); // String fallback
                });
            } else {
                // Fallback sort (numeric if possible, else string)
                console.warn(`Sort order for metric '${selectedMetric}' unavailable, using fallback structural order.`);
                sortedLeaves.sort((a,b) => {
                    const idA = parseInt(String(a.data.cluster_id).trim(), 10);
                    const idB = parseInt(String(b.data.cluster_id).trim(), 10);
                    if (!isNaN(idA) && !isNaN(idB)) return idA - idB;
                    return String(a.data.cluster_id).trim().localeCompare(String(b.data.cluster_id).trim());
                });
            }

            // 3. Calculate layout width based on sorted leaf spacing
            const numLeaves = sortedLeaves.length;
            const requiredWidth = numLeaves * minLeafSpacing;
            const widthAvailableInContainer = Math.max(300, containerWidth - margin.left - margin.right);
            layoutWidth = Math.max(requiredWidth, widthAvailableInContainer);
            window.currentLayoutWidth = layoutWidth; // Store final width

            // 4. Manually assign x coordinates to leaves
            const leafSpacing = numLeaves > 1 ? layoutWidth / (numLeaves - 1) : layoutWidth / 2;
            sortedLeaves.forEach((leaf, i) => { leaf.x = i * leafSpacing; });

            // 5. Manually calculate internal node x positions (average of children)
            root.eachAfter(node => {
                if (!node.children || node.children.length === 0) return;
                node.x = d3.mean(node.children, d => d.x); // Use d3.mean for clarity
            });
            console.log(`Manual layout width for ${selectedMetric}: ${layoutWidth}`);
        }

        // <<< STORE THE PROCESSED ROOT WITH COORDINATES >>>
        window.lastTreeRoot = root;
        // <<< END STORING ROOT >>>

        // --- Rendering Code ---
        // <<< START VIEWBOX CALCULATION >>>
        const viewBoxWidth = window.currentLayoutWidth + margin.left + margin.right;
        const viewBoxHeight = height + margin.top + margin.bottom;
        svg.attr("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`)
        .attr("preserveAspectRatio", "xMidYMid meet");
        // <<< END VIEWBOX CALCULATION >>>

        const svgContent = svg.append("g"); // Group for zoomable content

        // Draw Links
        svgContent.selectAll(".link")
            .data(root.links()) // Use links from the *processed* root
            .join("path")
            .attr("class", "link")
            .attr("d", d => {
                // Add validation for coordinates just in case layout produced non-numbers
                const sourceX = typeof d.source.x === 'number' && isFinite(d.source.x) ? d.source.x : 0;
                const sourceY = typeof d.source.y === 'number' && isFinite(d.source.y) ? d.source.y : 0;
                const targetX = typeof d.target.x === 'number' && isFinite(d.target.x) ? d.target.x : 0;
                const targetY = typeof d.target.y === 'number' && isFinite(d.target.y) ? d.target.y : 0;
                const midY = (sourceY + targetY) / 2;
                const validMidY = typeof midY === 'number' && isFinite(midY) ? midY : sourceY;
                // Apply margin.left and margin.top offset to rendering coordinates
                return `M${sourceX + margin.left},${sourceY + margin.top}V${validMidY + margin.top}H${targetX + margin.left}V${targetY + margin.top}`;
            })
            .attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 1.5);

        // Draw Node groups
        const node = svgContent.selectAll(".node")
            .data(root.descendants()) // Use descendants from the *processed* root
            .join("g")
            .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
            .attr("transform", d => {
                // Add validation for coordinates
                const x = typeof d.x === 'number' && isFinite(d.x) ? d.x : 0;
                const y = typeof d.y === 'number' && isFinite(d.y) ? d.y : 0;
                // Apply margin.left and margin.top offset here as well
                return `translate(${x + margin.left},${y + margin.top})`;
            });

        // Draw Circles
        node.append("circle").attr("r", 4).attr("fill", d => d.children ? "#555" : "#999");

        // Draw Labels
        node.append("text")
            .attr("dy", "0.31em")
            .attr("y", d => d.children ? -10 : 10)
            .attr("text-anchor", d => d.children ? "middle" : "start")
            .attr("font-size", "9px")
            .attr("fill", "#333")
            .text(d => d.data.id || "") // Use node ID from original data
            .style("user-select", "none")
            .filter(d => !d.children)
                .attr("transform", "translate(4, 0) rotate(45)");

        // --- Zoom and Pan ---
        // <<< START CORRECTED INITIAL TRANSFORM CALCULATION >>>
        let dx = 0; // Default translation
        let dy = 0;
        let initialScale = 1; // Default scale

        try {
            // Get bounds *after* rendering the content AND applying margins
            const bounds = svgContent.node().getBBox();

            if (bounds.width > 0 && bounds.height > 0) {
                 // Calculate scales needed to fit bounds into the VIEWBOX dimensions
                 const scaleX = viewBoxWidth / bounds.width;
                 const scaleY = viewBoxHeight / bounds.height;

                 // Use the smaller scale factor to ensure the entire tree fits ('meet')
                 // Apply a slight padding (e.g., 95%)
                 initialScale = Math.min(scaleX, scaleY) * 0.95;

                 // Ensure initial scale is not excessively small (minimum zoom) or large (max zoom)
                 initialScale = Math.max(0.1, Math.min(initialScale, 2)); // Example limits

                 // Calculate translation needed to center the SCALED bounds within the VIEWBOX
                 dx = (viewBoxWidth / 2) - ((bounds.x + bounds.width / 2) * initialScale);
                 dy = (viewBoxHeight / 2) - ((bounds.y + bounds.height / 2) * initialScale);

                 // Basic sanity check for calculated values
                 if (isNaN(dx)) dx = 0;
                 if (isNaN(dy)) dy = 0;
                 if (isNaN(initialScale) || initialScale <= 0) initialScale = 1;

            } else {
                console.warn("Could not get valid bounds for initial zoom calculation. Using defaults.");
                dx = margin.left; // Fallback: Use margins
                dy = margin.top;
                initialScale = 1;
            }
        } catch (e) {
             console.error("Error calculating tree bounds for initial zoom:", e);
             dx = margin.left; // Fallback on error
             dy = margin.top;
             initialScale = 1;
        }

        // Store the calculated (or default) initial transform
        initialTreeTransform = d3.zoomIdentity.translate(dx, dy).scale(initialScale);
        console.log("Calculated Initial Transform:", initialTreeTransform);
        // <<< END CORRECTED INITIAL TRANSFORM CALCULATION >>>

        const zoomBehavior = d3.zoom()
            .scaleExtent([0.05, 10]) // Define zoom limits
             // Define the area within which the user can pan
            .translateExtent([[0, 0], [viewBoxWidth, viewBoxHeight]])
            .on("zoom.main", (event) => {
                svgContent.attr("transform", event.transform);
                // Trigger threshold update after the SVG content has been transformed
                const thresholdSlider = document.getElementById('thresholdSlider');
                if (thresholdSlider) {
                    requestAnimationFrame(() => { // Ensures D3 transform is rendered
                        thresholdSlider.dispatchEvent(new Event('input'));
                    });
                }
            });

        window.inlineZoom = zoomBehavior;
        svg.call(zoomBehavior)
            // Apply the calculated initial transform immediately
            .call(zoomBehavior.transform, initialTreeTransform)
            .on("dblclick.zoom", null); // Disable double-click zoom reset (use button)


        // --- Final Steps ---
        document.getElementById("treeControls").style.display = "flex";
        window.lastTreeData = data; // Store raw data
        highlightTreeClusters(new Set(clusterHighlightColors.keys())); // Apply any existing highlights

        // Apply initial threshold state *after* drawing and storing the processed root
        const initialSlider = document.getElementById('thresholdSlider');
        if (initialSlider) {
            requestAnimationFrame(() => { // Wait for render cycle
                // Ensure the processed root exists before triggering the initial threshold calc
                if (window.lastTreeRoot && d3.select("#inlineDendrogramSvg g").node()) {
                    console.log("Triggering initial threshold calculation after draw.");
                    initialSlider.dispatchEvent(new Event('input'));
                } else {
                    console.warn("Initial threshold trigger skipped: Processed root node or SVG content not available yet.");
                    d3.select("#threshold-bar").style("display", "none"); // Hide bar if it cannot be calculated
                }
            });
        }
    } // --- End of showInlineDendrogram ---

    function highlightTreeClusters(selectedClusterIds = new Set()) {
        const svgContent = d3.select("#inlineDendrogramSvg g");
        if (svgContent.empty()) {
            return; // Tree not rendered yet
        }

        const leafNodes = svgContent.selectAll(".node--leaf"); // Select the group containing circle and text
        const leafCircles = leafNodes.select("circle");
        const leafTexts = leafNodes.select("text");
        const defaultTextColor = "#333"; // Default text color

        // Reset all leaves first
        leafCircles.classed("highlighted", false)
                  .transition().duration(150)
                  .attr("r", 4) // Default radius
                  .style("fill", "#999") // Default leaf circle color
                  .style("stroke", "none");

        leafTexts.transition().duration(150)
                .style("fill", defaultTextColor) // Reset text color
                .style("font-weight", "normal"); // Reset font weight

        // Apply highlights based on the provided set and stored colors
        if (selectedClusterIds.size > 0) {
            selectedClusterIds.forEach(clusterId => {
                const stringClusterId = String(clusterId); // Ensure string comparison
                // Get the correct highlight color from the global map
                const highlightColor = clusterHighlightColors.get(stringClusterId);

                if (highlightColor) { // Only highlight if found in the map
                    // Find the matching leaf node(s)
                    const matchedNodes = leafNodes.filter(function(d) {
                        return d && d.data && String(d.data.cluster_id) === stringClusterId;
                    });

                    // Highlight the circle
                    matchedNodes.select("circle")
                        .classed("highlighted", true)
                        .transition().duration(150)
                        .attr("r", 6) // Highlighted radius
                        .style("fill", highlightColor) // Use the specific highlight color from map
                        .style("stroke", "none");

                    // --- Modify Text Color ---
                    try {
                        // Parse the highlight color (assuming HSL format like "hsl(H, S%, L%)")
                        let color = d3.hsl(highlightColor);

                        // Lower saturation (e.g., reduce by 40%, ensure it's between 0 and 1)
                        color.s = Math.max(0, Math.min(1, color.s * 0.6));

                        // Optional: Slightly increase lightness for readability, especially if saturation is low
                        if (color.s < 0.3) {
                            color.l = Math.min(1, color.l + 0.1);
                        }
                        // Ensure lightness isn't too high (avoid white on white)
                        color.l = Math.min(0.85, color.l);

                        const textColor = color.toString(); // Convert back to string

                        // Apply the modified color to the text
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", textColor)
                            .style("font-weight", "bold"); // Make text bold for emphasis

                    } catch (e) {
                        console.error("Could not parse highlight color for text:", highlightColor, e);
                        // Fallback: Apply a default highlight color to text if parsing fails
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", "#d95f02") // Fallback color (dark orange)
                            .style("font-weight", "bold");
                    }
                    // --- End Text Color Modification ---

                } else {
                    console.warn(`Highlight color not found in map for cluster ${stringClusterId}`);
                }
            });
        }
    }

    function hideDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'none';
        showButton.style.display = 'inline-block'; // Show the 'Show Tree' button
        console.log("Dendrogram hidden.");
    }

    function showDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'block';    // Show the card
        showButton.style.display = 'none'; // Hide the 'Show Tree' button

        // Optional: Reload or redraw if needed when shown
        if (!window.lastTreeData) {
            console.log("No tree data, loading...");
            loadInlineDendrogram(); // Load data if it wasn't loaded before
        } else {
            console.log("Showing existing dendrogram.");
            // You could potentially redraw or fit view here if desired
            // showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight);
            // resetInlineZoom();
        }
    }
    
    // Optional Helper Function to fit view (Example)
    function fitView() {
        const svg = d3.select("#inlineDendrogramSvg");
        const svgContent = svg.select("g"); // Assumes content is in the first 'g'
        if (!svgContent.empty() && window.inlineZoom) {
            const bounds = svgContent.node().getBBox();
            const parent = svg.node();
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width === 0 || height === 0) return; // Nothing to fit

            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

            svg.transition().duration(750).call(
                window.inlineZoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }
    }

    // Make sure the resetInlineZoom function still uses d3.zoomIdentity
    function resetInlineZoom() {
        const svg = d3.select("#inlineDendrogramSvg");
        if (window.inlineZoom) {
            // Reset zoom with a smooth transition TO THE STORED INITIAL CENTERED TRANSFORM
            svg.transition().duration(500)
                .call(window.inlineZoom.transform, initialTreeTransform);
            console.log("Inline dendrogram zoom reset to initial view.");
        } else {
            console.warn("Cannot reset zoom, zoom behavior not initialized.");
        }
    }

    function loadInlineDendrogram() {
      console.log("Attempting to load inline dendrogram data...");
      fetch(`${API_BASE_URL}/hierarchical_clusters`) // Use API_BASE_URL
          .then(response => {
              if (!response.ok) {
                  return response.text().then(text => { throw new Error(text || `HTTP error ${response.status}`) });
              }
              return response.json();
            })
          .then(data => {
              console.log("Dendrogram data received:", data);
              if (Object.keys(data).length === 0 || (data.error)) {
                  console.error("Empty or error data received for dendrogram.");
                  showInlineDendrogram(null); // Show error state
              } else {
                    showInlineDendrogram(data); // Render the tree
              }
          })
          .catch(err => {
              console.error("Failed to load or render inline dendrogram:", err);
                showInlineDendrogram(null); // Show error state in the SVG
          });
    }

    function formatDuration(seconds) {
        if (seconds === null || seconds === undefined || isNaN(seconds) || seconds < 0) {
            return "N/A";
        }
        if (seconds < 60) {
            return `${seconds.toFixed(2)}s`; // More concise seconds
        }
        let minutes = Math.floor(seconds / 60);
        let remainingSeconds = Math.floor(seconds % 60); // Use floor for whole seconds
        if (minutes < 60) {
            return `${minutes}m ${remainingSeconds}s`;
        }
        let hours = Math.floor(minutes / 60);
        let remainingMinutes = minutes % 60;
        if (hours < 24) {
            return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
        }
        let days = Math.floor(hours / 24);
        let remainingHours = hours % 24;
        // Omit seconds for durations >= 1 day for brevity
        return `${days}d ${remainingHours}h ${remainingMinutes}m`;
    }

    function updateTimeInfoDisplay() {
        const timeInfoSpan = document.getElementById('timeInfoSpan');
        if (!timeInfoSpan) {
            console.error("timeInfoSpan element not found");
            return;
        }

        timeInfoSpan.textContent = 'Loading time info...'; // Indicate loading

        fetch(`${API_BASE_URL}/time_info`)
            .then(response => {
            if (!response.ok) {
                // If 404 (no data), clear the span. Otherwise, show error.
                if (response.status === 404) {
                    return response.json().then(err => {
                        console.log("Time info not available:", err.error);
                        return null; // Resolve with null to clear display
                    });
                }
                // For other errors, try to get text, then throw
                return response.text().then(text => { throw new Error(text || `HTTP error ${response.status}`) });
            }
            return response.json();
            })
            .then(data => {
            if (data && data.start_time && data.end_time && data.duration_seconds !== null && !isNaN(data.duration_seconds)) {
                // Attempt to parse dates safely
                let startTimeStr = "Invalid Date";
                let endTimeStr = "Invalid Date";
                try {
                    startTimeStr = new Date(data.start_time).toLocaleString();
                    endTimeStr = new Date(data.end_time).toLocaleString();
                    // Check if parsing resulted in "Invalid Date"
                    if (startTimeStr === "Invalid Date" || endTimeStr === "Invalid Date") {
                        throw new Error("Date parsing resulted in Invalid Date");
                    }
                } catch (dateError) {
                    console.error("Error formatting dates:", dateError);
                    // Use raw ISO strings as fallback if parsing fails
                    startTimeStr = data.start_time || "N/A";
                    endTimeStr = data.end_time || "N/A";
                }

                const durationFormatted = formatDuration(data.duration_seconds);
                timeInfoSpan.textContent = `| Start: ${startTimeStr} | End: ${endTimeStr} | Duration: ${durationFormatted}`;
            } else {
                console.log("Clearing time info span (no/incomplete data received).");
                timeInfoSpan.textContent = ''; // Clear if no data or incomplete data
            }
            })
            .catch(error => {
            console.error('Error fetching or processing time info:', error);
            timeInfoSpan.textContent = '| Time info unavailable'; // Display error message
            });
        }

    function reclusterAndRedraw() {
        const resolutionInput = document.getElementById('resolutionInput');
        const resolution = parseFloat(resolutionInput.value);
        const messageDiv = document.getElementById('reclusterMessage');
        const treeInfoSpan = document.getElementById('treeInfoSpan'); // Get info span

        if (isNaN(resolution) || resolution <= 0) {
            messageDiv.textContent = "Please enter a valid resolution > 0.";
            resolutionInput.focus();
            return;
        }

        messageDiv.textContent = "Applying resolution and reclustering..."; // Loading message
        if (treeInfoSpan) treeInfoSpan.textContent = ''; // Clear tree info during recluster
        console.log(`Requesting recluster with resolution: ${resolution}`);
        showLoading(); // Show main loading overlay

        // Fetch new hierarchy data with the specified resolution
        fetch(`<span class="math-inline">\{API\_BASE\_URL\}/hierarchical\_clusters?resolution\=</span>{resolution}`)
            .then(response => {
                    if (!response.ok) {
                        // Try to parse error message from backend JSON response
                        return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) });
                    }
                    return response.json();
            })
            .then(treeData => {
                    console.log("Reclustered tree data received:", treeData);

                    // Check for structural changes to provide feedback
                    let currentLeafCount = 0;
                    (function countLeaves(node) { // Simple recursive leaf counter
                        if (!node || typeof node !== 'object') return;
                        if (!node.children || node.children.length === 0) {
                        if(node.cluster_id !== undefined) currentLeafCount++; // Count only actual leaves with cluster_id
                        } else {
                        node.children.forEach(countLeaves);
                        }
                    })(treeData);

                    // --- Update Tree Info Span ---
                    if (treeInfoSpan) {
                        treeInfoSpan.textContent = `(${currentLeafCount} leaf nodes)`;
                    }
                    // --- End Update ---

                    // Basic structural comparison (can be improved)
                    const currentHash = JSON.stringify(treeData);
                    const structureChanged = (
                        previousClusterCount === null ||
                        currentLeafCount !== previousClusterCount ||
                        currentHash !== previousClusterHash
                    );

                    previousClusterCount = currentLeafCount; // Update state
                    previousClusterHash = currentHash;      // Update state

                    if (structureChanged) {
                        messageDiv.textContent = `Reclustering complete. ${currentLeafCount} leaf clusters found.`;
                        showInlineDendrogram(treeData, currentDendrogramHeight); // Redraw with current height
                        // Do NOT reset zoom automatically, let user do it if needed
                        // resetInlineZoom();

                        // --- IMPORTANT: Update the main heatmap and legend ---
                        console.log("Updating heatmap and legend after recluster...");
                        updateHeatmap(); // This uses the updated cluster IDs from the backend
                        updateLegend(); // Update legend based on new global state
                        clearSidebarVisualization(); // Clear sidebar as clusters changed
                        toggleSidebar(false); // Close sidebar
                        // --- End Updates ---

                    } else {
                        messageDiv.textContent = "No structural change in clusters. Try a different resolution.";
                        // Even if no structural change, redraw to apply potential sorting changes if metric selected
                        showInlineDendrogram(treeData, currentDendrogramHeight);
                    }
                    hideLoading(); // Hide loading overlay
            })
            .catch(err => {
                console.error("Error during recluster/redraw:", err);
                messageDiv.textContent = `Error: ${err.message || "Failed to recluster."}`;
                if (treeInfoSpan) treeInfoSpan.textContent = ''; // Clear info on error
                hideLoading(); // Hide loading overlay on error too
            });
        }

    function showCustomHeightInput() {
        // Use the stored height for the prompt default
        const customHeight = prompt(`Enter desired tree height in pixels (current: ${currentDendrogramHeight}):`, `${currentDendrogramHeight}`);
        if (customHeight !== null) { // Check if user pressed cancel
            const val = parseInt(customHeight, 10);
            if (!isNaN(val) && val > 50 && val < 5000) { // Basic validation
                if (window.lastTreeData) {
                      currentDendrogramHeight = val; // <<< STORE the new custom height
                      // Redraw using the stored tree data and the new height
                      showInlineDendrogram(window.lastTreeData, currentDendrogramHeight);
                      console.log(`Tree height set to custom value: ${val}px`);
                } else {
                      console.warn("Cannot set custom height, no tree data available.");
                      // If you want the container to resize even without data:
                      // document.getElementById("inline-dendrogram-container").style.height = `${val}px`;
                      // currentDendrogramHeight = val;
                }
            } else {
                alert("Invalid height entered. Please enter a number (e.g., 500).");
            }
        }
    }
    // --- END Dendrogram JS Functions ---
  </script>
</body>
</html>