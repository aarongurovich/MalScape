<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MalScape</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      color: #333;
      background-color: #f8f9fa;
    }
    body { display: flex; }
    #main-container {
      flex: 1;
      padding: 24px;
      height: 100vh;
      overflow-y: auto;
    }
    #legend-container {
      width: 220px;
      background-color: #fff;
      border-left: 1px solid #e9ecef;
      padding: 16px 12px;
      height: 100vh;
      overflow-y: auto;
      box-shadow: -4px 0 8px rgba(0, 0, 0, 0.05);
    }
    h2 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 28px;
      font-weight: 600;
      border-bottom: 2px solid #4299e1;
      padding-bottom: 8px;
      display: inline-block;
    }
    h3 {
      color: #2c3e50;
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      font-weight: 600;
    }
    .control-group {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    label {
      display: inline-block;
      margin-right: 8px;
      font-weight: 500;
      color: #4a5568;
    }
    input[type="text"], input[type="file"], input[type="range"], select {
      padding: 8px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      margin-right: 12px;
      margin-bottom: 8px;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, input[type="range"]:focus, select:focus {
      border-color: #4299e1;
      outline: none;
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.15);
    }
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-right: 8px;
    }
    button:hover { background-color: #3182ce; }
    #unselectButton { background-color: #e53e3e; }
    #unselectButton:hover { background-color: #c53030; }
    #loadMoreBtn {
      display: none;
      margin-top: 16px;
      background-color: #38a169;
    }
    #loadMoreBtn:hover { background-color: #2f855a; }
    #cy {
      width: 100%;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      background-color: #fff;
    }
    #tooltip {
      position: absolute;
      display: none;
      background: #fff;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 13px;
      color: #2d3748;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-width: 300px;
      line-height: 1.5;
    }
    /* Allow the table container to scroll so all columns are visible */
    #table-container {
      margin-top: 24px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      word-wrap: break-word;
    }
    th, td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
      white-space: normal;
    }
    .payload-toggle {
      cursor: pointer;
      color: #4299e1;
      text-decoration: underline;
      display: block;
      margin-top: 5px;
      font-size: 12px;
    }
    .payload-toggle:hover { color: #3182ce; }
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 18px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #loadingOverlay span {
      background: #2d3748;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
    }
    #loadingOverlay span::before {
      content: '';
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid transparent;
      border-top-color: #fff;
      border-radius: 50%;
      margin-right: 12px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      vertical-align: middle;
      margin-right: 4px;
      border: 1px solid #ccc;
    }
    #legend {
      font-size: 12px;
      line-height: 1.4;
    }
    #legend th, #legend td {
      padding: 4px 6px;
    }
    @media (max-width: 1200px) {
      body { flex-direction: column; }
      #legend-container {
        width: 100%;
        height: auto;
        max-height: 300px;
        border-left: none;
        border-top: 1px solid #e9ecef;
        box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.05);
      }
      #main-container { height: auto; padding: 16px; }
    }
  </style>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
</head>
<body>
  <div id="loadingOverlay">
    <span>Processing data, please wait...</span>
  </div>
  <div id="main-container">
    <h2>MalScape</h2>
    <div class="control-group">
      <div>
        <label for="startSource">Start Source IP:</label>
        <input type="text" id="startSource" placeholder="e.g. 192.168.1.10" />
        <label for="startDestination">Start Destination IP:</label>
        <input type="text" id="startDestination" placeholder="e.g. 10.0.0.50" />
      </div>
      <div style="margin-top: 16px;">
        <label for="fileInput">Upload CSV Data:</label>
        <input type="file" id="fileInput" accept=".csv" />
      </div>
      <!-- Timeline controls -->
      <div style="margin-top: 16px;">
        <label for="timeSlider">Timeline:</label>
        <input type="range" id="timeSlider" min="1" max="100" value="100">
        <span id="timeDisplay"></span>
        <button id="playButton">▶</button>
        <select id="speedSelector">
          <option value="1">1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
          <option value="16">16x</option>
          <option value="32">32x</option>
          <option value="64">64x</option>
          <option value="124">124x</option>
          <option value="256">256x</option>
          <option value="512">512x</option>
          <option value="1024">1024x</option>
        </select>
      </div>

      <!-- Visualization filter controls -->
      <div id="visFilterGroup">
        <label for="visFilterColumn">Filter Column:</label>
        <select id="visFilterColumn">
          <option value="No.">No.</option>
          <option value="Time">Time</option>
          <option value="Source">Source</option>
          <option value="Destination">Destination</option>
          <option value="Protocol">Protocol</option>
          <option value="Length">Length</option>
          <option value="Payload">Payload</option>
        </select>
        <label for="keywordInput">Keyword:</label>
        <input type="text" id="keywordInput" list="keywordOptions" placeholder="Select or search keyword" />
        <datalist id="keywordOptions"></datalist>
        <label for="filterAction">Filter Action:</label>
        <select id="filterAction">
          <option value="show">Show Matching Edges</option>
          <option value="hide">Hide Matching Edges</option>
        </select>
        <button id="applyVisFilterBtn">Apply Visualization Filter</button>
        <button id="clearVisFilterBtn">Clear Filter</button>
        <button id="unselectButton">Unselect All Edges</button>
        <button id="unclusterButton">Uncluster Selected Edges</button>
        <button id="reclusterButton">Recluster Selected Edges</button>
        <div id="filterListContainer" style="margin-top: 12px;">
          <h4 style="margin: 0 0 8px 0; font-size: 16px;">Current Filters:</h4>
          <ul id="currentFilters" style="list-style: none; padding: 0; margin: 0;"></ul>
        </div>      
      </div>
    </div>
    <button id="downloadCsvBtn">Download Processed CSV</button>

    <div id="cy"></div>
    <div id="tooltip"></div>
    <div class="control-group">
      <div style="margin-top: 16px;">
        <label for="infoFilterInput">Search Payload:</label>
        <input type="text" id="infoFilterInput" placeholder="Enter search keyword" />
      </div>
    </div>
    <div id="table-container"></div>
    <button id="loadMoreBtn">Load More Rows</button>
    </div>
  <div id="legend-container">
    <h3>Protocol Legend</h3>
    <table id="legend">
      <tr>
        <th>Protocol</th>
        <th>Color</th>
      </tr>
      <!-- Dynamic rows will be added here -->
    </table>
  </div>
  <script>
    // Prevent accidental navigation away
    window.addEventListener('beforeunload', (e) => {
      e.preventDefault();
      e.returnValue = '';
    });

    let globalCsvText = "";
    let csvRows = [];
    let csvHeaders = [];
    let selectedEdges = new Set();
    let globalCy;
    let payloadColumnIndex = -1;
    let currentVisFilters = [];
    let allRowElems = [];
    let displayOffset = 0;
    const PAGE_SIZE = 50;
    let currentAllowed = [];
    let protocolColorMap = {};

    const fileInput = document.getElementById('fileInput');
    const tooltip = document.getElementById('tooltip');
    const unselectButton = document.getElementById('unselectButton');
    const unclusterButton = document.getElementById('unclusterButton');
    const reclusterButton = document.getElementById('reclusterButton');
    const startSourceInput = document.getElementById('startSource');
    const startDestinationInput = document.getElementById('startDestination');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const payloadFilterInput = document.getElementById('infoFilterInput');
    const timeSlider = document.getElementById('timeSlider');
    const timeDisplay = document.getElementById('timeDisplay');
    const playButton = document.getElementById('playButton');
    const speedSelector = document.getElementById('speedSelector');
    const visFilterColumn = document.getElementById('visFilterColumn');
    const keywordInput = document.getElementById('keywordInput');
    const keywordOptions = document.getElementById('keywordOptions');
    const applyVisFilterBtn = document.getElementById('applyVisFilterBtn');
    const clearVisFilterBtn = document.getElementById('clearVisFilterBtn');

    let playInterval;
    let isPlaying = false;

    function randomColor(){
      return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
    }
    
    function updateLegend() {
      const legendTable = document.getElementById('legend');
      legendTable.innerHTML = '<tr><th>Protocol</th><th>Color</th></tr>';
      const protocolSet = new Set();
      for (let i = 1; i < csvRows.length; i++){
        const cols = csvRows[i].split(',').map(s => s.replace(/(^"|"$)/g, ''));
        const protocolIndex = csvHeaders.indexOf('Protocol');
        if (protocolIndex !== -1) {
          const protocol = cols[protocolIndex]?.trim();
          if (protocol) {
            protocolSet.add(protocol);
          }
        }
      }
      Array.from(protocolSet).sort().forEach(protocol => {
        if (!protocolColorMap[protocol]) {
          protocolColorMap[protocol] = randomColor();
        }
        const row = document.createElement('tr');
        row.innerHTML = `<td>${protocol}</td><td><span class="color-box" style="background-color:${protocolColorMap[protocol]}"></span></td>`;
        legendTable.appendChild(row);
      });
    }

    visFilterColumn.addEventListener('change', () => {
      updateKeywordSuggestions();
    });

    playButton.addEventListener('click', () => {
      if (!isPlaying) {
        playButton.textContent = '⏸';
        isPlaying = true;
        playInterval = setInterval(() => {
          let currentValue = parseInt(timeSlider.value);
          let maxValue = parseInt(timeSlider.max);
          let speed = parseFloat(speedSelector.value) || 1;
          let increment = 1 * speed;
          if (currentValue < maxValue) {
            timeSlider.value = Math.min(currentValue + increment, maxValue);
            updateTimeFilter();
          } else {
            clearInterval(playInterval);
            playButton.textContent = '▶';
            isPlaying = false;
          }
        }, 200);
      } else {
        clearInterval(playInterval);
        playButton.textContent = '▶';
        isPlaying = false;
      }
    });

    payloadFilterInput.addEventListener('input', () => {
      updateRowVisibility();
    });

    applyVisFilterBtn.addEventListener('click', () => {
      const col = visFilterColumn.value;
      const keyword = keywordInput.value.trim();
      if (!keyword) {
        alert("Please select or type a keyword.");
        return;
      }
      const action = document.getElementById('filterAction').value;
      currentVisFilters.push({ column: col, keyword: keyword, action: action });
      updateFilterListDisplay();  
      applyVisualizationFilter();
    });

    clearVisFilterBtn.addEventListener('click', () => {
      currentVisFilters = [];
      updateFilterListDisplay(); 
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          edge.show();
        }
      });
      globalCy.nodes().forEach(node => node.show());
      keywordInput.value = "";
    });

    unselectButton.addEventListener('click', () => {
      selectedEdges.clear();
      if (globalCy) {
        globalCy.edges().removeClass('selected');
      }
      updateKeywordSuggestions();
      updateRowVisibility();
    });

    unclusterButton.addEventListener('click', () => {
      if (!globalCy) return;
      let edgesToUncluster = globalCy.edges('.selected').filter(edge => {
        let indices = edge.data('csvIndices') || [];
        return indices.length > 1;
      });
      edgesToUncluster.forEach(edge => {
        let indices = edge.data('csvIndices') || [];
        indices.forEach(idx => {
          let newEdge = createEdgeFromCSVRow(csvRows[idx], idx);
          globalCy.add(newEdge).addClass('selected');
        });
        edge.remove();
        indices.forEach(idx => {
          selectedEdges.delete(idx);
          selectedEdges.add(idx);
        });
      });
      updateKeywordSuggestions();
      updateRowVisibility();
    });

    reclusterButton.addEventListener('click', () => {
      if (!globalCy) return;
      let selected = globalCy.edges('.selected');
      let groups = {};
      selected.forEach(edge => {
        let data = edge.data();
        let key = data.source + '|' + data.target + '|' + data.Protocol;
        if (!groups[key]) groups[key] = [];
        groups[key].push(edge);
      });
      Object.keys(groups).forEach(key => {
        let edgesGroup = groups[key];
        if (edgesGroup.length < 2) return;
        let aggregatedIndices = [];
        edgesGroup.forEach(edge => {
          aggregatedIndices = aggregatedIndices.concat(edge.data('csvIndices'));
        });
        edgesGroup.forEach(edge => edge.remove());
        let parts = key.split('|');
        let newEdge = {
          data: {
            id: `edge-${parts[0]}-${parts[1]}-${parts[2]}`,
            source: parts[0],
            target: parts[1],
            Protocol: parts[2],
            EdgeWeight: aggregatedIndices.length,
            processCount: aggregatedIndices.length,
            csvIndices: aggregatedIndices,
            label: `(${aggregatedIndices.length}) ${parts[2]}`,
            edgeColor: protocolColorMap[parts[2]] || '#000'
          }
        };
        globalCy.add(newEdge).addClass('selected');
        aggregatedIndices.forEach(idx => selectedEdges.add(idx));
      });
      updateKeywordSuggestions();
      updateRowVisibility();
    });

    loadMoreBtn.addEventListener('click', () => {
      displayOffset += PAGE_SIZE;
      showNextChunk();
    });

    // New event listener for downloading the processed CSV file.
    downloadCsvBtn.addEventListener('click', () => {
      if (!globalCsvText) {
        alert("No CSV data to download.");
        return;
      }
      const blob = new Blob([globalCsvText], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "processed_data.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    function setupTimeSlider() {
      let maxTime = 0;
      globalCy.nodes().forEach(node => {
        if (node.data('timeIndex') > maxTime) {
          maxTime = node.data('timeIndex');
        }
      });
      timeSlider.min = 1;
      timeSlider.max = maxTime;
      timeSlider.value = maxTime;
      timeDisplay.textContent = maxTime;
      timeSlider.addEventListener('input', updateTimeFilter);
      updateTimeFilter();
    }

    function updateTimeFilter() {
      let timeValue = parseInt(timeSlider.value);
      timeDisplay.textContent = timeValue;
      if (!globalCy) return;
      globalCy.nodes().forEach(node => {
        if (node.data('timeIndex') <= timeValue) {
          node.show();
        } else {
          node.hide();
        }
      });
      globalCy.edges().forEach(edge => {
        if (edge.source().visible() && edge.target().visible()) {
          edge.show();
        } else {
          edge.hide();
        }
      });
    }

    function updateFilterListDisplay() {
      const currentFiltersList = document.getElementById('currentFilters');
      currentFiltersList.innerHTML = "";
      currentVisFilters.forEach((filter, index) => {
        const li = document.createElement('li');
        li.style.marginBottom = '4px';
        li.style.fontSize = '14px';
        li.textContent = `${filter.action.toUpperCase()} edges where [${filter.column}] contains "${filter.keyword}" `;
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.marginLeft = '8px';
        removeBtn.style.fontSize = '12px';
        removeBtn.addEventListener('click', () => {
          currentVisFilters.splice(index, 1);
          updateFilterListDisplay();
          applyVisualizationFilter();
        });
        li.appendChild(removeBtn);
        currentFiltersList.appendChild(li);
      });
    }

    function updateKeywordSuggestions() {
      keywordOptions.innerHTML = "";
      let uniqueKeywords = new Set();
      const col = visFilterColumn.value;
      const colIndex = csvHeaders.indexOf(col);
      if (colIndex === -1) return;
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          let indices = edge.data('csvIndices') || [];
          indices.forEach(idx => {
            if (idx < 1 || idx >= csvRows.length) return;
            let row = csvRows[idx].split(',').map(s => s.replace(/(^"|"$)/g, ''));
            uniqueKeywords.add(row[colIndex].trim());
          });
        }
      });
      uniqueKeywords.forEach(keyword => {
        if (keyword) {
          let option = document.createElement('option');
          option.value = keyword;
          keywordOptions.appendChild(option);
        }
      });
    }

    function applyVisualizationFilter() {
      if (currentVisFilters.length === 0) {
        globalCy.edges().forEach(edge => {
          if (edge.hasClass('selected')) {
            edge.show();
          }
        });
        return;
      }
      globalCy.edges().forEach(edge => {
        if (edge.hasClass('selected')) {
          let shouldShow = true;
          let indices = edge.data('csvIndices') || [];
          for (const filter of currentVisFilters) {
            const colIndex = csvHeaders.indexOf(filter.column);
            if (colIndex === -1) continue;
            let filterStr = filter.keyword.trim();
            const numericMatch = filterStr.match(/^(>=|<=|>|<)\s*(\d+(\.\d+)?)$/);
            let numericOperator = null, numericValue = null;
            if (numericMatch) {
              numericOperator = numericMatch[1];
              numericValue = parseFloat(numericMatch[2]);
            }
            let isMatch = false;
            for (let idx of indices) {
              if (idx < 1 || idx >= csvRows.length) continue;
              let row = csvRows[idx].split(',').map(s => s.replace(/(^"|"$)/g, ''));
              let cellValueRaw = row[colIndex].trim();
              if (numericOperator !== null) {
                let cellValue = parseFloat(cellValueRaw);
                if (!isNaN(cellValue)) {
                  switch (numericOperator) {
                    case '>': if (cellValue > numericValue) isMatch = true; break;
                    case '<': if (cellValue < numericValue) isMatch = true; break;
                    case '>=': if (cellValue >= numericValue) isMatch = true; break;
                    case '<=': if (cellValue <= numericValue) isMatch = true; break;
                  }
                }
              } else {
                if (cellValueRaw.toLowerCase().includes(filterStr.toLowerCase())) {
                  isMatch = true;
                }
              }
              if (isMatch) break;
            }
            if (filter.action === "show" && !isMatch) {
              shouldShow = false;
              break;
            } else if (filter.action === "hide" && isMatch) {
              shouldShow = false;
              break;
            }
          }
          if (shouldShow) {
            edge.show();
          } else {
            edge.hide();
          }
        }
      });
    }

    async function runBackendScript(csvText, startSource, startDestination) {
      const response = await fetch('http://localhost:5000/process_csv', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          csv_text: csvText,
          start_source: startSource,
          start_destination: startDestination
        })
      });
      if (!response.ok) {
        throw new Error('Error processing CSV: ' + await response.text());
      }
      return await response.text();
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadingOverlay.style.display = "flex";
      try {
        const text = await file.text();
        const userSource = startSourceInput.value.trim();
        const userDestination = startDestinationInput.value.trim(); 
        const processedCSV = await runBackendScript(text, userSource, userDestination);
        // Print the first 50 lines of the processed CSV file to the console.
        console.log("First 50 lines of processed CSV:");
        processedCSV.split('\n').slice(0, 50).forEach(line => console.log(line));
        globalCsvText = processedCSV;
        csvRows = processedCSV.trim().split('\n');
        csvHeaders = csvRows[0].split(',').map(s => s.replace(/(^"|"$)/g, ''));
        updateLegend();
        createFullTable();
        const parsedElements = parseCSV(processedCSV);
        let elementsToVisualize = parsedElements;
        if (userSource) {
          const sourceNode = parsedElements.find(ele => ele.data && ele.data.id === userSource);
          if (sourceNode && sourceNode.data.ClusterID) {
            const targetCluster = sourceNode.data.ClusterID;
            const nodes = parsedElements.filter(ele => !ele.data.source);
            const edges = parsedElements.filter(ele => ele.data.source);
            const filteredNodes = nodes.filter(node => node.data.ClusterID === targetCluster);
            const nodeIdSet = new Set(filteredNodes.map(node => node.data.id));
            const filteredEdges = edges.filter(edge => nodeIdSet.has(edge.data.source) && nodeIdSet.has(edge.data.target));
            elementsToVisualize = filteredNodes.concat(filteredEdges);
          }
        }
        visualizeNetwork(elementsToVisualize);
        setupTimeSlider();
        if (userSource && userDestination) {
          globalCy.edges().forEach(edge => {
            if (edge.data('source') === userSource && edge.data('target') === userDestination) {
              edge.addClass('selected');
              (edge.data('csvIndices') || []).forEach(idx => selectedEdges.add(idx));
            }
          });
          updateKeywordSuggestions();
          updateRowVisibility();
        }
      } catch (err) {
        console.error("Error processing file:", err);
        alert("An error occurred while processing the CSV. See console for details.");
      } finally {
        loadingOverlay.style.display = "none";
      }
    });

    // Updated function to display all columns in the table.
    function createFullTable() {
      const container = document.getElementById('table-container');
      container.innerHTML = '';
      allRowElems = [];
      if (csvRows.length < 2) return;
      const table = document.createElement('table');
      // Use all headers as they are in the processed CSV.
      const originalHeaders = csvRows[0].split(',').map(c => c.replace(/(^"|"$)/g, ''));
      const headersToShow = originalHeaders; // No exclusions.
      payloadColumnIndex = headersToShow.findIndex(col => col.toLowerCase() === "payload");
      const hdrTr = document.createElement('tr');
      headersToShow.forEach(col => {
        let th = document.createElement('th');
        th.textContent = col;
        hdrTr.appendChild(th);
      });
      table.appendChild(hdrTr);
      for (let i = 1; i < csvRows.length; i++) {
        let tr = document.createElement('tr');
        tr.setAttribute('data-index', i);
        let cols = csvRows[i].split(',');
        // Use all columns from the row.
        cols.forEach(c => {
          let td = document.createElement('td');
          td.textContent = c.replace(/(^"|"$)/g, '');
          tr.appendChild(td);
        });
        tr.addEventListener('click', function() {
          const rowIndex = parseInt(this.getAttribute('data-index'));
          if (globalCy) {
            let targetEdge = null;
            globalCy.edges().some(edge => {
              if ((edge.data('csvIndices') || []).includes(rowIndex)) {
                targetEdge = edge;
                return true;
              }
              return false;
            });
            if (targetEdge) {
              globalCy.edges().removeClass('selected');
              selectedEdges.clear();
              targetEdge.addClass('selected');
              (targetEdge.data('csvIndices') || []).forEach(idx => selectedEdges.add(idx));
              updateKeywordSuggestions();
              globalCy.animate({
                fit: { eles: targetEdge, padding: 50 },
                duration: 500
              });
              updateRowVisibility();
            }
          }
        });
        table.appendChild(tr);
        allRowElems.push(tr);
      }
      container.appendChild(table);
      displayOffset = 0;
      updateRowVisibility();
    }

    function updateRowVisibility() {
      if (!csvRows || csvRows.length < 2 || allRowElems.length === 0) return;
      let allowed = [];
      if (selectedEdges.size === 0) {
        for (let i = 1; i < csvRows.length; i++){
          allowed.push(i);
        }
      } else {
        allowed = Array.from(selectedEdges);
      }
      allowed.sort((a, b) => a - b);
      const filterText = payloadFilterInput.value.trim().toLowerCase();
      if (filterText && payloadColumnIndex !== -1) {
        allowed = allowed.filter(rowIndex => {
          let rowElem = allRowElems[rowIndex - 1];
          if (rowElem && rowElem.cells && rowElem.cells.length > payloadColumnIndex) {
            let cellText = rowElem.cells[payloadColumnIndex].textContent.toLowerCase();
            return cellText.includes(filterText);
          }
          return false;
        });
      }
      allRowElems.forEach(row => row.style.display = 'none');
      currentAllowed = allowed;
      displayOffset = 0;
      showNextChunk();
    }

    function showNextChunk() {
      if (!currentAllowed || currentAllowed.length === 0) {
        loadMoreBtn.style.display = 'none';
        return;
      }
      let start = displayOffset;
      let end = start + PAGE_SIZE;
      if (end > currentAllowed.length) {
        end = currentAllowed.length;
      }
      for (let i = start; i < end; i++) {
        let rowIndex = currentAllowed[i];
        if (rowIndex - 1 >= 0 && rowIndex - 1 < allRowElems.length) {
          allRowElems[rowIndex - 1].style.display = 'table-row';
        }
      }
      displayOffset = end;
      loadMoreBtn.style.display = (displayOffset >= currentAllowed.length) ? 'none' : 'inline-block';
    }

    function parseCSV(text) {
      if (!text) return [];
      let lines = text.trim().split('\n');
      if (lines.length < 2) return [];
      const header = lines[0].split(',').map(s => s.replace(/(^"|"$)/g, '').trim());
      const sourceClassIdx = header.indexOf("SourceClassification");
      const destinationClassIdx = header.indexOf("DestinationClassification");
      const clusterIdIdx = header.indexOf("ClusterID");
      let seenNodes = new Set();
      let edgesMap = new Map();
      let nodeElements = [];
      for (let i = 1; i < lines.length; i++){
        let rowNumber = i;
        let cols = lines[i].split(',').map(c => c.replace(/(^"|"$)/g, ''));
        const sourceIdx = header.indexOf('Source');
        const destIdx = header.indexOf('Destination');
        const protocolIdx = header.indexOf('Protocol');
        const source = cols[sourceIdx]?.trim();
        const destination = cols[destIdx]?.trim();
        const protocol = cols[protocolIdx]?.trim();
        const nodeWeight = parseFloat(cols[8]) || 0;
        const sourceClassification = sourceClassIdx !== -1 ? cols[sourceClassIdx]?.trim() : 'External';
        const destinationClassification = destinationClassIdx !== -1 ? cols[destinationClassIdx]?.trim() : 'External';
        const clusterID = (clusterIdIdx !== -1) ? cols[clusterIdIdx]?.trim() : null;
        if (source && !seenNodes.has(source)) {
          nodeElements.push({
            data: {
              id: source,
              label: source,
              Classification: sourceClassification,
              NodeWeight: nodeWeight,
              timeIndex: rowNumber,
              ClusterID: clusterID
            }
          });
          seenNodes.add(source);
        }
        if (destination && !seenNodes.has(destination)) {
          nodeElements.push({
            data: {
              id: destination,
              label: destination,
              Classification: destinationClassification,
              NodeWeight: nodeWeight,
              timeIndex: rowNumber,
              ClusterID: clusterID
            }
          });
          seenNodes.add(destination);
        }
        if (!source || !destination || !protocol) continue;
        const edgeKey = source + '|' + destination + '|' + protocol;
        if (!edgesMap.has(edgeKey)) {
          edgesMap.set(edgeKey, {
            source, destination, protocol,
            csvIndices: [],
            totalEdgeWeight: 0
          });
        }
        let entry = edgesMap.get(edgeKey);
        entry.csvIndices.push(rowNumber);
        entry.totalEdgeWeight += parseFloat(cols[5]) || 0;
      }
      let edgeElements = [];
      edgesMap.forEach(val => {
        edgeElements.push({
          data: {
            id: `edge-${val.source}-${val.destination}-${val.protocol}`,
            source: val.source,
            target: val.destination,
            Protocol: val.protocol,
            EdgeWeight: val.totalEdgeWeight,
            processCount: val.csvIndices.length,
            csvIndices: val.csvIndices,
            label: `(${val.csvIndices.length}) ${val.protocol}`,
            edgeColor: protocolColorMap[val.protocol] || '#000'
          }
        });
      });
      return [...nodeElements, ...edgeElements];
    }

    function createEdgeFromCSVRow(row, rowIndex) {
      let cols = row.split(',').map(s => s.replace(/(^"|"$)/g, ''));
      let source = cols[csvHeaders.indexOf('Source')];
      let destination = cols[csvHeaders.indexOf('Destination')];
      let protocol = cols[csvHeaders.indexOf('Protocol')];
      return {
        data: {
          id: `edge-${source}-${destination}-${protocol}-${rowIndex}`,
          source: source,
          target: destination,
          Protocol: protocol,
          EdgeWeight: 1,
          processCount: 1,
          csvIndices: [rowIndex],
          label: `${protocol}`,
          edgeColor: protocolColorMap[protocol] || '#000'
        }
      };
    }

    function groupDirectedComponents(cy) {
      let visited = new Set();
      let groupCount = 0;
      function randomColor(){
        return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
      }
      cy.nodes().forEach(node => {
        if (!visited.has(node.id())) {
          groupCount++;
          const color = randomColor();
          let bfs = cy.elements().bfs({ roots: node, directed: true });
          bfs.path.forEach(ele => {
            if (ele.isNode()) {
              visited.add(ele.id());
              ele.data('groupID', groupCount);
              ele.data('color', color);
            }
          });
        }
      });
    }

    function positionGroupedComponentsTree(cy) {
      let groupMap = {};
      cy.nodes().forEach(n => {
        let g = n.data('groupID') || 0;
        if (!groupMap[g]) groupMap[g] = [];
        groupMap[g].push(n);
      });
      let sortedGroups = Object.entries(groupMap).sort((a, b) => b[1].length - a[1].length);
      let groupYOffset = 0;
      const verticalSpacingBetweenGroups = 300;
      const levelHeight = 80;
      const siblingSpacing = 100;
      sortedGroups.forEach(([groupID, nodes]) => {
        let root = nodes.reduce((prev, curr) => {
          return (!prev || (curr.data('timeIndex') < prev.data('timeIndex'))) ? curr : prev;
        }, null);
        if (!root) return;
        let levels = {};
        let visited = new Set();
        let queue = [];
        levels[root.id()] = 0;
        visited.add(root.id());
        queue.push(root);
        while (queue.length > 0) {
          let current = queue.shift();
          let currentLevel = levels[current.id()];
          current.outgoers('edge').forEach(edge => {
            let target = edge.target();
            if (target.data('groupID') == groupID && !visited.has(target.id())) {
              levels[target.id()] = currentLevel + 1;
              visited.add(target.id());
              queue.push(target);
            }
          });
        }
        let levelNodes = {};
        nodes.forEach(n => {
          let lvl = levels[n.id()] !== undefined ? levels[n.id()] : 0;
          if (!levelNodes[lvl]) levelNodes[lvl] = [];
          levelNodes[lvl].push(n);
        });
        Object.keys(levelNodes).forEach(lvlKey => {
          let lvl = parseInt(lvlKey);
          let nodesAtLevel = levelNodes[lvl];
          nodesAtLevel.sort((a, b) => (a.data('timeIndex') || 0) - (b.data('timeIndex') || 0));
          let totalWidth = (nodesAtLevel.length - 1) * siblingSpacing;
          let startX = -totalWidth / 2;
          nodesAtLevel.forEach((n, idx) => {
            let x = startX + idx * siblingSpacing;
            let y = groupYOffset + lvl * levelHeight;
            n.position({x: x, y: y});
          });
        });
        let maxLevel = Math.max(...Object.keys(levelNodes).map(Number));
        groupYOffset += (maxLevel + 1) * levelHeight + verticalSpacingBetweenGroups;
      });
    }

    function visualizeNetwork(elements) {
      const cy = cytoscape({
        container: document.getElementById('cy'),
        elements,
        layout: { name: 'preset' },
        style: [
          {
            selector: 'node',
            style: {
              'color': '#000',
              'font-size': 12,
              'text-valign': 'center',
              'text-halign': 'center',
              'shape': 'ellipse',
              'font-family': 'Arial, sans-serif',
              'font-weight': 'bold',
              'text-opacity': 0,
              'width': 'mapData(NodeWeight, 0, 1, 20, 40)',
              'height': 'mapData(NodeWeight, 0, 1, 20, 40)',
              'background-color': 'mapData(NodeWeight, 0, 1, #d4f0d4, #006400)',
              'border-width': 2.0,
              'content': 'data(label)'
            }
          },
          {
            selector: 'node[Classification="Internal"]',
            style: { 'shape': 'rectangle' }
          },
          {
            selector: 'node[color]',
            style: { 'background-color': 'data(color)' }
          },
          {
            selector: 'edge',
            style: {
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'control-point-step-size': 30,
              'width': 'data(normalizedWeight)',
              'line-color': 'data(edgeColor)',
              'target-arrow-color': 'data(edgeColor)',
              'opacity': 0.8
            }
          },
          {
            selector: 'edge.selected',
            style: {
              'line-color': 'red',
              'target-arrow-color': 'red',
              'width': 4
            }
          }
        ]
      });
      cy.zoom(0.5);
      globalCy = cy;
      groupDirectedComponents(cy);
      positionGroupedComponentsTree(cy);
      let groupEdges = {};
      globalCy.edges().forEach(edge => {
        let sourceGroup = edge.source().data('groupID');
        let targetGroup = edge.target().data('groupID');
        if(sourceGroup && sourceGroup === targetGroup) {
          if(!groupEdges[sourceGroup]) groupEdges[sourceGroup] = [];
          groupEdges[sourceGroup].push(edge);
        }
      });
      Object.keys(groupEdges).forEach(groupID => {
        let edges = groupEdges[groupID];
        let counts = edges.map(e => e.data('processCount'));
        let minCount = Math.min(...counts);
        let maxCount = Math.max(...counts);
        edges.forEach(e => {
          let count = e.data('processCount');
          let norm = 2;
          if(maxCount !== minCount) {
            norm = 2 + ((count - minCount) / (maxCount - minCount)) * (10 - 2);
          }
          e.data('normalizedWeight', norm);
        });
      });
      globalCy.edges().forEach(edge => {
        if(edge.data('normalizedWeight') === undefined) {
          edge.data('normalizedWeight', 2);
        }
      });
      cy.on('mouseover', 'node,edge', (evt) => {
        let t = evt.target;
        let px = evt.originalEvent.pageX;
        let py = evt.originalEvent.pageY;
        tooltip.style.display = 'block';
        tooltip.style.left = (px + 10) + 'px';
        tooltip.style.top = (py + 10) + 'px';
        if (t.isNode()) {
          tooltip.innerHTML = `<strong>Node ID:</strong> ${t.id()}<br>
                               <strong>Classification:</strong> ${t.data('Classification')}<br>
                               <strong>Group:</strong> ${t.data('groupID') || 'N/A'}<br>`;
        } else {
          let arr = t.data('csvIndices') || [];
          tooltip.innerHTML = `<strong>Edge:</strong><br>
                               From: ${t.data('source')}<br>
                               To: ${t.data('target')}<br>
                               Protocol: ${t.data('Protocol')}<br>
                               Rows: ${arr.length}`;
        }
      });
      cy.on('mouseout', 'node,edge', () => {
        tooltip.style.display = 'none';
      });
      cy.on('click', 'edge', (evt) => {
        let edge = evt.target;
        if (evt.originalEvent.shiftKey) {
          let groupID = edge.source().data('groupID');
          if (groupID !== undefined) {
            cy.edges().forEach(e => {
              if (e.source().data('groupID') === groupID &&
                  e.target().data('groupID') === groupID) {
                let indices = e.data('csvIndices') || [];
                indices.forEach(idx => selectedEdges.add(idx));
                e.addClass('selected');
              }
            });
          }
        } else {
          let indices = edge.data('csvIndices') || [];
          if (!indices.length) return;
          let allSelected = indices.every(idx => selectedEdges.has(idx));
          if (allSelected) {
            indices.forEach(idx => selectedEdges.delete(idx));
            edge.removeClass('selected');
          } else {
            indices.forEach(idx => selectedEdges.add(idx));
            edge.addClass('selected');
          }
        }
        updateKeywordSuggestions();
        displayOffset = 0;
        updateRowVisibility();
      });
    }
  </script>
</body>
</html>
